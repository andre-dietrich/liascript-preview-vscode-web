// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"eha9F":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "5bd0225e1b6425ef";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, globalThis, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets, assetsToDispose, assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
} // eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/"); // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome; // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    } // $FlowFixMe
    ws.onmessage = async function(event) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH); // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear(); // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets); // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                } // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html); // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ‚ú® Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          üö® ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>üìù <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", link.getAttribute("href").split("?")[0] + "?" + Date.now()); // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle, asset) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
             // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        } // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id]; // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle, id, depsByBundle) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
     // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle, id, depsByBundle) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle, id) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle, id) {
    // Execute the module.
    bundle(id); // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            }); // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"hTFxQ":[function(require,module,exports) {
// @ts-ignore
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
var _ace = require("ace-builds/src-min-noconflict/ace");
var _aceDefault = parcelHelpers.interopDefault(_ace);
var _editorModes = require("./editor-modes");
var _aceCollabExt = require("@convergencelabs/ace-collab-ext");
var _aceCollabExtMinCss = require("@convergencelabs/ace-collab-ext/dist/css/ace-collab-ext.min.css");
function markerStyle(name) {
    if (typeof name === "string") name = "ace_color_" + name.replace(/ /g, "").replace(/\./g, "").replace(/,/g, "_").replace(/\(/g, "").replace(/\)/g, "");
    return name;
}
function addMarker(color, name) {
    if (!color) return;
    const id = markerStyle(name || color);
    if (!document.head.querySelector("style#" + id)) {
        let node = document.createElement("style");
        // node.type ='text/css'
        node.id = id;
        node.appendChild(document.createTextNode(`.${id} {
        position:absolute;
        background:${color};
        z-index:20
      }`));
        document.getElementsByTagName("head")[0].appendChild(node);
    }
}
function throttle(cb, delay = 500) {
    let storedChange = [];
    let storedCursor;
    let timerID = null;
    function checkStoredArgs() {
        if (storedChange.length > 0 || storedCursor) {
            cb(storedChange, storedCursor);
            storedChange = [];
            storedCursor = undefined;
        }
        timerID = null;
    }
    return (change, cursor)=>{
        if (timerID) window.clearTimeout(timerID);
        if (change !== null) storedChange.push(change);
        if (cursor) storedCursor = cursor;
        timerID = window.setTimeout(checkStoredArgs, delay);
    };
}
/*
function debounce(cb: (_: any) => void, delay: number = 1000) {
  let storedArg: any | undefined
  let timerID: number | null = null

  function checkStoredArgs() {
    if (storedArg !== undefined) {
      cb(storedArg)
      storedArg = undefined
    }

    timerID = null
  }

  return (arg: any) => {
    if (timerID) {
      window.clearTimeout(timerID)
    }

    storedArg = arg
    timerID = window.setTimeout(checkStoredArgs, delay)
  }
}
*/ customElements.define("lia-editor", class extends HTMLElement {
    _blockUpdate = false;
    _blockEvents = false;
    _cursors = [];
    _catchCursorUpdates = false;
    constructor(){
        super();
        (0, _aceDefault.default).config.set("basePath", ".");
        this._focus = false;
        this._ariaLabel = "editor";
        this.model = {
            value: "",
            theme: "dreamweaver",
            mode: "text",
            shared: null,
            showPrintMargin: true,
            highlightActiveLine: true,
            firstLineNumber: 1,
            tabSize: 4,
            useSoftTabs: true,
            useWrapMode: false,
            readOnly: false,
            showCursor: true,
            showGutter: true,
            extensions: [],
            maxLines: Infinity,
            marker: "",
            minLines: 1,
            annotations: [],
            fontSize: "1.5rem",
            fontFamily: "var(--global-font-mono,)",
            enableKeyboardAccessibility: true
        };
        let markers = {
            error: "rgba(255,0,0,0.3)",
            warn: "rgba(255,255,102,0.3)",
            debug: "rgba(100,100,100,0.3)",
            info: "rgba(0,255,0,0.3)",
            log: "rgba(0,0,255,0.3)"
        };
        try {
            Object.entries(markers).forEach((entry)=>{
                const [name, color] = entry;
                addMarker(color, name);
            });
        } catch (e) {
            console.warn("ace.js => ", e);
        }
    }
    connectedCallback() {
        this.setExtension();
        this._editor = (0, _aceDefault.default).edit(this, {
            value: this.model.value,
            theme: "ace/theme/" + this.model.theme,
            mode: _editorModes.getMode(this.model.mode),
            showPrintMargin: this.model.showPrintMargin,
            highlightActiveLine: this.model.highlightActiveLine,
            firstLineNumber: this.model.firstLineNumber,
            tabSize: this.model.tabSize,
            useSoftTabs: this.model.useSoftTabs,
            readOnly: this.model.readOnly,
            showGutter: this.model.showGutter,
            minLines: this.model.minLines,
            maxLines: this.model.maxLines,
            fontSize: this.model.fontSize,
            fontFamily: this.model.fontFamily,
            highlightGutterLine: false,
            enableKeyboardAccessibility: this.model.enableKeyboardAccessibility
        });
        if (!this.model.showCursor) this._editor.renderer.$cursorLayer.element.style.display = "none";
        this._editor.renderer.setScrollMargin(8, 8, 0, 0);
        this._editor.getSession().setUseWrapMode(this.model.useWrapMode);
        this._editor.setAutoScrollEditorIntoView(true);
        const input = this._editor.textInput.getElement();
        const dispatchUpdateEvent = throttle((changes, cursor)=>{
            if (changes.length > 0) this.dispatchEvent(new CustomEvent("editorUpdateEvent", {
                detail: changes
            }));
            if (cursor) this.dispatchEvent(new CustomEvent("editorUpdateCursor", {
                detail: cursor
            }));
        });
        input.setAttribute("role", "application");
        if (!this.model.readOnly) {
            const runDispatch = (event)=>{
                if (this._blockEvents) return;
                this.model.value = this._editor.getValue();
                this.dispatchEvent(new CustomEvent("editorUpdate", {
                    detail: this.model.value
                }));
                if (!this.blockUpdate) dispatchUpdateEvent({
                    action: event.action,
                    index: this._editor.getSession().doc.positionToIndex(event.start, 0),
                    content: event.lines.join("\n")
                });
            };
            const cursorDispatch = ()=>{
                if (this.catchCursorUpdates && this._editor) {
                    const { start , end  } = this._editor.getSelectionRange();
                    const selection = start.row == end.row && start.column == end.column ? [] : [
                        start.row,
                        start.column,
                        end.row,
                        end.column
                    ];
                    this.cursorPosition = this._editor.selection.getCursor();
                    if (this.cursorPosition) dispatchUpdateEvent(null, {
                        position: this.cursorPosition,
                        selection
                    });
                }
            };
            this._editor.on("change", runDispatch);
            this._editor.session.selection.on("changeCursor", cursorDispatch);
            const self = this;
            this._editor.commands.addCommand({
                name: "Ctrl-Enter",
                bindKey: {
                    win: "Ctrl-Enter",
                    mac: "Command-Enter"
                },
                exec: function(editor) {
                    self.dispatchEvent(new CustomEvent("editorCtrlEnter"));
                },
                readOnly: false
            });
            input.setAttribute("aria-label", "Code-editor in " + this.model.mode + " mode");
        } else input.setAttribute("aria-label", "Code-block in " + this.model.mode + " mode");
        let self = this;
        this._editor.on("focus", function() {
            self._focus = true;
            self.dispatchEvent(new CustomEvent("editorFocus"));
        });
        this._editor.on("blur", function() {
            self._focus = false;
            self.dispatchEvent(new CustomEvent("editorFocus"));
            self._editor.clearSelection();
        });
        this.setMarker();
        if (this._focus) this.setFocus();
    }
    disconnectedCallback() {
    // todo
    }
    setOption(option, value) {
        /*if ((this.model[option] as any) == value) return

    this.model[option] = value
    */ if (this._editor) try {
            this._editor.setOption(option, value);
        } catch (e) {
            console.log("Problem Ace: setOption ", option, value, " => ", e.toString());
        }
    }
    get annotations() {
        return this.model.annotations;
    }
    set annotations(list) {
        if (this.model.annotations === list) return;
        if (list == null) this.model.annotations = [];
        else this.model.annotations = list;
        if (!this._editor) return;
        try {
            this._editor.getSession().setAnnotations(this.model.annotations);
        } catch (e) {
            console.log("Problem Ace: setAnnotations ", this.model.annotations, " => ", e.toString());
        }
    }
    get extensions() {
        return this.model.extensions;
    }
    set extensions(values) {
        if (this.model.extensions === values) return;
        this.model.extensions = values;
        if (!this._editor) return;
        this.setExtension();
    }
    setExtension() {
        for(const ext in this.model.extensions)try {
            (0, _aceDefault.default).require("ace/ext/" + ext);
        } catch (e) {
            console.log("Problem Ace: require ", ext, " => ", e.toString());
        }
    }
    get fontSize() {
        return this.model.fontSize;
    }
    set fontSize(value) {
        if (this.model.fontSize !== value) {
            this.model.fontSize = value;
            this.setOption("fontSize", value);
        }
    }
    get enableKeyboardAccessibility() {
        return this.model.enableKeyboardAccessibility;
    }
    set enableKeyboardAccessibility(value) {
        if (this.model.enableKeyboardAccessibility !== value) {
            this.model.enableKeyboardAccessibility = value;
            this.setOption("enableKeyboardAccessibility", value);
        }
    }
    setMarker() {
        let Range = (0, _aceDefault.default).require("ace/range").Range;
        let value = this.model.marker.replace("\n", "").split(";").filter((e)=>e !== "");
        for(let i = 0; i < value.length; i++){
            let m = value[i].trim().split(" ").map((e)=>e.trim()).filter((e)=>e !== "");
            addMarker(m[4]);
            this._editor.session.addMarker(new Range(parseInt(m[0]), parseInt(m[1]), parseInt(m[2]), parseInt(m[3])), markerStyle(m[4]), m[5] ? m[5] : "fullLine");
        }
    }
    get marker() {
        return this.model.marker;
    }
    set marker(value) {
        this.model.marker = value;
    }
    get firstLineNumber() {
        return this.model.firstLineNumber;
    }
    set firstLineNumber(value) {
        if (this.model.firstLineNumber !== value) {
            this.model.firstLineNumber = value;
            this.setOption("firstLineNumber", value);
        }
    }
    get highlightActiveLine() {
        return this.model.highlightActiveLine;
    }
    set highlightActiveLine(value) {
        if (this.model.highlightActiveLine !== value) {
            this.model.highlightActiveLine = value;
            this.setOption("highlightActiveLine", value);
        }
    }
    get maxLines() {
        return this.model.maxLines;
    }
    set maxLines(value) {
        value = value < 0 ? Infinity : value;
        if (this.model.maxLines !== value) {
            this.model.maxLines = value;
            this.setOption("maxLines", value);
        }
    }
    get minLines() {
        return this.model.minLines;
    }
    set minLines(value) {
        value = value < 0 ? 1 : value;
        if (this.model.minLines !== value) {
            this.model.minLines = value;
            this.setOption("minLines", value);
        }
    }
    get mode() {
        return this.model.mode;
    }
    set mode(mode) {
        if (this.model.mode === mode) return;
        this.model.mode = mode;
        if (!this._editor) return;
        try {
            this._editor.getSession().setMode(_editorModes.getMode(mode));
        } catch (e) {
            console.log("Problem Ace: setMode(", mode, ") => ", e.toString());
        }
    }
    get readOnly() {
        return this.model.readOnly;
    }
    set readOnly(value) {
        if (this.model.readOnly !== value) {
            this.model.readOnly = value;
            this.setOption("readOnly", value);
        }
    }
    get showCursor() {
        return this.model.showCursor;
    }
    set showCursor(value) {
        if (this.model.showCursor !== value) {
            this.model.showCursor = value;
            this.setOption("showCursor", value);
        }
    }
    get showGutter() {
        return this.model.showGutter;
    }
    set showGutter(value) {
        if (this.model.showGutter !== value) {
            this.model.showGutter = value;
            this.setOption("showGutter", value);
        }
    }
    get showPrintMargin() {
        return this.model.showPrintMargin;
    }
    set showPrintMargin(value) {
        if (this.model.showPrintMargin !== value) {
            this.model.showPrintMargin = value;
            this.setOption("showPrintMargin", value);
        }
    }
    get tabSize() {
        return this.model.tabSize;
    }
    set tabSize(value) {
        if (this.model.tabSize !== value) {
            this.model.tabSize = value;
            this.setOption("tabSize", value);
        }
    }
    get theme() {
        return this.model.theme;
    }
    set theme(theme) {
        if (this.model.theme === theme || theme === "") return;
        this.model.theme = theme;
        if (!this._editor) return;
        this._editor.setTheme("ace/theme/" + theme);
    }
    get useSoftTabs() {
        return this.model.useSoftTabs;
    }
    set useSoftTabs(value) {
        if (this.model.useSoftTabs !== value) {
            this.model.useSoftTabs = value;
            this.setOption("useSoftTabs", value);
        }
    }
    get useWrapMode() {
        return this.model.useWrapMode;
    }
    set useWrapMode(value) {
        if (this.model.useWrapMode !== value) {
            this.model.useWrapMode = value;
            this.setOption("useWrapMode", value);
        }
    }
    get value() {
        return this.model.value;
    }
    async setValue(value) {
        const session = await this.getSession();
        this._blockEvents = true;
        this.blockUpdate = true;
        this.model.value = value;
        const cursor = this._editor.getCursorPosition();
        session.setValue(value);
        this._editor.moveCursorToPosition(cursor);
        this._blockEvents = false;
        this.blockUpdate = false;
    }
    set value(value) {
        if (this.model.value !== value) this.setValue(value);
    }
    get blockUpdate() {
        //console.warn('Getting block of ->', this._blockUpdate)
        return this._blockUpdate;
    }
    set blockUpdate(value) {
        //console.warn('Setting block to ->', value)
        this._blockUpdate = value;
    }
    get catchCursorUpdates() {
        //console.warn('Getting block of ->', this._blockUpdate)
        return this._catchCursorUpdates;
    }
    set catchCursorUpdates(value) {
        if (this._catchCursorUpdates !== value) {
            this._catchCursorUpdates = value;
            this.setCursors();
        }
    }
    async getSession() {
        if (this._editor) return Promise.resolve(this._editor.getSession()) // object already exists, return it immediately
        ;
        const self = this;
        return new Promise((resolve, reject)=>{
            let elapsed = 0;
            const checkExistence = setInterval(()=>{
                elapsed += 100;
                if (self._editor) {
                    // check if the object exists
                    clearInterval(checkExistence) // stop checking
                    ;
                    resolve(self._editor.getSession()) // return the object
                    ;
                } else if (elapsed >= 1000) {
                    clearInterval(checkExistence) // stop checking
                    ;
                    reject(null) // return null if object is not created after maxDelay
                    ;
                }
            }, 100);
        });
    }
    /**
     * Initialize the collaborative cursors, if collaborative is set to true, otherwise delete the cursorManager.
     */ async setCursors() {
        if (this._catchCursorUpdates) {
            if (!this.cursorManager) {
                const session = await this.getSession();
                this.cursorManager = new _aceCollabExt.AceMultiCursorManager(session);
                this.selectManager = new _aceCollabExt.AceMultiSelectionManager(session);
                for (let { id , color , position  } of this._cursors)this.cursorManager.addCursor(id, "", color, position);
            }
        } else if (this.cursorManager) {
            this.cursorManager.removeAll();
            this.selectManager.removeAll();
            delete this.cursorManager;
        }
    }
    get cursors() {
        return this._cursors;
    }
    set cursors(value) {
        if (this.cursorManager) try {
            // delete all not existing cursors
            for (let oldCursor of this._cursors){
                let remove = true;
                for (let newCursor of value)if (oldCursor.id == newCursor.id) {
                    remove = false;
                    break;
                }
                if (remove) {
                    this.cursorManager.removeCursor(oldCursor.id);
                    try {
                        this.selectManager.clearSelection(oldCursor.id);
                    } catch (e) {}
                    try {
                        this.selectManager.removeSelection(oldCursor.id);
                    } catch (e) {}
                }
            }
            for (let newCursor of value){
                let add = true;
                for (let oldCursor of this._cursors)if (oldCursor.id == newCursor.id) {
                    add = false;
                    break;
                }
                if (add) {
                    this.cursorManager.addCursor(newCursor.id, "", newCursor.color, newCursor.position);
                    this.selectManager.addSelection(newCursor.id, "", newCursor.color, this.toRange(newCursor.selection));
                } else {
                    this.cursorManager.setCursor(newCursor.id, newCursor.position);
                    try {
                        this.selectManager.clearSelection(newCursor.id);
                    } catch (e) {}
                    this.selectManager.setSelection(newCursor.id, this.toRange(newCursor.selection));
                }
            }
        } catch (e) {
            console.warn("ace error:", e.message);
        }
        this._cursors = value;
    }
    toRange(selection) {
        if (selection.length === 0) return [];
        let Range = (0, _aceDefault.default).require("ace/range").Range;
        const [start1, end1, start2, end2] = selection;
        return [
            new Range(start1, end1, start2, end2)
        ];
    }
    get focusing() {
        return this._focus;
    }
    set focusing(value) {
        this._focus = value;
        if (value) this.setFocus();
    }
    setFocus() {
        if (!this._editor) return;
        try {
            this._editor.focus();
        } catch (e) {
            console.log("Problem Ace: focus => ", e.toString());
        }
    }
});

},{"ace-builds/src-min-noconflict/ace":"8HYmZ","./editor-modes":"dfUSf","@convergencelabs/ace-collab-ext":"8GLpd","@convergencelabs/ace-collab-ext/dist/css/ace-collab-ext.min.css":"3EO9f","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8HYmZ":[function(require,module,exports) {
(function() {
    function o(n) {
        var i = e;
        n && (e[n] || (e[n] = {}), i = e[n]);
        if (!i.define || !i.define.packaged) t.original = i.define, i.define = t, i.define.packaged = !0;
        if (!i.require || !i.require.packaged) r.original = i.require, i.require = r, i.require.packaged = !0;
    }
    var ACE_NAMESPACE = "ace", e = function() {
        return this;
    }();
    !e && typeof window != "undefined" && (e = window);
    if (!ACE_NAMESPACE && typeof requirejs != "undefined") return;
    var t = function(e, n, r) {
        if (typeof e != "string") {
            t.original ? t.original.apply(this, arguments) : (console.error("dropping module because define wasn't a string."), console.trace());
            return;
        }
        arguments.length == 2 && (r = n), t.modules[e] || (t.payloads[e] = r, t.modules[e] = null);
    };
    t.modules = {}, t.payloads = {};
    var n = function(e, t, n) {
        if (typeof t == "string") {
            var i = s(e, t);
            if (i != undefined) return n && n(), i;
        } else if (Object.prototype.toString.call(t) === "[object Array]") {
            var o = [];
            for(var u = 0, a = t.length; u < a; ++u){
                var f = s(e, t[u]);
                if (f == undefined && r.original) return;
                o.push(f);
            }
            return n && n.apply(null, o) || !0;
        }
    }, r = function(e, t) {
        var i = n("", e, t);
        return i == undefined && r.original ? r.original.apply(this, arguments) : i;
    }, i = function(e, t) {
        if (t.indexOf("!") !== -1) {
            var n = t.split("!");
            return i(e, n[0]) + "!" + i(e, n[1]);
        }
        if (t.charAt(0) == ".") {
            var r = e.split("/").slice(0, -1).join("/");
            t = r + "/" + t;
            while(t.indexOf(".") !== -1 && s != t){
                var s = t;
                t = t.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
        }
        return t;
    }, s = function(e, r) {
        r = i(e, r);
        var s = t.modules[r];
        if (!s) {
            s = t.payloads[r];
            if (typeof s == "function") {
                var o = {}, u = {
                    id: r,
                    uri: "",
                    exports: o,
                    packaged: !0
                }, a = function(e, t) {
                    return n(r, e, t);
                }, f = s(a, o, u);
                o = f || u.exports, t.modules[r] = o, delete t.payloads[r];
            }
            s = t.modules[r] = o || s;
        }
        return s;
    };
    o(ACE_NAMESPACE);
})(), ace.define("ace/lib/es6-shim", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    function r(e, t, n) {
        Object.defineProperty(e, t, {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0
        });
    }
    String.prototype.startsWith || r(String.prototype, "startsWith", function(e, t) {
        return t = t || 0, this.lastIndexOf(e, t) === t;
    }), String.prototype.endsWith || r(String.prototype, "endsWith", function(e, t) {
        var n = this;
        if (t === undefined || t > n.length) t = n.length;
        t -= e.length;
        var r = n.indexOf(e, t);
        return r !== -1 && r === t;
    }), String.prototype.repeat || r(String.prototype, "repeat", function(e) {
        var t = "", n = this;
        while(e > 0){
            e & 1 && (t += n);
            if (e >>= 1) n += n;
        }
        return t;
    }), String.prototype.includes || r(String.prototype, "includes", function(e, t) {
        return this.indexOf(e, t) != -1;
    }), Object.assign || (Object.assign = function(e) {
        if (e === undefined || e === null) throw new TypeError("Cannot convert undefined or null to object");
        var t = Object(e);
        for(var n = 1; n < arguments.length; n++){
            var r = arguments[n];
            r !== undefined && r !== null && Object.keys(r).forEach(function(e) {
                t[e] = r[e];
            });
        }
        return t;
    }), Object.values || (Object.values = function(e) {
        return Object.keys(e).map(function(t) {
            return e[t];
        });
    }), Array.prototype.find || r(Array.prototype, "find", function(e) {
        var t = this.length, n = arguments[1];
        for(var r = 0; r < t; r++){
            var i = this[r];
            if (e.call(n, i, r, this)) return i;
        }
    }), Array.prototype.findIndex || r(Array.prototype, "findIndex", function(e) {
        var t = this.length, n = arguments[1];
        for(var r = 0; r < t; r++){
            var i = this[r];
            if (e.call(n, i, r, this)) return r;
        }
    }), Array.prototype.includes || r(Array.prototype, "includes", function(e, t) {
        return this.indexOf(e, t) != -1;
    }), Array.prototype.fill || r(Array.prototype, "fill", function(e) {
        var t = this, n = t.length >>> 0, r = arguments[1], i = r >> 0, s = i < 0 ? Math.max(n + i, 0) : Math.min(i, n), o = arguments[2], u = o === undefined ? n : o >> 0, a = u < 0 ? Math.max(n + u, 0) : Math.min(u, n);
        while(s < a)t[s] = e, s++;
        return t;
    }), Array.of || r(Array, "of", function() {
        return Array.prototype.slice.call(arguments);
    });
}), ace.define("ace/lib/fixoldbrowsers", [
    "require",
    "exports",
    "module",
    "ace/lib/es6-shim"
], function(e, t, n) {
    "use strict";
    e("./es6-shim");
}), ace.define("ace/lib/deep_copy", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    t.deepCopy = function r(e) {
        if (typeof e != "object" || !e) return e;
        var t;
        if (Array.isArray(e)) {
            t = [];
            for(var n = 0; n < e.length; n++)t[n] = r(e[n]);
            return t;
        }
        if (Object.prototype.toString.call(e) !== "[object Object]") return e;
        t = {};
        for(var n in e)t[n] = r(e[n]);
        return t;
    };
}), ace.define("ace/lib/lang", [
    "require",
    "exports",
    "module",
    "ace/lib/deep_copy"
], function(e, t, n) {
    "use strict";
    t.last = function(e) {
        return e[e.length - 1];
    }, t.stringReverse = function(e) {
        return e.split("").reverse().join("");
    }, t.stringRepeat = function(e, t) {
        var n = "";
        while(t > 0){
            t & 1 && (n += e);
            if (t >>= 1) e += e;
        }
        return n;
    };
    var r = /^\s\s*/, i = /\s\s*$/;
    t.stringTrimLeft = function(e) {
        return e.replace(r, "");
    }, t.stringTrimRight = function(e) {
        return e.replace(i, "");
    }, t.copyObject = function(e) {
        var t = {};
        for(var n in e)t[n] = e[n];
        return t;
    }, t.copyArray = function(e) {
        var t = [];
        for(var n = 0, r = e.length; n < r; n++)e[n] && typeof e[n] == "object" ? t[n] = this.copyObject(e[n]) : t[n] = e[n];
        return t;
    }, t.deepCopy = e("./deep_copy").deepCopy, t.arrayToMap = function(e) {
        var t = {};
        for(var n = 0; n < e.length; n++)t[e[n]] = 1;
        return t;
    }, t.createMap = function(e) {
        var t = Object.create(null);
        for(var n in e)t[n] = e[n];
        return t;
    }, t.arrayRemove = function(e, t) {
        for(var n = 0; n <= e.length; n++)t === e[n] && e.splice(n, 1);
    }, t.escapeRegExp = function(e) {
        return e.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
    }, t.escapeHTML = function(e) {
        return ("" + e).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    }, t.getMatchOffsets = function(e, t) {
        var n = [];
        return e.replace(t, function(e) {
            n.push({
                offset: arguments[arguments.length - 2],
                length: e.length
            });
        }), n;
    }, t.deferredCall = function(e) {
        var t = null, n = function() {
            t = null, e();
        }, r = function(e) {
            return r.cancel(), t = setTimeout(n, e || 0), r;
        };
        return r.schedule = r, r.call = function() {
            return this.cancel(), e(), r;
        }, r.cancel = function() {
            return clearTimeout(t), t = null, r;
        }, r.isPending = function() {
            return t;
        }, r;
    }, t.delayedCall = function(e, t) {
        var n = null, r = function() {
            n = null, e();
        }, i = function(e) {
            n == null && (n = setTimeout(r, e || t));
        };
        return i.delay = function(e) {
            n && clearTimeout(n), n = setTimeout(r, e || t);
        }, i.schedule = i, i.call = function() {
            this.cancel(), e();
        }, i.cancel = function() {
            n && clearTimeout(n), n = null;
        }, i.isPending = function() {
            return n;
        }, i;
    }, t.supportsLookbehind = function() {
        try {
            new RegExp("(?<=.)");
        } catch (e) {
            return !1;
        }
        return !0;
    }, t.skipEmptyMatch = function(e, t, n) {
        return n && e.codePointAt(t) > 65535 ? 2 : 1;
    };
}), ace.define("ace/lib/useragent", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    t.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
    }, t.getOS = function() {
        return t.isMac ? t.OS.MAC : t.isLinux ? t.OS.LINUX : t.OS.WINDOWS;
    };
    var r = typeof navigator == "object" ? navigator : {}, i = (/mac|win|linux/i.exec(r.platform) || [
        "other"
    ])[0].toLowerCase(), s = r.userAgent || "", o = r.appName || "";
    t.isWin = i == "win", t.isMac = i == "mac", t.isLinux = i == "linux", t.isIE = o == "Microsoft Internet Explorer" || o.indexOf("MSAppHost") >= 0 ? parseFloat((s.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((s.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]), t.isOldIE = t.isIE && t.isIE < 9, t.isGecko = t.isMozilla = s.match(/ Gecko\/\d+/), t.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]", t.isWebKit = parseFloat(s.split("WebKit/")[1]) || undefined, t.isChrome = parseFloat(s.split(" Chrome/")[1]) || undefined, t.isSafari = parseFloat(s.split(" Safari/")[1]) && !t.isChrome || undefined, t.isEdge = parseFloat(s.split(" Edge/")[1]) || undefined, t.isAIR = s.indexOf("AdobeAIR") >= 0, t.isAndroid = s.indexOf("Android") >= 0, t.isChromeOS = s.indexOf(" CrOS ") >= 0, t.isIOS = /iPad|iPhone|iPod/.test(s) && !window.MSStream, t.isIOS && (t.isMac = !0), t.isMobile = t.isIOS || t.isAndroid;
}), ace.define("ace/lib/dom", [
    "require",
    "exports",
    "module",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    function u() {
        var e = o;
        o = null, e && e.forEach(function(e) {
            a(e[0], e[1]);
        });
    }
    function a(e, n, r) {
        if (typeof document == "undefined") return;
        if (o) {
            if (r) u();
            else if (r === !1) return o.push([
                e,
                n
            ]);
        }
        if (s) return;
        var i = r;
        if (!r || !r.getRootNode) i = document;
        else {
            i = r.getRootNode();
            if (!i || i == r) i = document;
        }
        var a = i.ownerDocument || i;
        if (n && t.hasCssString(n, i)) return null;
        n && (e += "\n/*# sourceURL=ace/css/" + n + " */");
        var f = t.createElement("style");
        f.appendChild(a.createTextNode(e)), n && (f.id = n), i == a && (i = t.getDocumentHead(a)), i.insertBefore(f, i.firstChild);
    }
    var r = e("./useragent"), i = "http://www.w3.org/1999/xhtml";
    t.buildDom = function l(e, t, n) {
        if (typeof e == "string" && e) {
            var r = document.createTextNode(e);
            return t && t.appendChild(r), r;
        }
        if (!Array.isArray(e)) return e && e.appendChild && t && t.appendChild(e), e;
        if (typeof e[0] != "string" || !e[0]) {
            var i = [];
            for(var s = 0; s < e.length; s++){
                var o = l(e[s], t, n);
                o && i.push(o);
            }
            return i;
        }
        var u = document.createElement(e[0]), a = e[1], f = 1;
        a && typeof a == "object" && !Array.isArray(a) && (f = 2);
        for(var s = f; s < e.length; s++)l(e[s], u, n);
        return f == 2 && Object.keys(a).forEach(function(e) {
            var t = a[e];
            e === "class" ? u.className = Array.isArray(t) ? t.join(" ") : t : typeof t == "function" || e == "value" || e[0] == "$" ? u[e] = t : e === "ref" ? n && (n[t] = u) : e === "style" ? typeof t == "string" && (u.style.cssText = t) : t != null && u.setAttribute(e, t);
        }), t && t.appendChild(u), u;
    }, t.getDocumentHead = function(e) {
        return e || (e = document), e.head || e.getElementsByTagName("head")[0] || e.documentElement;
    }, t.createElement = function(e, t) {
        return document.createElementNS ? document.createElementNS(t || i, e) : document.createElement(e);
    }, t.removeChildren = function(e) {
        e.innerHTML = "";
    }, t.createTextNode = function(e, t) {
        var n = t ? t.ownerDocument : document;
        return n.createTextNode(e);
    }, t.createFragment = function(e) {
        var t = e ? e.ownerDocument : document;
        return t.createDocumentFragment();
    }, t.hasCssClass = function(e, t) {
        var n = (e.className + "").split(/\s+/g);
        return n.indexOf(t) !== -1;
    }, t.addCssClass = function(e, n) {
        t.hasCssClass(e, n) || (e.className += " " + n);
    }, t.removeCssClass = function(e, t) {
        var n = e.className.split(/\s+/g);
        for(;;){
            var r = n.indexOf(t);
            if (r == -1) break;
            n.splice(r, 1);
        }
        e.className = n.join(" ");
    }, t.toggleCssClass = function(e, t) {
        var n = e.className.split(/\s+/g), r = !0;
        for(;;){
            var i = n.indexOf(t);
            if (i == -1) break;
            r = !1, n.splice(i, 1);
        }
        return r && n.push(t), e.className = n.join(" "), r;
    }, t.setCssClass = function(e, n, r) {
        r ? t.addCssClass(e, n) : t.removeCssClass(e, n);
    }, t.hasCssString = function(e, t) {
        var n = 0, r;
        t = t || document;
        if (r = t.querySelectorAll("style")) {
            while(n < r.length)if (r[n++].id === e) return !0;
        }
    }, t.removeElementById = function(e, t) {
        t = t || document, t.getElementById(e) && t.getElementById(e).remove();
    };
    var s, o = [];
    t.useStrictCSP = function(e) {
        s = e, e == 0 ? u() : o || (o = []);
    }, t.importCssString = a, t.importCssStylsheet = function(e, n) {
        t.buildDom([
            "link",
            {
                rel: "stylesheet",
                href: e
            }
        ], t.getDocumentHead(n));
    }, t.scrollbarWidth = function(e) {
        var n = t.createElement("ace_inner");
        n.style.width = "100%", n.style.minWidth = "0px", n.style.height = "200px", n.style.display = "block";
        var r = t.createElement("ace_outer"), i = r.style;
        i.position = "absolute", i.left = "-10000px", i.overflow = "hidden", i.width = "200px", i.minWidth = "0px", i.height = "150px", i.display = "block", r.appendChild(n);
        var s = e && e.documentElement || document && document.documentElement;
        if (!s) return 0;
        s.appendChild(r);
        var o = n.offsetWidth;
        i.overflow = "scroll";
        var u = n.offsetWidth;
        return o === u && (u = r.clientWidth), s.removeChild(r), o - u;
    }, t.computedStyle = function(e, t) {
        return window.getComputedStyle(e, "") || {};
    }, t.setStyle = function(e, t, n) {
        e[t] !== n && (e[t] = n);
    }, t.HAS_CSS_ANIMATION = !1, t.HAS_CSS_TRANSFORMS = !1, t.HI_DPI = r.isWin ? typeof window != "undefined" && window.devicePixelRatio >= 1.5 : !0, r.isChromeOS && (t.HI_DPI = !1);
    if (typeof document != "undefined") {
        var f = document.createElement("div");
        t.HI_DPI && f.style.transform !== undefined && (t.HAS_CSS_TRANSFORMS = !0), !r.isEdge && typeof f.style.animationName != "undefined" && (t.HAS_CSS_ANIMATION = !0), f = null;
    }
    t.HAS_CSS_TRANSFORMS ? t.translate = function(e, t, n) {
        e.style.transform = "translate(" + Math.round(t) + "px, " + Math.round(n) + "px)";
    } : t.translate = function(e, t, n) {
        e.style.top = Math.round(n) + "px", e.style.left = Math.round(t) + "px";
    };
}), ace.define("ace/lib/net", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("./dom");
    t.get = function(e, t) {
        var n = new XMLHttpRequest;
        n.open("GET", e, !0), n.onreadystatechange = function() {
            n.readyState === 4 && t(n.responseText);
        }, n.send(null);
    }, t.loadScript = function(e, t) {
        var n = r.getDocumentHead(), i = document.createElement("script");
        i.src = e, n.appendChild(i), i.onload = i.onreadystatechange = function(e, n) {
            if (n || !i.readyState || i.readyState == "loaded" || i.readyState == "complete") i = i.onload = i.onreadystatechange = null, n || t();
        };
    }, t.qualifyURL = function(e) {
        var t = document.createElement("a");
        return t.href = e, t.href;
    };
}), ace.define("ace/lib/oop", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    t.inherits = function(e, t) {
        e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
                value: e,
                enumerable: !1,
                writable: !0,
                configurable: !0
            }
        });
    }, t.mixin = function(e, t) {
        for(var n in t)e[n] = t[n];
        return e;
    }, t.implement = function(e, n) {
        t.mixin(e, n);
    };
}), ace.define("ace/lib/event_emitter", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    var r = {}, i = function() {
        this.propagationStopped = !0;
    }, s = function() {
        this.defaultPrevented = !0;
    };
    r._emit = r._dispatchEvent = function(e, t) {
        this._eventRegistry || (this._eventRegistry = {}), this._defaultHandlers || (this._defaultHandlers = {});
        var n = this._eventRegistry[e] || [], r = this._defaultHandlers[e];
        if (!n.length && !r) return;
        if (typeof t != "object" || !t) t = {};
        t.type || (t.type = e), t.stopPropagation || (t.stopPropagation = i), t.preventDefault || (t.preventDefault = s), n = n.slice();
        for(var o = 0; o < n.length; o++){
            n[o](t, this);
            if (t.propagationStopped) break;
        }
        if (r && !t.defaultPrevented) return r(t, this);
    }, r._signal = function(e, t) {
        var n = (this._eventRegistry || {})[e];
        if (!n) return;
        n = n.slice();
        for(var r = 0; r < n.length; r++)n[r](t, this);
    }, r.once = function(e, t) {
        var n = this;
        this.on(e, function r() {
            n.off(e, r), t.apply(null, arguments);
        });
        if (!t) return new Promise(function(e) {
            t = e;
        });
    }, r.setDefaultHandler = function(e, t) {
        var n = this._defaultHandlers;
        n || (n = this._defaultHandlers = {
            _disabled_: {}
        });
        if (n[e]) {
            var r = n[e], i = n._disabled_[e];
            i || (n._disabled_[e] = i = []), i.push(r);
            var s = i.indexOf(t);
            s != -1 && i.splice(s, 1);
        }
        n[e] = t;
    }, r.removeDefaultHandler = function(e, t) {
        var n = this._defaultHandlers;
        if (!n) return;
        var r = n._disabled_[e];
        if (n[e] == t) r && this.setDefaultHandler(e, r.pop());
        else if (r) {
            var i = r.indexOf(t);
            i != -1 && r.splice(i, 1);
        }
    }, r.on = r.addEventListener = function(e, t, n) {
        this._eventRegistry = this._eventRegistry || {};
        var r = this._eventRegistry[e];
        return r || (r = this._eventRegistry[e] = []), r.indexOf(t) == -1 && r[n ? "unshift" : "push"](t), t;
    }, r.off = r.removeListener = r.removeEventListener = function(e, t) {
        this._eventRegistry = this._eventRegistry || {};
        var n = this._eventRegistry[e];
        if (!n) return;
        var r = n.indexOf(t);
        r !== -1 && n.splice(r, 1);
    }, r.removeAllListeners = function(e) {
        e || (this._eventRegistry = this._defaultHandlers = undefined), this._eventRegistry && (this._eventRegistry[e] = undefined), this._defaultHandlers && (this._defaultHandlers[e] = undefined);
    }, t.EventEmitter = r;
}), ace.define("ace/lib/report_error", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    t.reportError = function(t, n) {
        var r = new Error(t);
        r.data = n, typeof console == "object" && console.error && console.error(r), setTimeout(function() {
            throw r;
        });
    };
}), ace.define("ace/lib/default_english_messages", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    var r = {
        "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
        "autocomplete.popup.aria-label": "Autocomplete suggestions",
        "autocomplete.popup.item.aria-roledescription": "item",
        "autocomplete.loading": "Loading...",
        "editor.scroller.aria-roledescription": "editor",
        "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
        "editor.gutter.aria-roledescription": "editor gutter",
        "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
        "error-marker.good-state": "Looks good!",
        "prompt.recently-used": "Recently used",
        "prompt.other-commands": "Other commands",
        "prompt.no-matching-commands": "No matching commands",
        "search-box.find.placeholder": "Search for",
        "search-box.find-all.text": "All",
        "search-box.replace.placeholder": "Replace with",
        "search-box.replace-next.text": "Replace",
        "search-box.replace-all.text": "All",
        "search-box.toggle-replace.title": "Toggle Replace mode",
        "search-box.toggle-regexp.title": "RegExp Search",
        "search-box.toggle-case.title": "CaseSensitive Search",
        "search-box.toggle-whole-word.title": "Whole Word Search",
        "search-box.toggle-in-selection.title": "Search In Selection",
        "search-box.search-counter": "$0 of $1",
        "text-input.aria-roledescription": "editor",
        "text-input.aria-label": "Cursor at row $0",
        "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
        "gutter.code-folding.closed.title": "Unfold code",
        "gutter.code-folding.open.title": "Fold code",
        "gutter.annotation.aria-label.error": "Error, read annotations row $0",
        "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
        "gutter.annotation.aria-label.info": "Info, read annotations row $0",
        "inline-fold.closed.title": "Unfold code",
        "gutter-tooltip.aria-label.error.singular": "error",
        "gutter-tooltip.aria-label.error.plural": "errors",
        "gutter-tooltip.aria-label.warning.singular": "warning",
        "gutter-tooltip.aria-label.warning.plural": "warnings",
        "gutter-tooltip.aria-label.info.singular": "information message",
        "gutter-tooltip.aria-label.info.plural": "information messages",
        "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
        "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
        "gutter-tooltip.aria-label.security.singular": "security finding",
        "gutter-tooltip.aria-label.security.plural": "security findings",
        "gutter-tooltip.aria-label.hint.singular": "suggestion",
        "gutter-tooltip.aria-label.hint.plural": "suggestions",
        "editor.tooltip.disable-editing": "Editing is disabled"
    };
    t.defaultEnglishMessages = r;
}), ace.define("ace/lib/app_config", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter",
    "ace/lib/report_error",
    "ace/lib/default_english_messages"
], function(e, t, n) {
    "no use strict";
    function a(e) {
        typeof console != "undefined" && console.warn && console.warn.apply(console, arguments);
    }
    var r = e("./oop"), i = e("./event_emitter").EventEmitter, s = e("./report_error").reportError, o = e("./default_english_messages").defaultEnglishMessages, u = {
        setOptions: function(e) {
            Object.keys(e).forEach(function(t) {
                this.setOption(t, e[t]);
            }, this);
        },
        getOptions: function(e) {
            var t = {};
            if (!e) {
                var n = this.$options;
                e = Object.keys(n).filter(function(e) {
                    return !n[e].hidden;
                });
            } else Array.isArray(e) || (e = Object.keys(e));
            return e.forEach(function(e) {
                t[e] = this.getOption(e);
            }, this), t;
        },
        setOption: function(e, t) {
            if (this["$" + e] === t) return;
            var n = this.$options[e];
            if (!n) return a('misspelled option "' + e + '"');
            if (n.forwardTo) return this[n.forwardTo] && this[n.forwardTo].setOption(e, t);
            n.handlesSet || (this["$" + e] = t), n && n.set && n.set.call(this, t);
        },
        getOption: function(e) {
            var t = this.$options[e];
            return t ? t.forwardTo ? this[t.forwardTo] && this[t.forwardTo].getOption(e) : t && t.get ? t.get.call(this) : this["$" + e] : a('misspelled option "' + e + '"');
        }
    }, f, l, c = function() {
        function e() {
            this.$defaultOptions = {}, f = o, l = "dollarSigns";
        }
        return e.prototype.defineOptions = function(e, t, n) {
            return e.$options || (this.$defaultOptions[t] = e.$options = {}), Object.keys(n).forEach(function(t) {
                var r = n[t];
                typeof r == "string" && (r = {
                    forwardTo: r
                }), r.name || (r.name = t), e.$options[r.name] = r, "initialValue" in r && (e["$" + r.name] = r.initialValue);
            }), r.implement(e, u), this;
        }, e.prototype.resetOptions = function(e) {
            Object.keys(e.$options).forEach(function(t) {
                var n = e.$options[t];
                "value" in n && e.setOption(t, n.value);
            });
        }, e.prototype.setDefaultValue = function(e, t, n) {
            if (!e) {
                for(e in this.$defaultOptions)if (this.$defaultOptions[e][t]) break;
                if (!this.$defaultOptions[e][t]) return !1;
            }
            var r = this.$defaultOptions[e] || (this.$defaultOptions[e] = {});
            r[t] && (r.forwardTo ? this.setDefaultValue(r.forwardTo, t, n) : r[t].value = n);
        }, e.prototype.setDefaultValues = function(e, t) {
            Object.keys(t).forEach(function(n) {
                this.setDefaultValue(e, n, t[n]);
            }, this);
        }, e.prototype.setMessages = function(e, t) {
            f = e, t && t.placeholders && (l = t.placeholders);
        }, e.prototype.nls = function(e, t, n) {
            f[e] || (a("No message found for the key '" + e + "' in messages with id " + f.$id + ", trying to find a translation for the default string '" + t + "'."), f[t] || a("No message found for the default string '" + t + "' in the provided messages. Falling back to the default English message."));
            var r = f[e] || f[t] || t;
            return n && (l === "dollarSigns" && (r = r.replace(/\$(\$|[\d]+)/g, function(e, t) {
                return t == "$" ? "$" : n[t];
            })), l === "curlyBrackets" && (r = r.replace(/\{([^\}]+)\}/g, function(e, t) {
                return n[t];
            }))), r;
        }, e;
    }();
    c.prototype.warn = a, c.prototype.reportError = s, r.implement(c.prototype, i), t.AppConfig = c;
}), ace.define("ace/theme/textmate-css", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    n.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
}), ace.define("ace/theme/textmate", [
    "require",
    "exports",
    "module",
    "ace/theme/textmate-css",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    t.isDark = !1, t.cssClass = "ace-tm", t.cssText = e("./textmate-css"), t.$id = "ace/theme/textmate";
    var r = e("../lib/dom");
    r.importCssString(t.cssText, t.cssClass, !1);
}), ace.define("ace/config", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/lib/net",
    "ace/lib/dom",
    "ace/lib/app_config",
    "ace/theme/textmate"
], function(e, t, n) {
    "no use strict";
    var r = e("./lib/lang"), i = e("./lib/net"), s = e("./lib/dom"), o = e("./lib/app_config").AppConfig;
    n.exports = t = new o;
    var u = {
        packaged: !1,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: !0,
        sharedPopups: !1,
        useStrictCSP: null
    };
    t.get = function(e) {
        if (!u.hasOwnProperty(e)) throw new Error("Unknown config key: " + e);
        return u[e];
    }, t.set = function(e, t) {
        if (u.hasOwnProperty(e)) u[e] = t;
        else if (this.setDefaultValue("", e, t) == 0) throw new Error("Unknown config key: " + e);
        e == "useStrictCSP" && s.useStrictCSP(t);
    }, t.all = function() {
        return r.copyObject(u);
    }, t.$modes = {}, t.moduleUrl = function(e, t) {
        if (u.$moduleUrls[e]) return u.$moduleUrls[e];
        var n = e.split("/");
        t = t || n[n.length - 2] || "";
        var r = t == "snippets" ? "/" : "-", i = n[n.length - 1];
        if (t == "worker" && r == "-") {
            var s = new RegExp("^" + t + "[\\-_]|[\\-_]" + t + "$", "g");
            i = i.replace(s, "");
        }
        (!i || i == t) && n.length > 1 && (i = n[n.length - 2]);
        var o = u[t + "Path"];
        return o == null ? o = u.basePath : r == "/" && (t = r = ""), o && o.slice(-1) != "/" && (o += "/"), o + t + r + i + this.get("suffix");
    }, t.setModuleUrl = function(e, t) {
        return u.$moduleUrls[e] = t;
    };
    var a = function(t, n) {
        if (t === "ace/theme/textmate" || t === "./theme/textmate") return n(null, e("./theme/textmate"));
        if (f) return f(t, n);
        console.error("loader is not configured");
    }, f;
    t.setLoader = function(e) {
        f = e;
    }, t.dynamicModules = Object.create(null), t.$loading = {}, t.$loaded = {}, t.loadModule = function(e, n) {
        var r;
        if (Array.isArray(e)) var s = e[0], o = e[1];
        else if (typeof e == "string") var o = e;
        var u = function(e) {
            if (e && !t.$loading[o]) return n && n(e);
            t.$loading[o] || (t.$loading[o] = []), t.$loading[o].push(n);
            if (t.$loading[o].length > 1) return;
            var r = function() {
                a(o, function(e, n) {
                    n && (t.$loaded[o] = n), t._emit("load.module", {
                        name: o,
                        module: n
                    });
                    var r = t.$loading[o];
                    t.$loading[o] = null, r.forEach(function(e) {
                        e && e(n);
                    });
                });
            };
            if (!t.get("packaged")) return r();
            i.loadScript(t.moduleUrl(o, s), r), l();
        };
        if (t.dynamicModules[o]) t.dynamicModules[o]().then(function(e) {
            e.default ? u(e.default) : u(e);
        });
        else {
            try {
                r = this.$require(o);
            } catch (f) {}
            u(r || t.$loaded[o]);
        }
    }, t.$require = function(e) {
        if (typeof n["require"] == "function") {
            var t = "require";
            return n[t](e);
        }
    }, t.setModuleLoader = function(e, n) {
        t.dynamicModules[e] = n;
    };
    var l = function() {
        !u.basePath && !u.workerPath && !u.modePath && !u.themePath && !Object.keys(u.$moduleUrls).length && (console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver"), l = function() {});
    };
    t.version = "1.42.0";
}), ace.define("ace/loader_build", [
    "require",
    "exports",
    "module",
    "ace/lib/fixoldbrowsers",
    "ace/config"
], function(e, t, n) {
    "use strict";
    function s(t) {
        if (!i || !i.document) return;
        r.set("packaged", t || e.packaged || n.packaged || i.define && define.packaged);
        var s = {}, u = "", a = document.currentScript || document._currentScript, f = a && a.ownerDocument || document;
        a && a.src && (u = a.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "");
        var l = f.getElementsByTagName("script");
        for(var c = 0; c < l.length; c++){
            var h = l[c], p = h.src || h.getAttribute("src");
            if (!p) continue;
            var d = h.attributes;
            for(var v = 0, m = d.length; v < m; v++){
                var g = d[v];
                g.name.indexOf("data-ace-") === 0 && (s[o(g.name.replace(/^data-ace-/, ""))] = g.value);
            }
            var y = p.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
            y && (u = y[1]);
        }
        u && (s.base = s.base || u, s.packaged = !0), s.basePath = s.base, s.workerPath = s.workerPath || s.base, s.modePath = s.modePath || s.base, s.themePath = s.themePath || s.base, delete s.base;
        for(var b in s)typeof s[b] != "undefined" && r.set(b, s[b]);
    }
    function o(e) {
        return e.replace(/-(.)/g, function(e, t) {
            return t.toUpperCase();
        });
    }
    e("./lib/fixoldbrowsers");
    var r = e("./config");
    r.setLoader(function(t, n) {
        e([
            t
        ], function(e) {
            n(null, e);
        });
    });
    var i = function() {
        return this || typeof window != "undefined" && window;
    }();
    n.exports = function(t) {
        r.init = s, r.$require = e, t.require = e, typeof define == "function" && (t.define = define);
    };
}), ace.define("ace/range", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    var r = function() {
        function e(e, t, n, r) {
            this.start = {
                row: e,
                column: t
            }, this.end = {
                row: n,
                column: r
            };
        }
        return e.prototype.isEqual = function(e) {
            return this.start.row === e.start.row && this.end.row === e.end.row && this.start.column === e.start.column && this.end.column === e.end.column;
        }, e.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        }, e.prototype.contains = function(e, t) {
            return this.compare(e, t) == 0;
        }, e.prototype.compareRange = function(e) {
            var t, n = e.end, r = e.start;
            return t = this.compare(n.row, n.column), t == 1 ? (t = this.compare(r.row, r.column), t == 1 ? 2 : t == 0 ? 1 : 0) : t == -1 ? -2 : (t = this.compare(r.row, r.column), t == -1 ? -1 : t == 1 ? 42 : 0);
        }, e.prototype.comparePoint = function(e) {
            return this.compare(e.row, e.column);
        }, e.prototype.containsRange = function(e) {
            return this.comparePoint(e.start) == 0 && this.comparePoint(e.end) == 0;
        }, e.prototype.intersects = function(e) {
            var t = this.compareRange(e);
            return t == -1 || t == 0 || t == 1;
        }, e.prototype.isEnd = function(e, t) {
            return this.end.row == e && this.end.column == t;
        }, e.prototype.isStart = function(e, t) {
            return this.start.row == e && this.start.column == t;
        }, e.prototype.setStart = function(e, t) {
            typeof e == "object" ? (this.start.column = e.column, this.start.row = e.row) : (this.start.row = e, this.start.column = t);
        }, e.prototype.setEnd = function(e, t) {
            typeof e == "object" ? (this.end.column = e.column, this.end.row = e.row) : (this.end.row = e, this.end.column = t);
        }, e.prototype.inside = function(e, t) {
            return this.compare(e, t) == 0 ? this.isEnd(e, t) || this.isStart(e, t) ? !1 : !0 : !1;
        }, e.prototype.insideStart = function(e, t) {
            return this.compare(e, t) == 0 ? this.isEnd(e, t) ? !1 : !0 : !1;
        }, e.prototype.insideEnd = function(e, t) {
            return this.compare(e, t) == 0 ? this.isStart(e, t) ? !1 : !0 : !1;
        }, e.prototype.compare = function(e, t) {
            return !this.isMultiLine() && e === this.start.row ? t < this.start.column ? -1 : t > this.end.column ? 1 : 0 : e < this.start.row ? -1 : e > this.end.row ? 1 : this.start.row === e ? t >= this.start.column ? 0 : -1 : this.end.row === e ? t <= this.end.column ? 0 : 1 : 0;
        }, e.prototype.compareStart = function(e, t) {
            return this.start.row == e && this.start.column == t ? -1 : this.compare(e, t);
        }, e.prototype.compareEnd = function(e, t) {
            return this.end.row == e && this.end.column == t ? 1 : this.compare(e, t);
        }, e.prototype.compareInside = function(e, t) {
            return this.end.row == e && this.end.column == t ? 1 : this.start.row == e && this.start.column == t ? -1 : this.compare(e, t);
        }, e.prototype.clipRows = function(t, n) {
            if (this.end.row > n) var r = {
                row: n + 1,
                column: 0
            };
            else if (this.end.row < t) var r = {
                row: t,
                column: 0
            };
            if (this.start.row > n) var i = {
                row: n + 1,
                column: 0
            };
            else if (this.start.row < t) var i = {
                row: t,
                column: 0
            };
            return e.fromPoints(i || this.start, r || this.end);
        }, e.prototype.extend = function(t, n) {
            var r = this.compare(t, n);
            if (r == 0) return this;
            if (r == -1) var i = {
                row: t,
                column: n
            };
            else var s = {
                row: t,
                column: n
            };
            return e.fromPoints(i || this.start, s || this.end);
        }, e.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
        }, e.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
        }, e.prototype.clone = function() {
            return e.fromPoints(this.start, this.end);
        }, e.prototype.collapseRows = function() {
            return this.end.column == 0 ? new e(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0) : new e(this.start.row, 0, this.end.row, 0);
        }, e.prototype.toScreenRange = function(t) {
            var n = t.documentToScreenPosition(this.start), r = t.documentToScreenPosition(this.end);
            return new e(n.row, n.column, r.row, r.column);
        }, e.prototype.moveBy = function(e, t) {
            this.start.row += e, this.start.column += t, this.end.row += e, this.end.column += t;
        }, e;
    }();
    r.fromPoints = function(e, t) {
        return new r(e.row, e.column, t.row, t.column);
    }, r.comparePoints = function(e, t) {
        return e.row - t.row || e.column - t.column;
    }, t.Range = r;
}), ace.define("ace/lib/keys", [
    "require",
    "exports",
    "module",
    "ace/lib/oop"
], function(e, t, n) {
    "use strict";
    var r = e("./oop"), i = {
        MODIFIER_KEYS: {
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            224: "Meta",
            91: "MetaLeft",
            92: "MetaRight",
            93: "ContextMenu"
        },
        KEY_MODS: {
            ctrl: 1,
            alt: 2,
            option: 2,
            shift: 4,
            "super": 8,
            meta: 8,
            command: 8,
            cmd: 8,
            control: 1
        },
        FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            "-13": "NumpadEnter",
            144: "Numlock",
            145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
            32: " ",
            59: ";",
            61: "=",
            107: "+",
            109: "-",
            110: ".",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            111: "/",
            106: "*"
        }
    }, s = {
        Command: 224,
        Backspace: 8,
        Tab: 9,
        Return: 13,
        Enter: 13,
        Pause: 19,
        Escape: 27,
        PageUp: 33,
        PageDown: 34,
        End: 35,
        Home: 36,
        Insert: 45,
        Delete: 46,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Backquote: 192,
        Minus: 189,
        Equal: 187,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Semicolon: 186,
        Quote: 222,
        Comma: 188,
        Period: 190,
        Slash: 191,
        Space: 32,
        NumpadAdd: 107,
        NumpadDecimal: 110,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        NumpadMultiply: 106
    };
    for(var o = 0; o < 10; o++)s["Digit" + o] = 48 + o, s["Numpad" + o] = 96 + o, i.PRINTABLE_KEYS[48 + o] = "" + o, i.FUNCTION_KEYS[96 + o] = "Numpad" + o;
    for(var o = 65; o < 91; o++){
        var u = String.fromCharCode(o + 32);
        s["Key" + u.toUpperCase()] = o, i.PRINTABLE_KEYS[o] = u;
    }
    for(var o = 1; o < 13; o++)s["F" + o] = 111 + o, i.FUNCTION_KEYS[111 + o] = "F" + o;
    var a = {
        Shift: 16,
        Control: 17,
        Alt: 18,
        Meta: 224
    };
    for(var f in a)s[f] = s[f + "Left"] = s[f + "Right"] = a[f];
    t.$codeToKeyCode = s, i.PRINTABLE_KEYS[173] = "-";
    for(var l in i.FUNCTION_KEYS){
        var c = i.FUNCTION_KEYS[l].toLowerCase();
        i[c] = parseInt(l, 10);
    }
    for(var l in i.PRINTABLE_KEYS){
        var c = i.PRINTABLE_KEYS[l].toLowerCase();
        i[c] = parseInt(l, 10);
    }
    r.mixin(i, i.MODIFIER_KEYS), r.mixin(i, i.PRINTABLE_KEYS), r.mixin(i, i.FUNCTION_KEYS), i.enter = i["return"], i.escape = i.esc, i.del = i["delete"], function() {
        var e = [
            "cmd",
            "ctrl",
            "alt",
            "shift"
        ];
        for(var t = Math.pow(2, e.length); t--;)i.KEY_MODS[t] = e.filter(function(e) {
            return t & i.KEY_MODS[e];
        }).join("-") + "-";
    }(), i.KEY_MODS[0] = "", i.KEY_MODS[-1] = "input-", r.mixin(t, i), t.default = t, t.keyCodeToString = function(e) {
        var t = i[e];
        return typeof t != "string" && (t = String.fromCharCode(e)), t.toLowerCase();
    };
}), ace.define("ace/lib/event", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    function a() {
        u = !1;
        try {
            document.createComment("").addEventListener("test", function() {}, {
                get passive () {
                    return u = {
                        passive: !1
                    }, !0;
                }
            });
        } catch (e) {}
    }
    function f() {
        return u == undefined && a(), u;
    }
    function l(e, t, n) {
        this.elem = e, this.type = t, this.callback = n;
    }
    function p(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    }
    function d(e, t, n) {
        var u = p(t);
        !n && t.code && (n = r.$codeToKeyCode[t.code] || n);
        if (!i.isMac && s) {
            t.getModifierState && (t.getModifierState("OS") || t.getModifierState("Win")) && (u |= 8);
            if (s.altGr) {
                if ((3 & u) == 3) return;
                s.altGr = 0;
            }
            if (n === 18 || n === 17) {
                var a = t.location;
                if (n === 17 && a === 1) s[n] == 1 && (o = t.timeStamp);
                else if (n === 18 && u === 3 && a === 2) {
                    var f = t.timeStamp - o;
                    f < 50 && (s.altGr = !0);
                }
            }
        }
        n in r.MODIFIER_KEYS && (n = -1);
        if (!u && n === 13 && t.location === 3) {
            e(t, u, -n);
            if (t.defaultPrevented) return;
        }
        if (i.isChromeOS && u & 8) {
            e(t, u, n);
            if (t.defaultPrevented) return;
            u &= -9;
        }
        return !!u || n in r.FUNCTION_KEYS || n in r.PRINTABLE_KEYS ? e(t, u, n) : !1;
    }
    function v() {
        s = Object.create(null);
    }
    var r = e("./keys"), i = e("./useragent"), s = null, o = 0, u;
    l.prototype.destroy = function() {
        h(this.elem, this.type, this.callback), this.elem = this.type = this.callback = undefined;
    };
    var c = t.addListener = function(e, t, n, r) {
        e.addEventListener(t, n, f()), r && r.$toDestroy.push(new l(e, t, n));
    }, h = t.removeListener = function(e, t, n) {
        e.removeEventListener(t, n, f());
    };
    t.stopEvent = function(e) {
        return t.stopPropagation(e), t.preventDefault(e), !1;
    }, t.stopPropagation = function(e) {
        e.stopPropagation && e.stopPropagation();
    }, t.preventDefault = function(e) {
        e.preventDefault && e.preventDefault();
    }, t.getButton = function(e) {
        return e.type == "dblclick" ? 0 : e.type == "contextmenu" || i.isMac && e.ctrlKey && !e.altKey && !e.shiftKey ? 2 : e.button;
    }, t.capture = function(e, t, n) {
        function i(e) {
            t && t(e), n && n(e), h(r, "mousemove", t), h(r, "mouseup", i), h(r, "dragstart", i);
        }
        var r = e && e.ownerDocument || document;
        return c(r, "mousemove", t), c(r, "mouseup", i), c(r, "dragstart", i), i;
    }, t.addMouseWheelListener = function(e, t, n) {
        c(e, "wheel", function(e) {
            var n = .15, r = e.deltaX || 0, i = e.deltaY || 0;
            switch(e.deltaMode){
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = r * n, e.wheelY = i * n;
                    break;
                case e.DOM_DELTA_LINE:
                    var s = 15;
                    e.wheelX = r * s, e.wheelY = i * s;
                    break;
                case e.DOM_DELTA_PAGE:
                    var o = 150;
                    e.wheelX = r * o, e.wheelY = i * o;
            }
            t(e);
        }, n);
    }, t.addMultiMouseDownListener = function(e, n, r, s, o) {
        function p(e) {
            t.getButton(e) !== 0 ? u = 0 : e.detail > 1 ? (u++, u > 4 && (u = 1)) : u = 1;
            if (i.isIE) {
                var o = Math.abs(e.clientX - a) > 5 || Math.abs(e.clientY - f) > 5;
                if (!l || o) u = 1;
                l && clearTimeout(l), l = setTimeout(function() {
                    l = null;
                }, n[u - 1] || 600), u == 1 && (a = e.clientX, f = e.clientY);
            }
            e._clicks = u, r[s]("mousedown", e);
            if (u > 4) u = 0;
            else if (u > 1) return r[s](h[u], e);
        }
        var u = 0, a, f, l, h = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
        };
        Array.isArray(e) || (e = [
            e
        ]), e.forEach(function(e) {
            c(e, "mousedown", p, o);
        });
    }, t.getModifierString = function(e) {
        return r.KEY_MODS[p(e)];
    }, t.addCommandKeyListener = function(e, n, r) {
        var i = null;
        c(e, "keydown", function(e) {
            s[e.keyCode] = (s[e.keyCode] || 0) + 1;
            var t = d(n, e, e.keyCode);
            return i = e.defaultPrevented, t;
        }, r), c(e, "keypress", function(e) {
            i && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey) && (t.stopEvent(e), i = null);
        }, r), c(e, "keyup", function(e) {
            s[e.keyCode] = null;
        }, r), s || (v(), c(window, "focus", v));
    };
    if (typeof window == "object" && window.postMessage && !i.isOldIE) {
        var m = 1;
        t.nextTick = function(e, n) {
            n = n || window;
            var r = "zero-timeout-message-" + m++, i = function(s) {
                s.data == r && (t.stopPropagation(s), h(n, "message", i), e());
            };
            c(n, "message", i), n.postMessage(r, "*");
        };
    }
    t.$idleBlocked = !1, t.onIdle = function(e, n) {
        return setTimeout(function r() {
            t.$idleBlocked ? setTimeout(r, 100) : e();
        }, n);
    }, t.$idleBlockId = null, t.blockIdle = function(e) {
        t.$idleBlockId && clearTimeout(t.$idleBlockId), t.$idleBlocked = !0, t.$idleBlockId = setTimeout(function() {
            t.$idleBlocked = !1;
        }, e || 100);
    }, t.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame), t.nextFrame ? t.nextFrame = t.nextFrame.bind(window) : t.nextFrame = function(e) {
        setTimeout(e, 17);
    };
}), ace.define("ace/clipboard", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    var r;
    n.exports = {
        lineMode: !1,
        pasteCancelled: function() {
            return r && r > Date.now() - 50 ? !0 : r = !1;
        },
        cancel: function() {
            r = Date.now();
        }
    };
}), ace.define("ace/keyboard/textinput", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/config",
    "ace/lib/useragent",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/clipboard",
    "ace/lib/keys"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/event"), i = e("../config").nls, s = e("../lib/useragent"), o = e("../lib/dom"), u = e("../lib/lang"), a = e("../clipboard"), f = s.isChrome < 18, l = s.isIE, c = s.isChrome > 63, h = 400, p = e("../lib/keys"), d = p.KEY_MODS, v = s.isIOS, m = v ? /\s/ : /\n/, g = s.isMobile, y;
    y = function(e, t) {
        function Q() {
            T = !0, n.blur(), n.focus(), T = !1;
        }
        function Y(e) {
            e.keyCode == 27 && n.value.length < n.selectionStart && (w || (N = n.value), C = k = -1, H()), G();
        }
        function et() {
            clearTimeout(Z), Z = setTimeout(function() {
                S && (n.style.cssText = S, S = ""), t.renderer.$isMousePressed = !1, t.renderer.$keepTextAreaAtCursor && t.renderer.$moveTextAreaToCursor();
            }, 0);
        }
        function nt(e, t, n) {
            var r = null, i = !1;
            n.addEventListener("keydown", function(e) {
                r && clearTimeout(r), i = !0;
            }, !0), n.addEventListener("keyup", function(e) {
                r = setTimeout(function() {
                    i = !1;
                }, 100);
            }, !0);
            var s = function(e) {
                if (document.activeElement !== n) return;
                if (i || w || t.$mouseHandler.isMousePressed) return;
                if (y) return;
                var r = n.selectionStart, s = n.selectionEnd, o = null, u = 0;
                if (r == 0) o = p.up;
                else if (r == 1) o = p.home;
                else if (s > k && N[s] == "\n") o = p.end;
                else if (r < C && N[r - 1] == " ") o = p.left, u = d.option;
                else if (r < C || r == C && k != C && r == s) o = p.left;
                else if (s > k && N.slice(0, s).split("\n").length > 2) o = p.down;
                else if (s > k && N[s - 1] == " ") o = p.right, u = d.option;
                else if (s > k || s == k && k != C && r == s) o = p.right;
                r !== s && (u |= d.shift);
                if (o) {
                    var a = t.onCommandKey({}, u, o);
                    if (!a && t.commands) {
                        o = p.keyCodeToString(o);
                        var f = t.commands.findKeyCommand(u, o);
                        f && t.execCommand(f);
                    }
                    C = r, k = s, H("");
                }
            };
            document.addEventListener("selectionchange", s), t.on("destroy", function() {
                document.removeEventListener("selectionchange", s);
            });
        }
        var n = o.createElement("textarea");
        n.className = "ace_text-input", n.setAttribute("wrap", "off"), n.setAttribute("autocorrect", "off"), n.setAttribute("autocapitalize", "off"), n.setAttribute("spellcheck", "false"), n.style.opacity = "0", e.insertBefore(n, e.firstChild), this.setHost = function(e) {
            t = e;
        };
        var y = !1, b = !1, w = !1, E = !1, S = "";
        g || (n.style.fontSize = "1px");
        var x = !1, T = !1, N = "", C = 0, k = 0, L = 0, A = Number.MAX_SAFE_INTEGER, O = Number.MIN_SAFE_INTEGER, M = 0;
        try {
            var _ = document.activeElement === n;
        } catch (D) {}
        this.setNumberOfExtraLines = function(e) {
            A = Number.MAX_SAFE_INTEGER, O = Number.MIN_SAFE_INTEGER;
            if (e < 0) {
                M = 0;
                return;
            }
            M = e;
        }, this.setAriaLabel = function() {
            var e = "";
            t.$textInputAriaLabel && (e += "".concat(t.$textInputAriaLabel, ", "));
            if (t.session) {
                var r = t.session.selection.cursor.row;
                e += i("text-input.aria-label", "Cursor at row $0", [
                    r + 1
                ]);
            }
            n.setAttribute("aria-label", e);
        }, this.setAriaOptions = function(e) {
            e.activeDescendant ? (n.setAttribute("aria-haspopup", "true"), n.setAttribute("aria-autocomplete", e.inline ? "both" : "list"), n.setAttribute("aria-activedescendant", e.activeDescendant)) : (n.setAttribute("aria-haspopup", "false"), n.setAttribute("aria-autocomplete", "both"), n.removeAttribute("aria-activedescendant")), e.role && n.setAttribute("role", e.role), e.setLabel && (n.setAttribute("aria-roledescription", i("text-input.aria-roledescription", "editor")), this.setAriaLabel());
        }, this.setAriaOptions({
            role: "textbox"
        }), r.addListener(n, "blur", function(e) {
            if (T) return;
            t.onBlur(e), _ = !1;
        }, t), r.addListener(n, "focus", function(e) {
            if (T) return;
            _ = !0;
            if (s.isEdge) try {
                if (!document.hasFocus()) return;
            } catch (e) {}
            t.onFocus(e), s.isEdge ? setTimeout(H) : H();
        }, t), this.$focusScroll = !1, this.focus = function() {
            this.setAriaOptions({
                setLabel: t.renderer.enableKeyboardAccessibility
            });
            if (S || c || this.$focusScroll == "browser") return n.focus({
                preventScroll: !0
            });
            var e = n.style.top;
            n.style.position = "fixed", n.style.top = "0px";
            try {
                var r = n.getBoundingClientRect().top != 0;
            } catch (i) {
                return;
            }
            var s = [];
            if (r) {
                var o = n.parentElement;
                while(o && o.nodeType == 1)s.push(o), o.setAttribute("ace_nocontext", "true"), !o.parentElement && o.getRootNode ? o = o.getRootNode().host : o = o.parentElement;
            }
            n.focus({
                preventScroll: !0
            }), r && s.forEach(function(e) {
                e.removeAttribute("ace_nocontext");
            }), setTimeout(function() {
                n.style.position = "", n.style.top == "0px" && (n.style.top = e);
            }, 0);
        }, this.blur = function() {
            n.blur();
        }, this.isFocused = function() {
            return _;
        }, t.on("beforeEndOperation", function() {
            var e = t.curOp, r = e && e.command && e.command.name;
            if (r == "insertstring") return;
            var i = r && (e.docChanged || e.selectionChanged);
            w && i && (N = n.value = "", K()), H();
        }), t.on("changeSelection", this.setAriaLabel);
        var P = function(e, n) {
            var r = n;
            for(var i = 1; i <= e - A && i < 2 * M + 1; i++)r += t.session.getLine(e - i).length + 1;
            return r;
        }, H = v ? function(e) {
            if (!_ || y && !e || E) return;
            e || (e = "");
            var r = "\n ab" + e + "cde fg\n";
            r != n.value && (n.value = N = r);
            var i = 4, s = 4 + (e.length || (t.selection.isEmpty() ? 0 : 1));
            (C != i || k != s) && n.setSelectionRange(i, s), C = i, k = s;
        } : function() {
            if (w || E) return;
            if (!_ && !I) return;
            w = !0;
            var e = 0, r = 0, i = "";
            if (t.session) {
                var s = t.selection, o = s.getRange(), u = s.cursor.row;
                if (u === O + 1) A = O + 1, O = A + 2 * M;
                else if (u === A - 1) O = A - 1, A = O - 2 * M;
                else if (u < A - 1 || u > O + 1) A = u > M ? u - M : 0, O = u > M ? u + M : 2 * M;
                var a = [];
                for(var f = A; f <= O; f++)a.push(t.session.getLine(f));
                i = a.join("\n"), e = P(o.start.row, o.start.column), r = P(o.end.row, o.end.column);
                if (o.start.row < A) {
                    var l = t.session.getLine(A - 1);
                    e = o.start.row < A - 1 ? 0 : e, r += l.length + 1, i = l + "\n" + i;
                } else if (o.end.row > O) {
                    var c = t.session.getLine(O + 1);
                    r = o.end.row > O + 1 ? c.length : o.end.column, r += i.length + 1, i = i + "\n" + c;
                } else g && u > 0 && (i = "\n" + i, r += 1, e += 1);
                i.length > h && (e < h && r < h ? i = i.slice(0, h) : (i = "\n", e == r ? e = r = 0 : (e = 0, r = 1)));
                var p = i + "\n\n";
                p != N && (n.value = N = p, C = k = p.length);
            }
            I && (C = n.selectionStart, k = n.selectionEnd);
            if (k != r || C != e || n.selectionEnd != k) try {
                n.setSelectionRange(e, r), C = e, k = r;
            } catch (d) {}
            w = !1;
        };
        this.resetSelection = H, _ && t.onFocus();
        var B = function(e) {
            return e.selectionStart === 0 && e.selectionEnd >= N.length && e.value === N && N && e.selectionEnd !== k;
        }, j = function(e) {
            if (w) return;
            y ? y = !1 : B(n) ? (t.selectAll(), H()) : g && n.selectionStart != C && H();
        }, F = null;
        this.setInputHandler = function(e) {
            F = e;
        }, this.getInputHandler = function() {
            return F;
        };
        var I = !1, q = function(e, r) {
            I && (I = !1);
            if (b) return H(), e && t.onPaste(e), b = !1, "";
            var i = n.selectionStart, o = n.selectionEnd, u = C, a = N.length - k, f = e, l = e.length - i, c = e.length - o, h = 0;
            while(u > 0 && N[h] == e[h])h++, u--;
            f = f.slice(h), h = 1;
            while(a > 0 && N.length - h > C - 1 && N[N.length - h] == e[e.length - h])h++, a--;
            l -= h - 1, c -= h - 1;
            var p = f.length - h + 1;
            p < 0 && (u = -p, p = 0), f = f.slice(0, p);
            if (!r && !f && !l && !u && !a && !c) return "";
            E = !0;
            var d = !1;
            return s.isAndroid && f == ". " && (f = "  ", d = !0), f && !u && !a && !l && !c || x ? t.onTextInput(f) : t.onTextInput(f, {
                extendLeft: u,
                extendRight: a,
                restoreStart: l,
                restoreEnd: c
            }), E = !1, N = e, C = i, k = o, L = c, d ? "\n" : f;
        }, R = function(e) {
            if (w) return J();
            if (e && e.inputType) {
                if (e.inputType == "historyUndo") return t.execCommand("undo");
                if (e.inputType == "historyRedo") return t.execCommand("redo");
            }
            var r = n.value, i = q(r, !0);
            (r.length > h + 100 || m.test(i) || g && C < 1 && C == k) && H();
        }, U = function(e, t, n) {
            var r = e.clipboardData || window.clipboardData;
            if (!r || f) return;
            var i = l || n ? "Text" : "text/plain";
            try {
                return t ? r.setData(i, t) !== !1 : r.getData(i);
            } catch (e) {
                if (!n) return U(e, t, !0);
            }
        }, z = function(e, i) {
            var s = t.getCopyText();
            if (!s) return r.preventDefault(e);
            U(e, s) ? (v && (H(s), y = s, setTimeout(function() {
                y = !1;
            }, 10)), i ? t.onCut() : t.onCopy(), r.preventDefault(e)) : (y = !0, n.value = s, n.select(), setTimeout(function() {
                y = !1, H(), i ? t.onCut() : t.onCopy();
            }));
        }, W = function(e) {
            z(e, !0);
        }, X = function(e) {
            z(e, !1);
        }, V = function(e) {
            var i = U(e);
            if (a.pasteCancelled()) return;
            typeof i == "string" ? (i && t.onPaste(i, e), s.isIE && setTimeout(H), r.preventDefault(e)) : (n.value = "", b = !0);
        };
        r.addCommandKeyListener(n, function(e, n, r) {
            if (w) return;
            return t.onCommandKey(e, n, r);
        }, t), r.addListener(n, "select", j, t), r.addListener(n, "input", R, t), r.addListener(n, "cut", W, t), r.addListener(n, "copy", X, t), r.addListener(n, "paste", V, t), (!("oncut" in n) || !("oncopy" in n) || !("onpaste" in n)) && r.addListener(e, "keydown", function(e) {
            if (s.isMac && !e.metaKey || !e.ctrlKey) return;
            switch(e.keyCode){
                case 67:
                    X(e);
                    break;
                case 86:
                    V(e);
                    break;
                case 88:
                    W(e);
            }
        }, t);
        var $ = function(e) {
            if (w || !t.onCompositionStart || t.$readOnly) return;
            w = {};
            if (x) return;
            e.data && (w.useTextareaForIME = !1), setTimeout(J, 0), t._signal("compositionStart"), t.on("mousedown", Q);
            var r = t.getSelectionRange();
            r.end.row = r.start.row, r.end.column = r.start.column, w.markerRange = r, w.selectionStart = C, t.onCompositionStart(w), w.useTextareaForIME ? (N = n.value = "", C = 0, k = 0) : (n.msGetInputContext && (w.context = n.msGetInputContext()), n.getInputContext && (w.context = n.getInputContext()));
        }, J = function() {
            if (!w || !t.onCompositionUpdate || t.$readOnly) return;
            if (x) return Q();
            if (w.useTextareaForIME) t.onCompositionUpdate(n.value);
            else {
                var e = n.value;
                q(e), w.markerRange && (w.context && (w.markerRange.start.column = w.selectionStart = w.context.compositionStartOffset), w.markerRange.end.column = w.markerRange.start.column + k - w.selectionStart + L);
            }
        }, K = function(e) {
            if (!t.onCompositionEnd || t.$readOnly) return;
            w = !1, t.onCompositionEnd(), t.off("mousedown", Q), e && R();
        }, G = u.delayedCall(J, 50).schedule.bind(null, null);
        r.addListener(n, "compositionstart", $, t), r.addListener(n, "compositionupdate", J, t), r.addListener(n, "keyup", Y, t), r.addListener(n, "keydown", G, t), r.addListener(n, "compositionend", K, t), this.getElement = function() {
            return n;
        }, this.setCommandMode = function(e) {
            x = e, n.readOnly = !1;
        }, this.setReadOnly = function(e) {
            x || (n.readOnly = e);
        }, this.setCopyWithEmptySelection = function(e) {}, this.onContextMenu = function(e) {
            I = !0, H(), t._emit("nativecontextmenu", {
                target: t,
                domEvent: e
            }), this.moveToMouse(e, !0);
        }, this.moveToMouse = function(e, i) {
            S || (S = n.style.cssText), n.style.cssText = (i ? "z-index:100000;" : "") + (s.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (C + k) * t.renderer.characterWidth * .5 + "px;";
            var u = t.container.getBoundingClientRect(), a = o.computedStyle(t.container), f = u.top + (parseInt(a.borderTopWidth) || 0), l = u.left + (parseInt(a.borderLeftWidth) || 0), c = u.bottom - f - n.clientHeight - 2, h = function(e) {
                o.translate(n, e.clientX - l - 2, Math.min(e.clientY - f - 2, c));
            };
            h(e);
            if (e.type != "mousedown") return;
            t.renderer.$isMousePressed = !0, clearTimeout(Z), s.isWin && r.capture(t.container, h, et);
        }, this.onContextMenuClose = et;
        var Z, tt = function(e) {
            t.textInput.onContextMenu(e), et();
        };
        r.addListener(n, "mouseup", tt, t), r.addListener(n, "mousedown", function(e) {
            e.preventDefault(), et();
        }, t), r.addListener(t.renderer.scroller, "contextmenu", tt, t), r.addListener(n, "contextmenu", tt, t), v && nt(e, t, n), this.destroy = function() {
            n.parentElement && n.parentElement.removeChild(n);
        };
    }, t.TextInput = y, t.$setUserAgentForTests = function(e, t) {
        g = e, v = t;
    };
}), ace.define("ace/mouse/default_handlers", [
    "require",
    "exports",
    "module",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    function u(e, t, n, r) {
        return Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - t, 2));
    }
    function a(e, t) {
        if (e.start.row == e.end.row) var n = 2 * t.column - e.start.column - e.end.column;
        else if (e.start.row == e.end.row - 1 && !e.start.column && !e.end.column) var n = t.column - 4;
        else var n = 2 * t.row - e.start.row - e.end.row;
        return n < 0 ? {
            cursor: e.start,
            anchor: e.end
        } : {
            cursor: e.end,
            anchor: e.start
        };
    }
    var r = e("../lib/useragent"), i = 0, s = 550, o = function() {
        function e(e) {
            e.$clickSelection = null;
            var t = e.editor;
            t.setDefaultHandler("mousedown", this.onMouseDown.bind(e)), t.setDefaultHandler("dblclick", this.onDoubleClick.bind(e)), t.setDefaultHandler("tripleclick", this.onTripleClick.bind(e)), t.setDefaultHandler("quadclick", this.onQuadClick.bind(e)), t.setDefaultHandler("mousewheel", this.onMouseWheel.bind(e));
            var n = [
                "select",
                "startSelect",
                "selectEnd",
                "selectAllEnd",
                "selectByWordsEnd",
                "selectByLinesEnd",
                "dragWait",
                "dragWaitEnd",
                "focusWait"
            ];
            n.forEach(function(t) {
                e[t] = this[t];
            }, this), e.selectByLines = this.extendSelectionBy.bind(e, "getLineRange"), e.selectByWords = this.extendSelectionBy.bind(e, "getWordRange");
        }
        return e.prototype.onMouseDown = function(e) {
            var t = e.inSelection(), n = e.getDocumentPosition();
            this.mousedownEvent = e;
            var i = this.editor, s = e.getButton();
            if (s !== 0) {
                var o = i.getSelectionRange(), u = o.isEmpty();
                (u || s == 1) && i.selection.moveToPosition(n), s == 2 && (i.textInput.onContextMenu(e.domEvent), r.isMozilla || e.preventDefault());
                return;
            }
            this.mousedownEvent.time = Date.now();
            if (t && !i.isFocused()) {
                i.focus();
                if (this.$focusTimeout && !this.$clickSelection && !i.inMultiSelectMode) {
                    this.setState("focusWait"), this.captureMouse(e);
                    return;
                }
            }
            return this.captureMouse(e), this.startSelect(n, e.domEvent._clicks > 1), e.preventDefault();
        }, e.prototype.startSelect = function(e, t) {
            e = e || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var n = this.editor;
            if (!this.mousedownEvent) return;
            this.mousedownEvent.getShiftKey() ? n.selection.selectToPosition(e) : t || n.selection.moveToPosition(e), t || this.select(), n.setStyle("ace_selecting"), this.setState("select");
        }, e.prototype.select = function() {
            var e, t = this.editor, n = t.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
                var r = this.$clickSelection.comparePoint(n);
                if (r == -1) e = this.$clickSelection.end;
                else if (r == 1) e = this.$clickSelection.start;
                else {
                    var i = a(this.$clickSelection, n);
                    n = i.cursor, e = i.anchor;
                }
                t.selection.setSelectionAnchor(e.row, e.column);
            }
            t.selection.selectToPosition(n), t.renderer.scrollCursorIntoView();
        }, e.prototype.extendSelectionBy = function(e) {
            var t, n = this.editor, r = n.renderer.screenToTextCoordinates(this.x, this.y), i = n.selection[e](r.row, r.column);
            if (this.$clickSelection) {
                var s = this.$clickSelection.comparePoint(i.start), o = this.$clickSelection.comparePoint(i.end);
                if (s == -1 && o <= 0) {
                    t = this.$clickSelection.end;
                    if (i.end.row != r.row || i.end.column != r.column) r = i.start;
                } else if (o == 1 && s >= 0) {
                    t = this.$clickSelection.start;
                    if (i.start.row != r.row || i.start.column != r.column) r = i.end;
                } else if (s == -1 && o == 1) r = i.end, t = i.start;
                else {
                    var u = a(this.$clickSelection, r);
                    r = u.cursor, t = u.anchor;
                }
                n.selection.setSelectionAnchor(t.row, t.column);
            }
            n.selection.selectToPosition(r), n.renderer.scrollCursorIntoView();
        }, e.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null, this.editor.unsetStyle("ace_selecting");
        }, e.prototype.focusWait = function() {
            var e = u(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y), t = Date.now();
            (e > i || t - this.mousedownEvent.time > this.$focusTimeout) && this.startSelect(this.mousedownEvent.getDocumentPosition());
        }, e.prototype.onDoubleClick = function(e) {
            var t = e.getDocumentPosition(), n = this.editor, r = n.session, i = r.getBracketRange(t);
            i ? (i.isEmpty() && (i.start.column--, i.end.column++), this.setState("select")) : (i = n.selection.getWordRange(t.row, t.column), this.setState("selectByWords")), this.$clickSelection = i, this.select();
        }, e.prototype.onTripleClick = function(e) {
            var t = e.getDocumentPosition(), n = this.editor;
            this.setState("selectByLines");
            var r = n.getSelectionRange();
            r.isMultiLine() && r.contains(t.row, t.column) ? (this.$clickSelection = n.selection.getLineRange(r.start.row), this.$clickSelection.end = n.selection.getLineRange(r.end.row).end) : this.$clickSelection = n.selection.getLineRange(t.row), this.select();
        }, e.prototype.onQuadClick = function(e) {
            var t = this.editor;
            t.selectAll(), this.$clickSelection = t.getSelectionRange(), this.setState("selectAll");
        }, e.prototype.onMouseWheel = function(e) {
            if (e.getAccelKey()) return;
            e.getShiftKey() && e.wheelY && !e.wheelX && (e.wheelX = e.wheelY, e.wheelY = 0);
            var t = this.editor;
            this.$lastScroll || (this.$lastScroll = {
                t: 0,
                vx: 0,
                vy: 0,
                allowed: 0
            });
            var n = this.$lastScroll, r = e.domEvent.timeStamp, i = r - n.t, o = i ? e.wheelX / i : n.vx, u = i ? e.wheelY / i : n.vy;
            i < s && (o = (o + n.vx) / 2, u = (u + n.vy) / 2);
            var a = Math.abs(o / u), f = !1;
            a >= 1 && t.renderer.isScrollableBy(e.wheelX * e.speed, 0) && (f = !0), a <= 1 && t.renderer.isScrollableBy(0, e.wheelY * e.speed) && (f = !0);
            if (f) n.allowed = r;
            else if (r - n.allowed < s) {
                var l = Math.abs(o) <= 1.5 * Math.abs(n.vx) && Math.abs(u) <= 1.5 * Math.abs(n.vy);
                l ? (f = !0, n.allowed = r) : n.allowed = 0;
            }
            n.t = r, n.vx = o, n.vy = u;
            if (f) return t.renderer.scrollBy(e.wheelX * e.speed, e.wheelY * e.speed), e.stop();
        }, e;
    }();
    o.prototype.selectEnd = o.prototype.selectByLinesEnd, o.prototype.selectAllEnd = o.prototype.selectByLinesEnd, o.prototype.selectByWordsEnd = o.prototype.selectByLinesEnd, t.DefaultHandlers = o;
}), ace.define("ace/lib/scroll", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    t.preventParentScroll = function(t) {
        t.stopPropagation();
        var n = t.currentTarget, r = n.scrollHeight > n.clientHeight;
        r || t.preventDefault();
    };
}), ace.define("ace/tooltip", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/range",
    "ace/lib/scroll"
], function(e, t, n) {
    "use strict";
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = this && this.__values || function(e) {
        var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
        if (n) return n.call(e);
        if (e && typeof e.length == "number") return {
            next: function() {
                return e && r >= e.length && (e = void 0), {
                    value: e && e[r++],
                    done: !e
                };
            }
        };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, s = e("./lib/dom"), o = e("./lib/event"), u = e("./range").Range, a = e("./lib/scroll").preventParentScroll, f = "ace_tooltip", l = function() {
        function e(e) {
            this.isOpen = !1, this.$element = null, this.$parentNode = e;
        }
        return e.prototype.$init = function() {
            return this.$element = s.createElement("div"), this.$element.className = f, this.$element.style.display = "none", this.$parentNode.appendChild(this.$element), this.$element;
        }, e.prototype.getElement = function() {
            return this.$element || this.$init();
        }, e.prototype.setText = function(e) {
            this.getElement().textContent = e;
        }, e.prototype.setHtml = function(e) {
            this.getElement().innerHTML = e;
        }, e.prototype.setPosition = function(e, t) {
            this.getElement().style.left = e + "px", this.getElement().style.top = t + "px";
        }, e.prototype.setClassName = function(e) {
            s.addCssClass(this.getElement(), e);
        }, e.prototype.setTheme = function(e) {
            this.$element.className = f + " " + (e.isDark ? "ace_dark " : "") + (e.cssClass || "");
        }, e.prototype.show = function(e, t, n) {
            e != null && this.setText(e), t != null && n != null && this.setPosition(t, n), this.isOpen || (this.getElement().style.display = "block", this.isOpen = !0);
        }, e.prototype.hide = function(e) {
            this.isOpen && (this.getElement().style.display = "none", this.getElement().className = f, this.isOpen = !1);
        }, e.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
        }, e.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
        }, e.prototype.destroy = function() {
            this.isOpen = !1, this.$element && this.$element.parentNode && this.$element.parentNode.removeChild(this.$element);
        }, e;
    }(), c = function() {
        function e() {
            this.popups = [];
        }
        return e.prototype.addPopup = function(e) {
            this.popups.push(e), this.updatePopups();
        }, e.prototype.removePopup = function(e) {
            var t = this.popups.indexOf(e);
            t !== -1 && (this.popups.splice(t, 1), this.updatePopups());
        }, e.prototype.updatePopups = function() {
            var e, t, n, r;
            this.popups.sort(function(e, t) {
                return t.priority - e.priority;
            });
            var s = [];
            try {
                for(var o = i(this.popups), u = o.next(); !u.done; u = o.next()){
                    var a = u.value, f = !0;
                    try {
                        for(var l = (n = void 0, i(s)), c = l.next(); !c.done; c = l.next()){
                            var h = c.value;
                            if (this.doPopupsOverlap(h, a)) {
                                f = !1;
                                break;
                            }
                        }
                    } catch (p) {
                        n = {
                            error: p
                        };
                    } finally{
                        try {
                            c && !c.done && (r = l.return) && r.call(l);
                        } finally{
                            if (n) throw n.error;
                        }
                    }
                    f ? s.push(a) : a.hide();
                }
            } catch (d) {
                e = {
                    error: d
                };
            } finally{
                try {
                    u && !u.done && (t = o.return) && t.call(o);
                } finally{
                    if (e) throw e.error;
                }
            }
        }, e.prototype.doPopupsOverlap = function(e, t) {
            var n = e.getElement().getBoundingClientRect(), r = t.getElement().getBoundingClientRect();
            return n.left < r.right && n.right > r.left && n.top < r.bottom && n.bottom > r.top;
        }, e;
    }(), h = new c;
    t.popupManager = h, t.Tooltip = l;
    var p = function(e) {
        function t(t) {
            t === void 0 && (t = document.body);
            var n = e.call(this, t) || this;
            n.timeout = undefined, n.lastT = 0, n.idleTime = 350, n.lastEvent = undefined, n.onMouseOut = n.onMouseOut.bind(n), n.onMouseMove = n.onMouseMove.bind(n), n.waitForHover = n.waitForHover.bind(n), n.hide = n.hide.bind(n);
            var r = n.getElement();
            return r.style.whiteSpace = "pre-wrap", r.style.pointerEvents = "auto", r.addEventListener("mouseout", n.onMouseOut), r.tabIndex = -1, r.addEventListener("blur", (function() {
                r.contains(document.activeElement) || this.hide();
            }).bind(n)), r.addEventListener("wheel", a), n;
        }
        return r(t, e), t.prototype.addToEditor = function(e) {
            e.on("mousemove", this.onMouseMove), e.on("mousedown", this.hide), e.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, !0);
        }, t.prototype.removeFromEditor = function(e) {
            e.off("mousemove", this.onMouseMove), e.off("mousedown", this.hide), e.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, !0), this.timeout && (clearTimeout(this.timeout), this.timeout = null);
        }, t.prototype.onMouseMove = function(e, t) {
            this.lastEvent = e, this.lastT = Date.now();
            var n = t.$mouseHandler.isMousePressed;
            if (this.isOpen) {
                var r = this.lastEvent && this.lastEvent.getDocumentPosition();
                (!this.range || !this.range.contains(r.row, r.column) || n || this.isOutsideOfText(this.lastEvent)) && this.hide();
            }
            if (this.timeout || n) return;
            this.lastEvent = e, this.timeout = setTimeout(this.waitForHover, this.idleTime);
        }, t.prototype.waitForHover = function() {
            this.timeout && clearTimeout(this.timeout);
            var e = Date.now() - this.lastT;
            if (this.idleTime - e > 10) {
                this.timeout = setTimeout(this.waitForHover, this.idleTime - e);
                return;
            }
            this.timeout = null, this.lastEvent && !this.isOutsideOfText(this.lastEvent) && this.$gatherData(this.lastEvent, this.lastEvent.editor);
        }, t.prototype.isOutsideOfText = function(e) {
            var t = e.editor, n = e.getDocumentPosition(), r = t.session.getLine(n.row);
            if (n.column == r.length) {
                var i = t.renderer.pixelToScreenCoordinates(e.clientX, e.clientY), s = t.session.documentToScreenPosition(n.row, n.column);
                if (s.column != i.column || s.row != i.row) return !0;
            }
            return !1;
        }, t.prototype.setDataProvider = function(e) {
            this.$gatherData = e;
        }, t.prototype.showForRange = function(e, t, n, r) {
            var i = 10;
            if (r && r != this.lastEvent) return;
            if (this.isOpen && document.activeElement == this.getElement()) return;
            var s = e.renderer;
            this.isOpen || (h.addPopup(this), this.$registerCloseEvents(), this.setTheme(s.theme)), this.isOpen = !0, this.addMarker(t, e.session), this.range = u.fromPoints(t.start, t.end);
            var o = s.textToScreenCoordinates(t.start.row, t.start.column), a = s.scroller.getBoundingClientRect();
            o.pageX < a.left && (o.pageX = a.left);
            var f = this.getElement();
            f.innerHTML = "", f.appendChild(n), f.style.maxHeight = "", f.style.display = "block";
            var l = f.clientHeight, c = f.clientWidth, p = window.innerHeight - o.pageY - s.lineHeight, d = !0;
            o.pageY - l < 0 && o.pageY < p && (d = !1), f.style.maxHeight = (d ? o.pageY : p) - i + "px", f.style.top = d ? "" : o.pageY + s.lineHeight + "px", f.style.bottom = d ? window.innerHeight - o.pageY + "px" : "", f.style.left = Math.min(o.pageX, window.innerWidth - c - i) + "px";
        }, t.prototype.addMarker = function(e, t) {
            this.marker && this.$markerSession.removeMarker(this.marker), this.$markerSession = t, this.marker = t && t.addMarker(e, "ace_highlight-marker", "text");
        }, t.prototype.hide = function(e) {
            if (!e && document.activeElement == this.getElement()) return;
            if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target)) return;
            this.lastEvent = null, this.timeout && clearTimeout(this.timeout), this.timeout = null, this.addMarker(null), this.isOpen && (this.$removeCloseEvents(), this.getElement().style.display = "none", this.isOpen = !1, h.removePopup(this));
        }, t.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, !0), window.addEventListener("wheel", this.hide, !0), window.addEventListener("mousedown", this.hide, !0);
        }, t.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, !0), window.removeEventListener("wheel", this.hide, !0), window.removeEventListener("mousedown", this.hide, !0);
        }, t.prototype.onMouseOut = function(e) {
            this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.lastEvent = null;
            if (!this.isOpen) return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;
            if (e && e.currentTarget.contains(e.relatedTarget)) return;
            e.relatedTarget.classList.contains("ace_content") || this.hide();
        }, t;
    }(l);
    t.HoverTooltip = p;
}), ace.define("ace/mouse/default_gutter_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/tooltip",
    "ace/config"
], function(e, t, n) {
    "use strict";
    function c(e) {
        function a() {
            var i = u.getDocumentPosition().row, s = t.session.getLength();
            if (i == s) {
                var o = t.renderer.pixelToScreenCoordinates(0, u.y).row, a = u.$pos;
                if (o > t.session.documentToScreenRow(a.row, a.column)) return c();
            }
            r.showTooltip(i);
            if (!r.isOpen) return;
            t.on("mousewheel", c), t.on("changeSession", c), window.addEventListener("keydown", c, !0);
            if (e.$tooltipFollowsMouse) p(u);
            else {
                var h = u.getGutterRow(), d = n.$lines.get(h);
                if (d) {
                    var v = d.element.querySelector(".ace_gutter_annotation"), m = v.getBoundingClientRect(), g = r.getElement().style;
                    g.left = m.right - f + "px", g.top = m.bottom - l + "px";
                } else p(u);
            }
        }
        function c(e) {
            if (e && e.type === "keydown" && (e.ctrlKey || e.metaKey)) return;
            if (e && e.type === "mouseout" && (!e.relatedTarget || r.getElement().contains(e.relatedTarget))) return;
            i && (i = clearTimeout(i)), r.isOpen && (r.hideTooltip(), t.off("mousewheel", c), t.off("changeSession", c), window.removeEventListener("keydown", c, !0));
        }
        function p(e) {
            r.setPosition(e.x, e.y);
        }
        var t = e.editor, n = t.renderer.$gutterLayer, r = new h(t, !0);
        e.editor.setDefaultHandler("guttermousedown", function(r) {
            if (!t.isFocused() || r.getButton() != 0) return;
            var i = n.getRegion(r);
            if (i == "foldWidgets") return;
            var s = r.getDocumentPosition().row, o = t.session.selection;
            if (r.getShiftKey()) o.selectTo(s, 0);
            else {
                if (r.domEvent.detail == 2) return t.selectAll(), r.preventDefault();
                e.$clickSelection = t.selection.getLineRange(s);
            }
            return e.setState("selectByLines"), e.captureMouse(r), r.preventDefault();
        });
        var i, u;
        e.editor.setDefaultHandler("guttermousemove", function(t) {
            var n = t.domEvent.target || t.domEvent.srcElement;
            if (s.hasCssClass(n, "ace_fold-widget") || s.hasCssClass(n, "ace_custom-widget")) return c();
            r.isOpen && e.$tooltipFollowsMouse && p(t), u = t;
            if (i) return;
            i = setTimeout(function() {
                i = null, u && !e.isMousePressed && a();
            }, 50);
        }), o.addListener(t.renderer.$gutter, "mouseout", function(e) {
            u = null;
            if (!r.isOpen) return;
            i = setTimeout(function() {
                i = null, c(e);
            }, 50);
        }, t);
    }
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = this && this.__values || function(e) {
        var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
        if (n) return n.call(e);
        if (e && typeof e.length == "number") return {
            next: function() {
                return e && r >= e.length && (e = void 0), {
                    value: e && e[r++],
                    done: !e
                };
            }
        };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, s = e("../lib/dom"), o = e("../lib/event"), u = e("../tooltip").Tooltip, a = e("../config").nls, f = 5, l = 3;
    t.GUTTER_TOOLTIP_LEFT_OFFSET = f, t.GUTTER_TOOLTIP_TOP_OFFSET = l, t.GutterHandler = c;
    var h = function(e) {
        function t(t, n) {
            n === void 0 && (n = !1);
            var r = e.call(this, t.container) || this;
            r.editor = t, r.visibleTooltipRow;
            var i = r.getElement();
            return i.setAttribute("role", "tooltip"), i.style.pointerEvents = "auto", n && (r.onMouseOut = r.onMouseOut.bind(r), i.addEventListener("mouseout", r.onMouseOut)), r;
        }
        return r(t, e), t.prototype.onMouseOut = function(e) {
            if (!this.isOpen) return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;
            if (e && e.currentTarget.contains(e.relatedTarget)) return;
            this.hideTooltip();
        }, t.prototype.setPosition = function(e, t) {
            var n = window.innerWidth || document.documentElement.clientWidth, r = window.innerHeight || document.documentElement.clientHeight, i = this.getWidth(), s = this.getHeight();
            e += 15, t += 15, e + i > n && (e -= e + i - n), t + s > r && (t -= 20 + s), u.prototype.setPosition.call(this, e, t);
        }, Object.defineProperty(t, "annotationLabels", {
            get: function() {
                return {
                    error: {
                        singular: a("gutter-tooltip.aria-label.error.singular", "error"),
                        plural: a("gutter-tooltip.aria-label.error.plural", "errors")
                    },
                    security: {
                        singular: a("gutter-tooltip.aria-label.security.singular", "security finding"),
                        plural: a("gutter-tooltip.aria-label.security.plural", "security findings")
                    },
                    warning: {
                        singular: a("gutter-tooltip.aria-label.warning.singular", "warning"),
                        plural: a("gutter-tooltip.aria-label.warning.plural", "warnings")
                    },
                    info: {
                        singular: a("gutter-tooltip.aria-label.info.singular", "information message"),
                        plural: a("gutter-tooltip.aria-label.info.plural", "information messages")
                    },
                    hint: {
                        singular: a("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                        plural: a("gutter-tooltip.aria-label.hint.plural", "suggestions")
                    }
                };
            },
            enumerable: !1,
            configurable: !0
        }), t.prototype.showTooltip = function(e) {
            var n, r = this.editor.renderer.$gutterLayer, i = r.$annotations[e], o;
            i ? o = {
                displayText: Array.from(i.displayText),
                type: Array.from(i.type)
            } : o = {
                displayText: [],
                type: []
            };
            var u = r.session.getFoldLine(e);
            if (u && r.$showFoldedAnnotations) {
                var a = {
                    error: [],
                    security: [],
                    warning: [],
                    info: [],
                    hint: []
                }, f = {
                    error: 1,
                    security: 2,
                    warning: 3,
                    info: 4,
                    hint: 5
                }, l;
                for(var c = e + 1; c <= u.end.row; c++){
                    if (!r.$annotations[c]) continue;
                    for(var h = 0; h < r.$annotations[c].text.length; h++){
                        var p = r.$annotations[c].type[h];
                        a[p].push(r.$annotations[c].text[h]);
                        if (!l || f[p] < f[l]) l = p;
                    }
                }
                if ([
                    "error",
                    "security",
                    "warning"
                ].includes(l)) {
                    var d = "".concat(t.annotationsToSummaryString(a), " in folded code.");
                    o.displayText.push(d), o.type.push(l + "_fold");
                }
            }
            if (o.displayText.length === 0) return this.hideTooltip();
            var v = {
                error: [],
                security: [],
                warning: [],
                info: [],
                hint: []
            }, m = r.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for(var c = 0; c < o.displayText.length; c++){
                var g = s.createElement("span"), y = s.createElement("span");
                (n = y.classList).add.apply(n, [
                    "ace_".concat(o.type[c]),
                    m
                ]), y.setAttribute("aria-label", "".concat(t.annotationLabels[o.type[c].replace("_fold", "")].singular)), y.setAttribute("role", "img"), y.appendChild(s.createTextNode(" ")), g.appendChild(y), g.appendChild(s.createTextNode(o.displayText[c])), g.appendChild(s.createElement("br")), v[o.type[c].replace("_fold", "")].push(g);
            }
            var b = this.getElement();
            s.removeChildren(b), v.error.forEach(function(e) {
                return b.appendChild(e);
            }), v.security.forEach(function(e) {
                return b.appendChild(e);
            }), v.warning.forEach(function(e) {
                return b.appendChild(e);
            }), v.info.forEach(function(e) {
                return b.appendChild(e);
            }), v.hint.forEach(function(e) {
                return b.appendChild(e);
            }), b.setAttribute("aria-live", "polite"), this.isOpen || (this.setTheme(this.editor.renderer.theme), this.setClassName("ace_gutter-tooltip")), this.show(), this.visibleTooltipRow = e, this.editor._signal("showGutterTooltip", this);
        }, t.prototype.hideTooltip = function() {
            if (!this.isOpen) return;
            this.$element.removeAttribute("aria-live"), this.hide(), this.visibleTooltipRow = undefined, this.editor._signal("hideGutterTooltip", this);
        }, t.annotationsToSummaryString = function(e) {
            var n, r, s = [], o = [
                "error",
                "security",
                "warning",
                "info",
                "hint"
            ];
            try {
                for(var u = i(o), a = u.next(); !a.done; a = u.next()){
                    var f = a.value;
                    if (!e[f].length) continue;
                    var l = e[f].length === 1 ? t.annotationLabels[f].singular : t.annotationLabels[f].plural;
                    s.push("".concat(e[f].length, " ").concat(l));
                }
            } catch (c) {
                n = {
                    error: c
                };
            } finally{
                try {
                    a && !a.done && (r = u.return) && r.call(u);
                } finally{
                    if (n) throw n.error;
                }
            }
            return s.join(", ");
        }, t;
    }(u);
    t.GutterTooltip = h;
}), ace.define("ace/mouse/mouse_event", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/event"), i = e("../lib/useragent"), s = function() {
        function e(e, t) {
            this.speed, this.wheelX, this.wheelY, this.domEvent = e, this.editor = t, this.x = this.clientX = e.clientX, this.y = this.clientY = e.clientY, this.$pos = null, this.$inSelection = null, this.propagationStopped = !1, this.defaultPrevented = !1;
        }
        return e.prototype.stopPropagation = function() {
            r.stopPropagation(this.domEvent), this.propagationStopped = !0;
        }, e.prototype.preventDefault = function() {
            r.preventDefault(this.domEvent), this.defaultPrevented = !0;
        }, e.prototype.stop = function() {
            this.stopPropagation(), this.preventDefault();
        }, e.prototype.getDocumentPosition = function() {
            return this.$pos ? this.$pos : (this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY), this.$pos);
        }, e.prototype.getGutterRow = function() {
            var e = this.getDocumentPosition().row, t = this.editor.session.documentToScreenRow(e, 0), n = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return t - n;
        }, e.prototype.inSelection = function() {
            if (this.$inSelection !== null) return this.$inSelection;
            var e = this.editor, t = e.getSelectionRange();
            if (t.isEmpty()) this.$inSelection = !1;
            else {
                var n = this.getDocumentPosition();
                this.$inSelection = t.contains(n.row, n.column);
            }
            return this.$inSelection;
        }, e.prototype.getButton = function() {
            return r.getButton(this.domEvent);
        }, e.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
        }, e.prototype.getAccelKey = function() {
            return i.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
        }, e;
    }();
    t.MouseEvent = s;
}), ace.define("ace/mouse/dragdrop_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    function f(e) {
        function T(e, n) {
            var r = Date.now(), i = !n || e.row != n.row, s = !n || e.column != n.column;
            if (!S || i || s) t.moveCursorToPosition(e), S = r, x = {
                x: p,
                y: d
            };
            else {
                var o = l(x.x, x.y, p, d);
                o > a ? S = null : r - S >= u && (t.renderer.scrollCursorIntoView(), S = null);
            }
        }
        function N(e, n) {
            var r = Date.now(), i = t.renderer.layerConfig.lineHeight, s = t.renderer.layerConfig.characterWidth, u = t.renderer.scroller.getBoundingClientRect(), a = {
                x: {
                    left: p - u.left,
                    right: u.right - p
                },
                y: {
                    top: d - u.top,
                    bottom: u.bottom - d
                }
            }, f = Math.min(a.x.left, a.x.right), l = Math.min(a.y.top, a.y.bottom), c = {
                row: e.row,
                column: e.column
            };
            f / s <= 2 && (c.column += a.x.left < a.x.right ? -3 : 2), l / i <= 1 && (c.row += a.y.top < a.y.bottom ? -1 : 1);
            var h = e.row != c.row, v = e.column != c.column, m = !n || e.row != n.row;
            h || v && !m ? E ? r - E >= o && t.renderer.scrollCursorIntoView(c) : E = r : E = null;
        }
        function C() {
            var e = g;
            g = t.renderer.screenToTextCoordinates(p, d), T(g, e), N(g, e);
        }
        function k() {
            m = t.selection.toOrientedRange(), h = t.session.addMarker(m, "ace_selection", t.getSelectionStyle()), t.clearSelection(), t.isFocused() && t.renderer.$cursorLayer.setBlinking(!1), clearInterval(v), C(), v = setInterval(C, 20), y = 0, i.addListener(document, "mousemove", O);
        }
        function L() {
            clearInterval(v), t.session.removeMarker(h), h = null, t.selection.fromOrientedRange(m), t.isFocused() && !w && t.$resetCursorStyle(), m = null, g = null, y = 0, E = null, S = null, i.removeListener(document, "mousemove", O);
        }
        function O() {
            A == null && (A = setTimeout(function() {
                A != null && h && L();
            }, 20));
        }
        function M(e) {
            var t = e.types;
            return !t || Array.prototype.some.call(t, function(e) {
                return e == "text/plain" || e == "Text";
            });
        }
        function _(e) {
            var t = [
                "copy",
                "copymove",
                "all",
                "uninitialized"
            ], n = [
                "move",
                "copymove",
                "linkmove",
                "all",
                "uninitialized"
            ], r = s.isMac ? e.altKey : e.ctrlKey, i = "uninitialized";
            try {
                i = e.dataTransfer.effectAllowed.toLowerCase();
            } catch (e) {}
            var o = "none";
            return r && t.indexOf(i) >= 0 ? o = "copy" : n.indexOf(i) >= 0 ? o = "move" : t.indexOf(i) >= 0 && (o = "copy"), o;
        }
        var t = e.editor, n = r.createElement("div");
        n.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5", n.textContent = "\xa0";
        var f = [
            "dragWait",
            "dragWaitEnd",
            "startDrag",
            "dragReadyEnd",
            "onMouseDrag"
        ];
        f.forEach(function(t) {
            e[t] = this[t];
        }, this), t.on("mousedown", this.onMouseDown.bind(e));
        var c = t.container, h, p, d, v, m, g, y = 0, b, w, E, S, x;
        this.onDragStart = function(e) {
            if (this.cancelDrag || !c.draggable) {
                var r = this;
                return setTimeout(function() {
                    r.startSelect(), r.captureMouse(e);
                }, 0), e.preventDefault();
            }
            m = t.getSelectionRange();
            var i = e.dataTransfer;
            i.effectAllowed = t.getReadOnly() ? "copy" : "copyMove", t.container.appendChild(n), i.setDragImage && i.setDragImage(n, 0, 0), setTimeout(function() {
                t.container.removeChild(n);
            }), i.clearData(), i.setData("Text", t.session.getTextRange()), w = !0, this.setState("drag");
        }, this.onDragEnd = function(e) {
            c.draggable = !1, w = !1, this.setState(null);
            if (!t.getReadOnly()) {
                var n = e.dataTransfer.dropEffect;
                !b && n == "move" && t.session.remove(t.getSelectionRange()), t.$resetCursorStyle();
            }
            this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle("");
        }, this.onDragEnter = function(e) {
            if (t.getReadOnly() || !M(e.dataTransfer)) return;
            return p = e.clientX, d = e.clientY, h || k(), y++, e.dataTransfer.dropEffect = b = _(e), i.preventDefault(e);
        }, this.onDragOver = function(e) {
            if (t.getReadOnly() || !M(e.dataTransfer)) return;
            return p = e.clientX, d = e.clientY, h || (k(), y++), A !== null && (A = null), e.dataTransfer.dropEffect = b = _(e), i.preventDefault(e);
        }, this.onDragLeave = function(e) {
            y--;
            if (y <= 0 && h) return L(), b = null, i.preventDefault(e);
        }, this.onDrop = function(e) {
            if (!g) return;
            var n = e.dataTransfer;
            if (w) switch(b){
                case "move":
                    m.contains(g.row, g.column) ? m = {
                        start: g,
                        end: g
                    } : m = t.moveText(m, g);
                    break;
                case "copy":
                    m = t.moveText(m, g, !0);
            }
            else {
                var r = n.getData("Text");
                m = {
                    start: g,
                    end: t.session.insert(g, r)
                }, t.focus(), b = null;
            }
            return L(), i.preventDefault(e);
        }, i.addListener(c, "dragstart", this.onDragStart.bind(e), t), i.addListener(c, "dragend", this.onDragEnd.bind(e), t), i.addListener(c, "dragenter", this.onDragEnter.bind(e), t), i.addListener(c, "dragover", this.onDragOver.bind(e), t), i.addListener(c, "dragleave", this.onDragLeave.bind(e), t), i.addListener(c, "drop", this.onDrop.bind(e), t);
        var A = null;
    }
    function l(e, t, n, r) {
        return Math.sqrt(Math.pow(n - e, 2) + Math.pow(r - t, 2));
    }
    var r = e("../lib/dom"), i = e("../lib/event"), s = e("../lib/useragent"), o = 200, u = 200, a = 5;
    (function() {
        this.dragWait = function() {
            var e = Date.now() - this.mousedownEvent.time;
            e > this.editor.getDragDelay() && this.startDrag();
        }, this.dragWaitEnd = function() {
            var e = this.editor.container;
            e.draggable = !1, this.startSelect(this.mousedownEvent.getDocumentPosition()), this.selectEnd();
        }, this.dragReadyEnd = function(e) {
            this.editor.$resetCursorStyle(), this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle(""), this.dragWaitEnd();
        }, this.startDrag = function() {
            this.cancelDrag = !1;
            var e = this.editor, t = e.container;
            t.draggable = !0, e.renderer.$cursorLayer.setBlinking(!1), e.setStyle("ace_dragging");
            var n = s.isWin ? "default" : "move";
            e.renderer.setCursorStyle(n), this.setState("dragReady");
        }, this.onMouseDrag = function(e) {
            var t = this.editor.container;
            if (s.isIE && this.state == "dragReady") {
                var n = l(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                n > 3 && t.dragDrop();
            }
            if (this.state === "dragWait") {
                var n = l(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                n > 0 && (t.draggable = !1, this.startSelect(this.mousedownEvent.getDocumentPosition()));
            }
        }, this.onMouseDown = function(e) {
            if (!this.$dragEnabled) return;
            this.mousedownEvent = e;
            var t = this.editor, n = e.inSelection(), r = e.getButton(), i = e.domEvent.detail || 1;
            if (i === 1 && r === 0 && n) {
                if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                this.mousedownEvent.time = Date.now();
                var o = e.domEvent.target || e.domEvent.srcElement;
                "unselectable" in o && (o.unselectable = "on");
                if (t.getDragDelay()) {
                    if (s.isWebKit) {
                        this.cancelDrag = !0;
                        var u = t.container;
                        u.draggable = !0;
                    }
                    this.setState("dragWait");
                } else this.startDrag();
                this.captureMouse(e, this.onMouseDrag.bind(this)), e.defaultPrevented = !0;
            }
        };
    }).call(f.prototype), t.DragdropHandler = f;
}), ace.define("ace/mouse/touch_handler", [
    "require",
    "exports",
    "module",
    "ace/mouse/mouse_event",
    "ace/lib/event",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("./mouse_event").MouseEvent, i = e("../lib/event"), s = e("../lib/dom");
    t.addTouchListeners = function(e, t) {
        function b() {
            var e = window.navigator && window.navigator.clipboard, r = !1, i = function() {
                var n = t.getCopyText(), i = t.session.getUndoManager().hasUndo();
                y.replaceChild(s.buildDom(r ? [
                    "span",
                    !n && o("selectall") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "selectall"
                        },
                        "Select All"
                    ],
                    n && o("copy") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "copy"
                        },
                        "Copy"
                    ],
                    n && o("cut") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "cut"
                        },
                        "Cut"
                    ],
                    e && o("paste") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "paste"
                        },
                        "Paste"
                    ],
                    i && o("undo") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "undo"
                        },
                        "Undo"
                    ],
                    o("find") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "find"
                        },
                        "Find"
                    ],
                    o("openCommandPalette") && [
                        "span",
                        {
                            "class": "ace_mobile-button",
                            action: "openCommandPalette"
                        },
                        "Palette"
                    ]
                ] : [
                    "span"
                ]), y.firstChild);
            }, o = function(e) {
                return t.commands.canExecute(e, t);
            }, u = function(n) {
                var s = n.target.getAttribute("action");
                if (s == "more" || !r) return r = !r, i();
                if (s == "paste") e.readText().then(function(e) {
                    t.execCommand(s, e);
                });
                else if (s) {
                    if (s == "cut" || s == "copy") e ? e.writeText(t.getCopyText()) : document.execCommand("copy");
                    t.execCommand(s);
                }
                y.firstChild.style.display = "none", r = !1, s != "openCommandPalette" && t.focus();
            };
            y = s.buildDom([
                "div",
                {
                    "class": "ace_mobile-menu",
                    ontouchstart: function(e) {
                        n = "menu", e.stopPropagation(), e.preventDefault(), t.textInput.focus();
                    },
                    ontouchend: function(e) {
                        e.stopPropagation(), e.preventDefault(), u(e);
                    },
                    onclick: u
                },
                [
                    "span"
                ],
                [
                    "span",
                    {
                        "class": "ace_mobile-button",
                        action: "more"
                    },
                    "..."
                ]
            ], t.container);
        }
        function w() {
            if (!t.getOption("enableMobileMenu")) {
                y && E();
                return;
            }
            y || b();
            var e = t.selection.cursor, n = t.renderer.textToScreenCoordinates(e.row, e.column), r = t.renderer.textToScreenCoordinates(0, 0).pageX, i = t.renderer.scrollLeft, s = t.container.getBoundingClientRect();
            y.style.top = n.pageY - s.top - 3 + "px", n.pageX - s.left < s.width - 70 ? (y.style.left = "", y.style.right = "10px") : (y.style.right = "", y.style.left = r + i - s.left + "px"), y.style.display = "", y.firstChild.style.display = "none", t.on("input", E);
        }
        function E(e) {
            y && (y.style.display = "none"), t.off("input", E);
        }
        function S() {
            l = null, clearTimeout(l);
            var e = t.selection.getRange(), r = e.contains(p.row, p.column);
            if (e.isEmpty() || !r) t.selection.moveToPosition(p), t.selection.selectWord();
            n = "wait", w();
        }
        function x() {
            l = null, clearTimeout(l), t.selection.moveToPosition(p);
            var e = d >= 2 ? t.selection.getLineRange(p.row) : t.session.getBracketRange(p);
            e && !e.isEmpty() ? t.selection.setRange(e) : t.selection.selectWord(), n = "wait";
        }
        function T() {
            h += 60, c = setInterval(function() {
                h-- <= 0 && (clearInterval(c), c = null), Math.abs(v) < .01 && (v = 0), Math.abs(m) < .01 && (m = 0), h < 20 && (v = .9 * v), h < 20 && (m = .9 * m);
                var e = t.session.getScrollTop();
                t.renderer.scrollBy(10 * v, 10 * m), e == t.session.getScrollTop() && (h = 0);
            }, 10);
        }
        var n = "scroll", o, u, a, f, l, c, h = 0, p, d = 0, v = 0, m = 0, g, y;
        i.addListener(e, "contextmenu", function(e) {
            if (!g) return;
            var n = t.textInput.getElement();
            n.focus();
        }, t), i.addListener(e, "touchstart", function(e) {
            var i = e.touches;
            if (l || i.length > 1) {
                clearTimeout(l), l = null, a = -1, n = "zoom";
                return;
            }
            g = t.$mouseHandler.isMousePressed = !0;
            var s = t.renderer.layerConfig.lineHeight, c = t.renderer.layerConfig.lineHeight, y = e.timeStamp;
            f = y;
            var b = i[0], w = b.clientX, E = b.clientY;
            Math.abs(o - w) + Math.abs(u - E) > s && (a = -1), o = e.clientX = w, u = e.clientY = E, v = m = 0;
            var T = new r(e, t);
            p = T.getDocumentPosition();
            if (y - a < 500 && i.length == 1 && !h) d++, e.preventDefault(), e.button = 0, x();
            else {
                d = 0;
                var N = t.selection.cursor, C = t.selection.isEmpty() ? N : t.selection.anchor, k = t.renderer.$cursorLayer.getPixelPosition(N, !0), L = t.renderer.$cursorLayer.getPixelPosition(C, !0), A = t.renderer.scroller.getBoundingClientRect(), O = t.renderer.layerConfig.offset, M = t.renderer.scrollLeft, _ = function(e, t) {
                    return e /= c, t = t / s - .75, e * e + t * t;
                };
                if (e.clientX < A.left) {
                    n = "zoom";
                    return;
                }
                var D = _(e.clientX - A.left - k.left + M, e.clientY - A.top - k.top + O), P = _(e.clientX - A.left - L.left + M, e.clientY - A.top - L.top + O);
                D < 3.5 && P < 3.5 && (n = D > P ? "cursor" : "anchor"), P < 3.5 ? n = "anchor" : D < 3.5 ? n = "cursor" : n = "scroll", l = setTimeout(S, 450);
            }
            a = y;
        }, t), i.addListener(e, "touchend", function(e) {
            g = t.$mouseHandler.isMousePressed = !1, c && clearInterval(c), n == "zoom" ? (n = "", h = 0) : l ? (t.selection.moveToPosition(p), h = 0, w()) : n == "scroll" ? (T(), E()) : w(), clearTimeout(l), l = null;
        }, t), i.addListener(e, "touchmove", function(e) {
            l && (clearTimeout(l), l = null);
            var i = e.touches;
            if (i.length > 1 || n == "zoom") return;
            var s = i[0], a = o - s.clientX, c = u - s.clientY;
            if (n == "wait") {
                if (!(a * a + c * c > 4)) return e.preventDefault();
                n = "cursor";
            }
            o = s.clientX, u = s.clientY, e.clientX = s.clientX, e.clientY = s.clientY;
            var h = e.timeStamp, p = h - f;
            f = h;
            if (n == "scroll") {
                var d = new r(e, t);
                d.speed = 1, d.wheelX = a, d.wheelY = c, 10 * Math.abs(a) < Math.abs(c) && (a = 0), 10 * Math.abs(c) < Math.abs(a) && (c = 0), p != 0 && (v = a / p, m = c / p), t._emit("mousewheel", d), d.propagationStopped || (v = m = 0);
            } else {
                var g = new r(e, t), y = g.getDocumentPosition();
                n == "cursor" ? t.selection.moveCursorToPosition(y) : n == "anchor" && t.selection.setSelectionAnchor(y.row, y.column), t.renderer.scrollCursorIntoView(y), e.preventDefault();
            }
        }, t);
    };
}), ace.define("ace/mouse/mouse_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent",
    "ace/mouse/default_handlers",
    "ace/mouse/default_gutter_handler",
    "ace/mouse/mouse_event",
    "ace/mouse/dragdrop_handler",
    "ace/mouse/touch_handler",
    "ace/config"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/event"), i = e("../lib/useragent"), s = e("./default_handlers").DefaultHandlers, o = e("./default_gutter_handler").GutterHandler, u = e("./mouse_event").MouseEvent, a = e("./dragdrop_handler").DragdropHandler, f = e("./touch_handler").addTouchListeners, l = e("../config"), c = function() {
        function e(e) {
            this.$dragDelay, this.$dragEnabled, this.$mouseMoved, this.mouseEvent, this.$focusTimeout;
            var t = this;
            this.editor = e, new s(this), new o(this), new a(this);
            var n = function(t) {
                var n = !document.hasFocus || !document.hasFocus() || !e.isFocused() && document.activeElement == (e.textInput && e.textInput.getElement());
                n && window.focus(), e.focus(), setTimeout(function() {
                    e.isFocused() || e.focus();
                });
            }, u = e.renderer.getMouseEventTarget();
            r.addListener(u, "click", this.onMouseEvent.bind(this, "click"), e), r.addListener(u, "mousemove", this.onMouseMove.bind(this, "mousemove"), e), r.addMultiMouseDownListener([
                u,
                e.renderer.scrollBarV && e.renderer.scrollBarV.inner,
                e.renderer.scrollBarH && e.renderer.scrollBarH.inner,
                e.textInput && e.textInput.getElement()
            ].filter(Boolean), [
                400,
                300,
                250
            ], this, "onMouseEvent", e), r.addMouseWheelListener(e.container, this.onMouseWheel.bind(this, "mousewheel"), e), f(e.container, e);
            var l = e.renderer.$gutter;
            r.addListener(l, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), e), r.addListener(l, "click", this.onMouseEvent.bind(this, "gutterclick"), e), r.addListener(l, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), e), r.addListener(l, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), e), r.addListener(u, "mousedown", n, e), r.addListener(l, "mousedown", n, e), i.isIE && e.renderer.scrollBarV && (r.addListener(e.renderer.scrollBarV.element, "mousedown", n, e), r.addListener(e.renderer.scrollBarH.element, "mousedown", n, e)), e.on("mousemove", function(n) {
                if (t.state || t.$dragDelay || !t.$dragEnabled) return;
                var r = e.renderer.screenToTextCoordinates(n.x, n.y), i = e.session.selection.getRange(), s = e.renderer;
                !i.isEmpty() && i.insideStart(r.row, r.column) ? s.setCursorStyle("default") : s.setCursorStyle("");
            }, e);
        }
        return e.prototype.onMouseEvent = function(e, t) {
            if (!this.editor.session) return;
            this.editor._emit(e, new u(t, this.editor));
        }, e.prototype.onMouseMove = function(e, t) {
            var n = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!n || !n.length) return;
            this.editor._emit(e, new u(t, this.editor));
        }, e.prototype.onMouseWheel = function(e, t) {
            var n = new u(t, this.editor);
            n.speed = this.$scrollSpeed * 2, n.wheelX = t.wheelX, n.wheelY = t.wheelY, this.editor._emit(e, n);
        }, e.prototype.setState = function(e) {
            this.state = e;
        }, e.prototype.captureMouse = function(e, t) {
            this.x = e.x, this.y = e.y, this.isMousePressed = !0;
            var n = this.editor, s = this.editor.renderer;
            s.$isMousePressed = !0;
            var o = this, a = !0, f = function(e) {
                if (!e) return;
                if (i.isWebKit && !e.which && o.releaseMouse) return o.releaseMouse();
                o.x = e.clientX, o.y = e.clientY, t && t(e), o.mouseEvent = new u(e, o.editor), o.$mouseMoved = !0;
            }, l = function(e) {
                n.off("beforeEndOperation", p), a = !1, n.session && c(), o[o.state + "End"] && o[o.state + "End"](e), o.state = "", o.isMousePressed = s.$isMousePressed = !1, s.$keepTextAreaAtCursor && s.$moveTextAreaToCursor(), o.$onCaptureMouseMove = o.releaseMouse = null, e && o.onMouseEvent("mouseup", e), n.endOperation();
            }, c = function() {
                o[o.state] && o[o.state](), o.$mouseMoved = !1;
            }, h = function() {
                a && (c(), r.nextFrame(h));
            };
            if (i.isOldIE && e.domEvent.type == "dblclick") return setTimeout(function() {
                l(e);
            });
            var p = function(e) {
                if (!o.releaseMouse) return;
                n.curOp.command.name && n.curOp.selectionChanged && (o[o.state + "End"] && o[o.state + "End"](), o.state = "", o.releaseMouse());
            };
            n.on("beforeEndOperation", p), n.startOperation({
                command: {
                    name: "mouse"
                }
            }), o.$onCaptureMouseMove = f, o.releaseMouse = r.capture(this.editor.container, f, l), h();
        }, e.prototype.cancelContextMenu = function() {
            var e = (function(t) {
                if (t && t.domEvent && t.domEvent.type != "contextmenu") return;
                this.editor.off("nativecontextmenu", e), t && t.domEvent && r.stopEvent(t.domEvent);
            }).bind(this);
            setTimeout(e, 10), this.editor.on("nativecontextmenu", e);
        }, e.prototype.destroy = function() {
            this.releaseMouse && this.releaseMouse();
        }, e;
    }();
    c.prototype.releaseMouse = null, l.defineOptions(c.prototype, "mouseHandler", {
        scrollSpeed: {
            initialValue: 2
        },
        dragDelay: {
            initialValue: i.isMac ? 150 : 0
        },
        dragEnabled: {
            initialValue: !0
        },
        focusTimeout: {
            initialValue: 0
        },
        tooltipFollowsMouse: {
            initialValue: !0
        }
    }), t.MouseHandler = c;
}), ace.define("ace/mouse/fold_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/dom"), i = function() {
        function e(e) {
            e.on("click", function(t) {
                var n = t.getDocumentPosition(), i = e.session, s = i.getFoldAt(n.row, n.column, 1);
                s && (t.getAccelKey() ? i.removeFold(s) : i.expandFold(s), t.stop());
                var o = t.domEvent && t.domEvent.target;
                o && r.hasCssClass(o, "ace_inline_button") && r.hasCssClass(o, "ace_toggle_wrap") && (i.setOption("wrap", !i.getUseWrapMode()), e.renderer.scrollCursorIntoView());
            }), e.on("gutterclick", function(t) {
                var n = e.renderer.$gutterLayer.getRegion(t);
                if (n == "foldWidgets") {
                    var r = t.getDocumentPosition().row, i = e.session;
                    i.foldWidgets && i.foldWidgets[r] && e.session.onFoldWidgetClick(r, t), e.isFocused() || e.focus(), t.stop();
                }
            }), e.on("gutterdblclick", function(t) {
                var n = e.renderer.$gutterLayer.getRegion(t);
                if (n == "foldWidgets") {
                    var r = t.getDocumentPosition().row, i = e.session, s = i.getParentFoldRangeData(r, !0), o = s.range || s.firstRange;
                    if (o) {
                        r = o.start.row;
                        var u = i.getFoldAt(r, i.getLine(r).length, 1);
                        u ? i.removeFold(u) : (i.addFold("...", o), e.renderer.scrollCursorIntoView({
                            row: o.start.row,
                            column: 0
                        }));
                    }
                    t.stop();
                }
            });
        }
        return e;
    }();
    t.FoldHandler = i;
}), ace.define("ace/keyboard/keybinding", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/event"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/keys"), i = e("../lib/event"), s = function() {
        function e(e) {
            this.$editor = e, this.$data = {
                editor: e
            }, this.$handlers = [], this.setDefaultHandler(e.commands);
        }
        return e.prototype.setDefaultHandler = function(e) {
            this.removeKeyboardHandler(this.$defaultHandler), this.$defaultHandler = e, this.addKeyboardHandler(e, 0);
        }, e.prototype.setKeyboardHandler = function(e) {
            var t = this.$handlers;
            if (t[t.length - 1] == e) return;
            while(t[t.length - 1] && t[t.length - 1] != this.$defaultHandler)this.removeKeyboardHandler(t[t.length - 1]);
            this.addKeyboardHandler(e, 1);
        }, e.prototype.addKeyboardHandler = function(e, t) {
            if (!e) return;
            typeof e == "function" && !e.handleKeyboard && (e.handleKeyboard = e);
            var n = this.$handlers.indexOf(e);
            n != -1 && this.$handlers.splice(n, 1), t == undefined ? this.$handlers.push(e) : this.$handlers.splice(t, 0, e), n == -1 && e.attach && e.attach(this.$editor);
        }, e.prototype.removeKeyboardHandler = function(e) {
            var t = this.$handlers.indexOf(e);
            return t == -1 ? !1 : (this.$handlers.splice(t, 1), e.detach && e.detach(this.$editor), !0);
        }, e.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
        }, e.prototype.getStatusText = function() {
            var e = this.$data, t = e.editor;
            return this.$handlers.map(function(n) {
                return n.getStatusText && n.getStatusText(t, e) || "";
            }).filter(Boolean).join(" ");
        }, e.prototype.$callKeyboardHandlers = function(e, t, n, r) {
            var s, o = !1, u = this.$editor.commands;
            for(var a = this.$handlers.length; a--;){
                s = this.$handlers[a].handleKeyboard(this.$data, e, t, n, r);
                if (!s || !s.command) continue;
                s.command == "null" ? o = !0 : o = u.exec(s.command, this.$editor, s.args, r), o && r && e != -1 && s["passEvent"] != 1 && s.command["passEvent"] != 1 && i.stopEvent(r);
                if (o) break;
            }
            return !o && e == -1 && (s = {
                command: "insertstring"
            }, o = u.exec("insertstring", this.$editor, t)), o && this.$editor._signal && this.$editor._signal("keyboardActivity", s), o;
        }, e.prototype.onCommandKey = function(e, t, n) {
            var i = r.keyCodeToString(n);
            return this.$callKeyboardHandlers(t, i, n, e);
        }, e.prototype.onTextInput = function(e) {
            return this.$callKeyboardHandlers(-1, e);
        }, e;
    }();
    t.KeyBinding = s;
}), ace.define("ace/lib/bidiutil", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    function F(e, t, n, r) {
        var i = s ? d : p, c = null, h = null, v = null, m = 0, g = null, y = null, b = -1, w = null, E = null, T = [];
        if (!r) for(w = 0, r = []; w < n; w++)r[w] = R(e[w]);
        o = s, u = !1, a = !1, f = !1, l = !1;
        for(E = 0; E < n; E++){
            c = m, T[E] = h = q(e, r, T, E), m = i[c][h], g = m & 240, m &= 15, t[E] = v = i[m][5];
            if (g > 0) {
                if (g == 16) {
                    for(w = b; w < E; w++)t[w] = 1;
                    b = -1;
                } else b = -1;
            }
            y = i[m][6];
            if (y) b == -1 && (b = E);
            else if (b > -1) {
                for(w = b; w < E; w++)t[w] = v;
                b = -1;
            }
            r[E] == S && (t[E] = 0), o |= v;
        }
        if (l) {
            for(w = 0; w < n; w++)if (r[w] == x) {
                t[w] = s;
                for(var C = w - 1; C >= 0; C--){
                    if (r[C] != N) break;
                    t[C] = s;
                }
            }
        }
    }
    function I(e, t, n) {
        if (o < e) return;
        if (e == 1 && s == m && !f) {
            n.reverse();
            return;
        }
        var r = n.length, i = 0, u, a, l, c;
        while(i < r){
            if (t[i] >= e) {
                u = i + 1;
                while(u < r && t[u] >= e)u++;
                for(a = i, l = u - 1; a < l; a++, l--)c = n[a], n[a] = n[l], n[l] = c;
                i = u;
            }
            i++;
        }
    }
    function q(e, t, n, r) {
        var i = t[r], o, c, h, p;
        switch(i){
            case g:
            case y:
                u = !1;
            case E:
            case w:
                return i;
            case b:
                return u ? w : b;
            case T:
                return u = !0, a = !0, y;
            case N:
                return E;
            case C:
                if (r < 1 || r + 1 >= t.length || (o = n[r - 1]) != b && o != w || (c = t[r + 1]) != b && c != w) return E;
                return u && (c = w), c == o ? c : E;
            case k:
                o = r > 0 ? n[r - 1] : S;
                if (o == b && r + 1 < t.length && t[r + 1] == b) return b;
                return E;
            case L:
                if (r > 0 && n[r - 1] == b) return b;
                if (u) return E;
                p = r + 1, h = t.length;
                while(p < h && t[p] == L)p++;
                if (p < h && t[p] == b) return b;
                return E;
            case A:
                h = t.length, p = r + 1;
                while(p < h && t[p] == A)p++;
                if (p < h) {
                    var d = e[r], v = d >= 1425 && d <= 2303 || d == 64286;
                    o = t[p];
                    if (v && (o == y || o == T)) return y;
                }
                if (r < 1 || (o = t[r - 1]) == S) return E;
                return n[r - 1];
            case S:
                return u = !1, f = !0, s;
            case x:
                return l = !0, E;
            case O:
            case M:
            case D:
            case P:
            case _:
                u = !1;
            case H:
                return E;
        }
    }
    function R(e) {
        var t = e.charCodeAt(0), n = t >> 8;
        return n == 0 ? t > 191 ? g : B[t] : n == 5 ? /[\u0591-\u05f4]/.test(e) ? y : g : n == 6 ? /[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(e) ? A : /[\u0660-\u0669\u066b-\u066c]/.test(e) ? w : t == 1642 ? L : /[\u06f0-\u06f9]/.test(e) ? b : T : n == 32 && t <= 8287 ? j[t & 255] : n == 254 ? t >= 65136 ? T : E : E;
    }
    function U(e) {
        return e >= "Ÿã" && e <= "Ÿï";
    }
    var r = [
        "ÿ°",
        "ŸÅ"
    ], i = [
        "ÿ∫",
        "Ÿä"
    ], s = 0, o = 0, u = !1, a = !1, f = !1, l = !1, c = !1, h = !1, p = [
        [
            0,
            3,
            0,
            1,
            0,
            0,
            0
        ],
        [
            0,
            3,
            0,
            1,
            2,
            2,
            0
        ],
        [
            0,
            3,
            0,
            17,
            2,
            0,
            1
        ],
        [
            0,
            3,
            5,
            5,
            4,
            1,
            0
        ],
        [
            0,
            3,
            21,
            21,
            4,
            0,
            1
        ],
        [
            0,
            3,
            5,
            5,
            4,
            2,
            0
        ]
    ], d = [
        [
            2,
            0,
            1,
            1,
            0,
            1,
            0
        ],
        [
            2,
            0,
            1,
            1,
            0,
            2,
            0
        ],
        [
            2,
            0,
            2,
            1,
            3,
            2,
            0
        ],
        [
            2,
            0,
            2,
            33,
            3,
            1,
            1
        ]
    ], v = 0, m = 1, g = 0, y = 1, b = 2, w = 3, E = 4, S = 5, x = 6, T = 7, N = 8, C = 9, k = 10, L = 11, A = 12, O = 13, M = 14, _ = 15, D = 16, P = 17, H = 18, B = [
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        x,
        S,
        x,
        N,
        S,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        S,
        S,
        S,
        x,
        N,
        E,
        E,
        L,
        L,
        L,
        E,
        E,
        E,
        E,
        E,
        k,
        C,
        k,
        C,
        C,
        b,
        b,
        b,
        b,
        b,
        b,
        b,
        b,
        b,
        b,
        C,
        E,
        E,
        E,
        E,
        E,
        E,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        E,
        E,
        E,
        E,
        E,
        E,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        g,
        E,
        E,
        E,
        E,
        H,
        H,
        H,
        H,
        H,
        H,
        S,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        H,
        C,
        E,
        L,
        L,
        L,
        L,
        E,
        E,
        E,
        E,
        g,
        E,
        E,
        H,
        E,
        E,
        L,
        L,
        b,
        b,
        E,
        g,
        E,
        E,
        E,
        b,
        g,
        E,
        E,
        E,
        E,
        E
    ], j = [
        N,
        N,
        N,
        N,
        N,
        N,
        N,
        N,
        N,
        N,
        N,
        H,
        H,
        H,
        g,
        y,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        N,
        S,
        O,
        M,
        _,
        D,
        P,
        C,
        L,
        L,
        L,
        L,
        L,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        C,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        E,
        N
    ];
    t.L = g, t.R = y, t.EN = b, t.ON_R = 3, t.AN = 4, t.R_H = 5, t.B = 6, t.RLE = 7, t.DOT = "\xb7", t.doBidiReorder = function(e, n, r) {
        if (e.length < 2) return {};
        var i = e.split(""), o = new Array(i.length), u = new Array(i.length), a = [];
        s = r ? m : v, F(i, a, i.length, n);
        for(var f = 0; f < o.length; o[f] = f, f++);
        I(2, a, o), I(1, a, o);
        for(var f = 0; f < o.length - 1; f++)n[f] === w ? a[f] = t.AN : a[f] === y && (n[f] > T && n[f] < O || n[f] === E || n[f] === H) ? a[f] = t.ON_R : f > 0 && i[f - 1] === "ŸÑ" && /\u0622|\u0623|\u0625|\u0627/.test(i[f]) && (a[f - 1] = a[f] = t.R_H, f++);
        i[i.length - 1] === t.DOT && (a[i.length - 1] = t.B), i[0] === "‚Ä´" && (a[0] = t.RLE);
        for(var f = 0; f < o.length; f++)u[f] = a[o[f]];
        return {
            logicalFromVisual: o,
            bidiLevels: u
        };
    }, t.hasBidiCharacters = function(e, t) {
        var n = !1;
        for(var r = 0; r < e.length; r++)t[r] = R(e.charAt(r)), !n && (t[r] == y || t[r] == T || t[r] == w) && (n = !0);
        return n;
    }, t.getVisualFromLogicalIdx = function(e, t) {
        for(var n = 0; n < t.logicalFromVisual.length; n++)if (t.logicalFromVisual[n] == e) return n;
        return 0;
    };
}), ace.define("ace/bidihandler", [
    "require",
    "exports",
    "module",
    "ace/lib/bidiutil",
    "ace/lib/lang"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/bidiutil"), i = e("./lib/lang"), s = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/, o = function() {
        function e(e) {
            this.session = e, this.bidiMap = {}, this.currentRow = null, this.bidiUtil = r, this.charWidths = [], this.EOL = "\xac", this.showInvisibles = !0, this.isRtlDir = !1, this.$isRtl = !1, this.line = "", this.wrapIndent = 0, this.EOF = "\xb6", this.RLE = "‚Ä´", this.contentWidth = 0, this.fontMetrics = null, this.rtlLineOffset = 0, this.wrapOffset = 0, this.isMoveLeftOperation = !1, this.seenBidi = s.test(e.getValue());
        }
        return e.prototype.isBidiRow = function(e, t, n) {
            return this.seenBidi ? (e !== this.currentRow && (this.currentRow = e, this.updateRowLine(t, n), this.updateBidiMap()), this.bidiMap.bidiLevels) : !1;
        }, e.prototype.onChange = function(e) {
            this.seenBidi ? this.currentRow = null : e.action == "insert" && s.test(e.lines.join("\n")) && (this.seenBidi = !0, this.currentRow = null);
        }, e.prototype.getDocumentRow = function() {
            var e = 0, t = this.session.$screenRowCache;
            if (t.length) {
                var n = this.session.$getRowCacheIndex(t, this.currentRow);
                n >= 0 && (e = this.session.$docRowCache[n]);
            }
            return e;
        }, e.prototype.getSplitIndex = function() {
            var e = 0, t = this.session.$screenRowCache;
            if (t.length) {
                var n, r = this.session.$getRowCacheIndex(t, this.currentRow);
                while(this.currentRow - e > 0){
                    n = this.session.$getRowCacheIndex(t, this.currentRow - e - 1);
                    if (n !== r) break;
                    r = n, e++;
                }
            } else e = this.currentRow;
            return e;
        }, e.prototype.updateRowLine = function(e, t) {
            e === undefined && (e = this.getDocumentRow());
            var n = e === this.session.getLength() - 1, s = n ? this.EOF : this.EOL;
            this.wrapIndent = 0, this.line = this.session.getLine(e), this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
                var o = this.session.$wrapData[e];
                o && (t === undefined && (t = this.getSplitIndex()), t > 0 && o.length ? (this.wrapIndent = o.indent, this.wrapOffset = this.wrapIndent * this.charWidths[r.L], this.line = t < o.length ? this.line.substring(o[t - 1], o[t]) : this.line.substring(o[o.length - 1])) : this.line = this.line.substring(0, o[t]), t == o.length && (this.line += this.showInvisibles ? s : r.DOT));
            } else this.line += this.showInvisibles ? s : r.DOT;
            var u = this.session, a = 0, f;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(e, t) {
                return e === "	" || u.isFullWidth(e.charCodeAt(0)) ? (f = e === "	" ? u.getScreenTabSize(t + a) : 2, a += f - 1, i.stringRepeat(r.DOT, f)) : e;
            }), this.isRtlDir && (this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == r.DOT ? this.line.substr(0, this.line.length - 1) : this.line, this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width);
        }, e.prototype.updateBidiMap = function() {
            var e = [];
            r.hasBidiCharacters(this.line, e) || this.isRtlDir ? this.bidiMap = r.doBidiReorder(this.line, e, this.isRtlDir) : this.bidiMap = {};
        }, e.prototype.markAsDirty = function() {
            this.currentRow = null;
        }, e.prototype.updateCharacterWidths = function(e) {
            if (this.characterWidth === e.$characterSize.width) return;
            this.fontMetrics = e;
            var t = this.characterWidth = e.$characterSize.width, n = e.$measureCharWidth("◊î");
            this.charWidths[r.L] = this.charWidths[r.EN] = this.charWidths[r.ON_R] = t, this.charWidths[r.R] = this.charWidths[r.AN] = n, this.charWidths[r.R_H] = n * .45, this.charWidths[r.B] = this.charWidths[r.RLE] = 0, this.currentRow = null;
        }, e.prototype.setShowInvisibles = function(e) {
            this.showInvisibles = e, this.currentRow = null;
        }, e.prototype.setEolChar = function(e) {
            this.EOL = e;
        }, e.prototype.setContentWidth = function(e) {
            this.contentWidth = e;
        }, e.prototype.isRtlLine = function(e) {
            return this.$isRtl ? !0 : e != undefined ? this.session.getLine(e).charAt(0) == this.RLE : this.isRtlDir;
        }, e.prototype.setRtlDirection = function(e, t) {
            var n = e.getCursorPosition();
            for(var r = e.selection.getSelectionAnchor().row; r <= n.row; r++)!t && e.session.getLine(r).charAt(0) === e.session.$bidiHandler.RLE ? e.session.doc.removeInLine(r, 0, 1) : t && e.session.getLine(r).charAt(0) !== e.session.$bidiHandler.RLE && e.session.doc.insert({
                column: 0,
                row: r
            }, e.session.$bidiHandler.RLE);
        }, e.prototype.getPosLeft = function(e) {
            e -= this.wrapIndent;
            var t = this.line.charAt(0) === this.RLE ? 1 : 0, n = e > t ? this.session.getOverwrite() ? e : e - 1 : t, i = r.getVisualFromLogicalIdx(n, this.bidiMap), s = this.bidiMap.bidiLevels, o = 0;
            !this.session.getOverwrite() && e <= t && s[i] % 2 !== 0 && i++;
            for(var u = 0; u < i; u++)o += this.charWidths[s[u]];
            return !this.session.getOverwrite() && e > t && s[i] % 2 === 0 && (o += this.charWidths[s[i]]), this.wrapIndent && (o += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset), this.isRtlDir && (o += this.rtlLineOffset), o;
        }, e.prototype.getSelections = function(e, t) {
            var n = this.bidiMap, r = n.bidiLevels, i, s = [], o = 0, u = Math.min(e, t) - this.wrapIndent, a = Math.max(e, t) - this.wrapIndent, f = !1, l = !1, c = 0;
            this.wrapIndent && (o += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset);
            for(var h, p = 0; p < r.length; p++)h = n.logicalFromVisual[p], i = r[p], f = h >= u && h < a, f && !l ? c = o : !f && l && s.push({
                left: c,
                width: o - c
            }), o += this.charWidths[i], l = f;
            f && p === r.length && s.push({
                left: c,
                width: o - c
            });
            if (this.isRtlDir) for(var d = 0; d < s.length; d++)s[d].left += this.rtlLineOffset;
            return s;
        }, e.prototype.offsetToCol = function(e) {
            this.isRtlDir && (e -= this.rtlLineOffset);
            var t = 0, e = Math.max(e, 0), n = 0, r = 0, i = this.bidiMap.bidiLevels, s = this.charWidths[i[r]];
            this.wrapIndent && (e -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset);
            while(e > n + s / 2){
                n += s;
                if (r === i.length - 1) {
                    s = 0;
                    break;
                }
                s = this.charWidths[i[++r]];
            }
            return r > 0 && i[r - 1] % 2 !== 0 && i[r] % 2 === 0 ? (e < n && r--, t = this.bidiMap.logicalFromVisual[r]) : r > 0 && i[r - 1] % 2 === 0 && i[r] % 2 !== 0 ? t = 1 + (e > n ? this.bidiMap.logicalFromVisual[r] : this.bidiMap.logicalFromVisual[r - 1]) : this.isRtlDir && r === i.length - 1 && s === 0 && i[r - 1] % 2 === 0 || !this.isRtlDir && r === 0 && i[r] % 2 !== 0 ? t = 1 + this.bidiMap.logicalFromVisual[r] : (r > 0 && i[r - 1] % 2 !== 0 && s !== 0 && r--, t = this.bidiMap.logicalFromVisual[r]), t === 0 && this.isRtlDir && t++, t + this.wrapIndent;
        }, e;
    }();
    t.BidiHandler = o;
}), ace.define("ace/selection", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/lib/event_emitter",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/oop"), i = e("./lib/lang"), s = e("./lib/event_emitter").EventEmitter, o = e("./range").Range, u = function() {
        function e(e) {
            this.session = e, this.doc = e.getDocument(), this.clearSelection(), this.cursor = this.lead = this.doc.createAnchor(0, 0), this.anchor = this.doc.createAnchor(0, 0), this.$silent = !1;
            var t = this;
            this.cursor.on("change", function(e) {
                t.$cursorChanged = !0, t.$silent || t._emit("changeCursor"), !t.$isEmpty && !t.$silent && t._emit("changeSelection"), !t.$keepDesiredColumnOnChange && e.old.column != e.value.column && (t.$desiredColumn = null);
            }), this.anchor.on("change", function() {
                t.$anchorChanged = !0, !t.$isEmpty && !t.$silent && t._emit("changeSelection");
            });
        }
        return e.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        }, e.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
        }, e.prototype.getCursor = function() {
            return this.lead.getPosition();
        }, e.prototype.setAnchor = function(e, t) {
            this.$isEmpty = !1, this.anchor.setPosition(e, t);
        }, e.prototype.getAnchor = function() {
            return this.$isEmpty ? this.getSelectionLead() : this.anchor.getPosition();
        }, e.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
        }, e.prototype.isBackwards = function() {
            var e = this.anchor, t = this.lead;
            return e.row > t.row || e.row == t.row && e.column > t.column;
        }, e.prototype.getRange = function() {
            var e = this.anchor, t = this.lead;
            return this.$isEmpty ? o.fromPoints(t, t) : this.isBackwards() ? o.fromPoints(t, e) : o.fromPoints(e, t);
        }, e.prototype.clearSelection = function() {
            this.$isEmpty || (this.$isEmpty = !0, this._emit("changeSelection"));
        }, e.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        }, e.prototype.setRange = function(e, t) {
            var n = t ? e.end : e.start, r = t ? e.start : e.end;
            this.$setSelection(n.row, n.column, r.row, r.column);
        }, e.prototype.$setSelection = function(e, t, n, r) {
            if (this.$silent) return;
            var i = this.$isEmpty, s = this.inMultiSelectMode;
            this.$silent = !0, this.$cursorChanged = this.$anchorChanged = !1, this.anchor.setPosition(e, t), this.cursor.setPosition(n, r), this.$isEmpty = !o.comparePoints(this.anchor, this.cursor), this.$silent = !1, this.$cursorChanged && this._emit("changeCursor"), (this.$cursorChanged || this.$anchorChanged || i != this.$isEmpty || s) && this._emit("changeSelection");
        }, e.prototype.$moveSelection = function(e) {
            var t = this.lead;
            this.$isEmpty && this.setSelectionAnchor(t.row, t.column), e.call(this);
        }, e.prototype.selectTo = function(e, t) {
            this.$moveSelection(function() {
                this.moveCursorTo(e, t);
            });
        }, e.prototype.selectToPosition = function(e) {
            this.$moveSelection(function() {
                this.moveCursorToPosition(e);
            });
        }, e.prototype.moveTo = function(e, t) {
            this.clearSelection(), this.moveCursorTo(e, t);
        }, e.prototype.moveToPosition = function(e) {
            this.clearSelection(), this.moveCursorToPosition(e);
        }, e.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
        }, e.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
        }, e.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
        }, e.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
        }, e.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
        }, e.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
        }, e.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
        }, e.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
        }, e.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
        }, e.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
        }, e.prototype.getWordRange = function(e, t) {
            if (typeof t == "undefined") {
                var n = e || this.lead;
                e = n.row, t = n.column;
            }
            return this.session.getWordRange(e, t);
        }, e.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
        }, e.prototype.selectAWord = function() {
            var e = this.getCursor(), t = this.session.getAWordRange(e.row, e.column);
            this.setSelectionRange(t);
        }, e.prototype.getLineRange = function(e, t) {
            var n = typeof e == "number" ? e : this.lead.row, r, i = this.session.getFoldLine(n);
            return i ? (n = i.start.row, r = i.end.row) : r = n, t === !0 ? new o(n, 0, r, this.session.getLine(r).length) : new o(n, 0, r + 1, 0);
        }, e.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
        }, e.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
        }, e.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
        }, e.prototype.wouldMoveIntoSoftTab = function(e, t, n) {
            var r = e.column, i = e.column + t;
            return n < 0 && (r = e.column - t, i = e.column), this.session.isTabStop(e) && this.doc.getLine(e.row).slice(r, i).split(" ").length - 1 == t;
        }, e.prototype.moveCursorLeft = function() {
            var e = this.lead.getPosition(), t;
            if (t = this.session.getFoldAt(e.row, e.column, -1)) this.moveCursorTo(t.start.row, t.start.column);
            else if (e.column === 0) e.row > 0 && this.moveCursorTo(e.row - 1, this.doc.getLine(e.row - 1).length);
            else {
                var n = this.session.getTabSize();
                this.wouldMoveIntoSoftTab(e, n, -1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, -n) : this.moveCursorBy(0, -1);
            }
        }, e.prototype.moveCursorRight = function() {
            var e = this.lead.getPosition(), t;
            if (t = this.session.getFoldAt(e.row, e.column, 1)) this.moveCursorTo(t.end.row, t.end.column);
            else if (this.lead.column == this.doc.getLine(this.lead.row).length) this.lead.row < this.doc.getLength() - 1 && this.moveCursorTo(this.lead.row + 1, 0);
            else {
                var n = this.session.getTabSize(), e = this.lead;
                this.wouldMoveIntoSoftTab(e, n, 1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, n) : this.moveCursorBy(0, 1);
            }
        }, e.prototype.moveCursorLineStart = function() {
            var e = this.lead.row, t = this.lead.column, n = this.session.documentToScreenRow(e, t), r = this.session.screenToDocumentPosition(n, 0), i = this.session.getDisplayLine(e, null, r.row, r.column), s = i.match(/^\s*/);
            s[0].length != t && !this.session.$useEmacsStyleLineStart && (r.column += s[0].length), this.moveCursorToPosition(r);
        }, e.prototype.moveCursorLineEnd = function() {
            var e = this.lead, t = this.session.getDocumentLastRowColumnPosition(e.row, e.column);
            if (this.lead.column == t.column) {
                var n = this.session.getLine(t.row);
                if (t.column == n.length) {
                    var r = n.search(/\s+$/);
                    r > 0 && (t.column = r);
                }
            }
            this.moveCursorTo(t.row, t.column);
        }, e.prototype.moveCursorFileEnd = function() {
            var e = this.doc.getLength() - 1, t = this.doc.getLine(e).length;
            this.moveCursorTo(e, t);
        }, e.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
        }, e.prototype.moveCursorLongWordRight = function() {
            var e = this.lead.row, t = this.lead.column, n = this.doc.getLine(e), r = n.substring(t);
            this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0;
            var i = this.session.getFoldAt(e, t, 1);
            if (i) {
                this.moveCursorTo(i.end.row, i.end.column);
                return;
            }
            this.session.nonTokenRe.exec(r) && (t += this.session.nonTokenRe.lastIndex, this.session.nonTokenRe.lastIndex = 0, r = n.substring(t));
            if (t >= n.length) {
                this.moveCursorTo(e, n.length), this.moveCursorRight(), e < this.doc.getLength() - 1 && this.moveCursorWordRight();
                return;
            }
            this.session.tokenRe.exec(r) && (t += this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(e, t);
        }, e.prototype.moveCursorLongWordLeft = function() {
            var e = this.lead.row, t = this.lead.column, n;
            if (n = this.session.getFoldAt(e, t, -1)) {
                this.moveCursorTo(n.start.row, n.start.column);
                return;
            }
            var r = this.session.getFoldStringAt(e, t, -1);
            r == null && (r = this.doc.getLine(e).substring(0, t));
            var s = i.stringReverse(r);
            this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0, this.session.nonTokenRe.exec(s) && (t -= this.session.nonTokenRe.lastIndex, s = s.slice(this.session.nonTokenRe.lastIndex), this.session.nonTokenRe.lastIndex = 0);
            if (t <= 0) {
                this.moveCursorTo(e, 0), this.moveCursorLeft(), e > 0 && this.moveCursorWordLeft();
                return;
            }
            this.session.tokenRe.exec(s) && (t -= this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(e, t);
        }, e.prototype.$shortWordEndIndex = function(e) {
            var t = 0, n, r = /\s/, i = this.session.tokenRe;
            i.lastIndex = 0;
            if (this.session.tokenRe.exec(e)) t = this.session.tokenRe.lastIndex;
            else {
                while((n = e[t]) && r.test(n))t++;
                if (t < 1) {
                    i.lastIndex = 0;
                    while((n = e[t]) && !i.test(n)){
                        i.lastIndex = 0, t++;
                        if (r.test(n)) {
                            if (t > 2) {
                                t--;
                                break;
                            }
                            while((n = e[t]) && r.test(n))t++;
                            if (t > 2) break;
                        }
                    }
                }
            }
            return i.lastIndex = 0, t;
        }, e.prototype.moveCursorShortWordRight = function() {
            var e = this.lead.row, t = this.lead.column, n = this.doc.getLine(e), r = n.substring(t), i = this.session.getFoldAt(e, t, 1);
            if (i) return this.moveCursorTo(i.end.row, i.end.column);
            if (t == n.length) {
                var s = this.doc.getLength();
                do e++, r = this.doc.getLine(e);
                while (e < s && /^\s*$/.test(r));
                /^\s+/.test(r) || (r = ""), t = 0;
            }
            var o = this.$shortWordEndIndex(r);
            this.moveCursorTo(e, t + o);
        }, e.prototype.moveCursorShortWordLeft = function() {
            var e = this.lead.row, t = this.lead.column, n;
            if (n = this.session.getFoldAt(e, t, -1)) return this.moveCursorTo(n.start.row, n.start.column);
            var r = this.session.getLine(e).substring(0, t);
            if (t === 0) {
                do e--, r = this.doc.getLine(e);
                while (e > 0 && /^\s*$/.test(r));
                t = r.length, /\s+$/.test(r) || (r = "");
            }
            var s = i.stringReverse(r), o = this.$shortWordEndIndex(s);
            return this.moveCursorTo(e, t - o);
        }, e.prototype.moveCursorWordRight = function() {
            this.session.$selectLongWords ? this.moveCursorLongWordRight() : this.moveCursorShortWordRight();
        }, e.prototype.moveCursorWordLeft = function() {
            this.session.$selectLongWords ? this.moveCursorLongWordLeft() : this.moveCursorShortWordLeft();
        }, e.prototype.moveCursorBy = function(e, t) {
            var n = this.session.documentToScreenPosition(this.lead.row, this.lead.column), r;
            t === 0 && (e !== 0 && (this.session.$bidiHandler.isBidiRow(n.row, this.lead.row) ? (r = this.session.$bidiHandler.getPosLeft(n.column), n.column = Math.round(r / this.session.$bidiHandler.charWidths[0])) : r = n.column * this.session.$bidiHandler.charWidths[0]), this.$desiredColumn ? n.column = this.$desiredColumn : this.$desiredColumn = n.column);
            if (e != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
                var i = this.session.lineWidgets[this.lead.row];
                e < 0 ? e -= i.rowsAbove || 0 : e > 0 && (e += i.rowCount - (i.rowsAbove || 0));
            }
            var s = this.session.screenToDocumentPosition(n.row + e, n.column, r);
            e !== 0 && t === 0 && s.row === this.lead.row && (s.column, this.lead.column), this.moveCursorTo(s.row, s.column + t, t === 0);
        }, e.prototype.moveCursorToPosition = function(e) {
            this.moveCursorTo(e.row, e.column);
        }, e.prototype.moveCursorTo = function(e, t, n) {
            var r = this.session.getFoldAt(e, t, 1);
            r && (e = r.start.row, t = r.start.column), this.$keepDesiredColumnOnChange = !0;
            var i = this.session.getLine(e);
            /[\uDC00-\uDFFF]/.test(i.charAt(t)) && i.charAt(t - 1) && (this.lead.row == e && this.lead.column == t + 1 ? t -= 1 : t += 1), this.lead.setPosition(e, t), this.$keepDesiredColumnOnChange = !1, n || (this.$desiredColumn = null);
        }, e.prototype.moveCursorToScreen = function(e, t, n) {
            var r = this.session.screenToDocumentPosition(e, t);
            this.moveCursorTo(r.row, r.column, n);
        }, e.prototype.detach = function() {
            this.lead.detach(), this.anchor.detach();
        }, e.prototype.fromOrientedRange = function(e) {
            this.setSelectionRange(e, e.cursor == e.start), this.$desiredColumn = e.desiredColumn || this.$desiredColumn;
        }, e.prototype.toOrientedRange = function(e) {
            var t = this.getRange();
            return e ? (e.start.column = t.start.column, e.start.row = t.start.row, e.end.column = t.end.column, e.end.row = t.end.row) : e = t, e.cursor = this.isBackwards() ? e.start : e.end, e.desiredColumn = this.$desiredColumn, e;
        }, e.prototype.getRangeOfMovements = function(e) {
            var t = this.getCursor();
            try {
                e(this);
                var n = this.getCursor();
                return o.fromPoints(t, n);
            } catch (r) {
                return o.fromPoints(t, t);
            } finally{
                this.moveCursorToPosition(t);
            }
        }, e.prototype.toJSON = function() {
            if (this.rangeCount) var e = this.ranges.map(function(e) {
                var t = e.clone();
                return t.isBackwards = e.cursor == e.start, t;
            });
            else {
                var e = this.getRange();
                e.isBackwards = this.isBackwards();
            }
            return e;
        }, e.prototype.fromJSON = function(e) {
            if (e.start == undefined) {
                if (this.rangeList && e.length > 1) {
                    this.toSingleRange(e[0]);
                    for(var t = e.length; t--;){
                        var n = o.fromPoints(e[t].start, e[t].end);
                        e[t].isBackwards && (n.cursor = n.start), this.addRange(n, !0);
                    }
                    return;
                }
                e = e[0];
            }
            this.rangeList && this.toSingleRange(e), this.setSelectionRange(e, e.isBackwards);
        }, e.prototype.isEqual = function(e) {
            if ((e.length || this.rangeCount) && e.length != this.rangeCount) return !1;
            if (!e.length || !this.ranges) return this.getRange().isEqual(e);
            for(var t = this.ranges.length; t--;)if (!this.ranges[t].isEqual(e[t])) return !1;
            return !0;
        }, e;
    }();
    u.prototype.setSelectionAnchor = u.prototype.setAnchor, u.prototype.getSelectionAnchor = u.prototype.getAnchor, u.prototype.setSelectionRange = u.prototype.setRange, r.implement(u.prototype, s), t.Selection = u;
}), ace.define("ace/tokenizer", [
    "require",
    "exports",
    "module",
    "ace/lib/report_error"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/report_error").reportError, i = 2e3, s = function() {
        function e(e) {
            this.splitRegex, this.states = e, this.regExps = {}, this.matchMappings = {};
            for(var t in this.states){
                var n = this.states[t], r = [], i = 0, s = this.matchMappings[t] = {
                    defaultToken: "text"
                }, o = "g", u = [];
                for(var a = 0; a < n.length; a++){
                    var f = n[a];
                    f.defaultToken && (s.defaultToken = f.defaultToken), f.caseInsensitive && o.indexOf("i") === -1 && (o += "i"), f.unicode && o.indexOf("u") === -1 && (o += "u");
                    if (f.regex == null) continue;
                    f.regex instanceof RegExp && (f.regex = f.regex.toString().slice(1, -1));
                    var l = f.regex, c = new RegExp("(?:(" + l + ")|(.))").exec("a").length - 2;
                    Array.isArray(f.token) ? f.token.length == 1 || c == 1 ? f.token = f.token[0] : c - 1 != f.token.length ? (this.reportError("number of classes and regexp groups doesn't match", {
                        rule: f,
                        groupCount: c - 1
                    }), f.token = f.token[0]) : (f.tokenArray = f.token, f.token = null, f.onMatch = this.$arrayTokens) : typeof f.token == "function" && !f.onMatch && (c > 1 ? f.onMatch = this.$applyToken : f.onMatch = f.token), c > 1 && (/\\\d/.test(f.regex) ? l = f.regex.replace(/\\([0-9]+)/g, function(e, t) {
                        return "\\" + (parseInt(t, 10) + i + 1);
                    }) : (c = 1, l = this.removeCapturingGroups(f.regex)), !f.splitRegex && typeof f.token != "string" && u.push(f)), s[i] = a, i += c, r.push(l), f.onMatch || (f.onMatch = null);
                }
                r.length || (s[0] = 0, r.push("$")), u.forEach(function(e) {
                    e.splitRegex = this.createSplitterRegexp(e.regex, o);
                }, this), this.regExps[t] = new RegExp("(" + r.join(")|(") + ")|($)", o);
            }
        }
        return e.prototype.$setMaxTokenCount = function(e) {
            i = e | 0;
        }, e.prototype.$applyToken = function(e) {
            var t = this.splitRegex.exec(e).slice(1), n = this.token.apply(this, t);
            if (typeof n == "string") return [
                {
                    type: n,
                    value: e
                }
            ];
            var r = [];
            for(var i = 0, s = n.length; i < s; i++)t[i] && (r[r.length] = {
                type: n[i],
                value: t[i]
            });
            return r;
        }, e.prototype.$arrayTokens = function(e) {
            if (!e) return [];
            var t = this.splitRegex.exec(e);
            if (!t) return "text";
            var n = [], r = this.tokenArray;
            for(var i = 0, s = r.length; i < s; i++)t[i + 1] && (n[n.length] = {
                type: r[i],
                value: t[i + 1]
            });
            return n;
        }, e.prototype.removeCapturingGroups = function(e) {
            var t = e.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(e, t) {
                return t ? "(?:" : e;
            });
            return t;
        }, e.prototype.createSplitterRegexp = function(e, t) {
            if (e.indexOf("(?=") != -1) {
                var n = 0, r = !1, i = {};
                e.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(e, t, s, o, u, a) {
                    return r ? r = u != "]" : u ? r = !0 : o ? (n == i.stack && (i.end = a + 1, i.stack = -1), n--) : s && (n++, s.length != 1 && (i.stack = n, i.start = a)), e;
                }), i.end != null && /^\)*$/.test(e.substr(i.end)) && (e = e.substring(0, i.start) + e.substr(i.end));
            }
            return e.charAt(0) != "^" && (e = "^" + e), e.charAt(e.length - 1) != "$" && (e += "$"), new RegExp(e, (t || "").replace("g", ""));
        }, e.prototype.getLineTokens = function(e, t) {
            if (t && typeof t != "string") {
                var n = t.slice(0);
                t = n[0], t === "#tmp" && (n.shift(), t = n.shift());
            } else var n = [];
            var r = t || "start", s = this.states[r];
            s || (r = "start", s = this.states[r]);
            var o = this.matchMappings[r], u = this.regExps[r];
            u.lastIndex = 0;
            var a, f = [], l = 0, c = 0, h = {
                type: null,
                value: ""
            };
            while(a = u.exec(e)){
                var p = o.defaultToken, d = null, v = a[0], m = u.lastIndex;
                if (m - v.length > l) {
                    var g = e.substring(l, m - v.length);
                    h.type == p ? h.value += g : (h.type && f.push(h), h = {
                        type: p,
                        value: g
                    });
                }
                for(var y = 0; y < a.length - 2; y++){
                    if (a[y + 1] === undefined) continue;
                    d = s[o[y]], d.onMatch ? p = d.onMatch(v, r, n, e) : p = d.token, d.next && (typeof d.next == "string" ? r = d.next : r = d.next(r, n), s = this.states[r], s || (this.reportError("state doesn't exist", r), r = "start", s = this.states[r]), o = this.matchMappings[r], l = m, u = this.regExps[r], u.lastIndex = m), d.consumeLineEnd && (l = m);
                    break;
                }
                if (v) {
                    if (typeof p == "string") !!d && d.merge === !1 || h.type !== p ? (h.type && f.push(h), h = {
                        type: p,
                        value: v
                    }) : h.value += v;
                    else if (p) {
                        h.type && f.push(h), h = {
                            type: null,
                            value: ""
                        };
                        for(var y = 0; y < p.length; y++)f.push(p[y]);
                    }
                }
                if (l == e.length) break;
                l = m;
                if (c++ > i) {
                    c > 2 * e.length && this.reportError("infinite loop with in ace tokenizer", {
                        startState: t,
                        line: e
                    });
                    while(l < e.length)h.type && f.push(h), h = {
                        value: e.substring(l, l += 500),
                        type: "overflow"
                    };
                    r = "start", n = [];
                    break;
                }
            }
            return h.type && f.push(h), n.length > 1 && n[0] !== r && n.unshift("#tmp", r), {
                tokens: f,
                state: n.length ? n : r
            };
        }, e;
    }();
    s.prototype.reportError = r, t.Tokenizer = s;
}), ace.define("ace/mode/text_highlight_rules", [
    "require",
    "exports",
    "module",
    "ace/lib/deep_copy"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/deep_copy").deepCopy, i;
    i = function() {
        this.$rules = {
            start: [
                {
                    token: "empty_line",
                    regex: "^$"
                },
                {
                    defaultToken: "text"
                }
            ]
        };
    }, (function() {
        this.addRules = function(e, t) {
            if (!t) {
                for(var n in e)this.$rules[n] = e[n];
                return;
            }
            for(var n in e){
                var r = e[n];
                for(var i = 0; i < r.length; i++){
                    var s = r[i];
                    if (s.next || s.onMatch) typeof s.next == "string" && s.next.indexOf(t) !== 0 && (s.next = t + s.next), s.nextState && s.nextState.indexOf(t) !== 0 && (s.nextState = t + s.nextState);
                }
                this.$rules[t + n] = r;
            }
        }, this.getRules = function() {
            return this.$rules;
        }, this.embedRules = function(e, t, n, i, s) {
            var o = typeof e == "function" ? (new e).getRules() : e;
            if (i) for(var u = 0; u < i.length; u++)i[u] = t + i[u];
            else {
                i = [];
                for(var a in o)i.push(t + a);
            }
            this.addRules(o, t);
            if (n) {
                var f = Array.prototype[s ? "push" : "unshift"];
                for(var u = 0; u < i.length; u++)f.apply(this.$rules[i[u]], r(n));
            }
            this.$embeds || (this.$embeds = []), this.$embeds.push(t);
        }, this.getEmbeds = function() {
            return this.$embeds;
        };
        var e = function(e, t) {
            return (e != "start" || t.length) && t.unshift(this.nextState, e), this.nextState;
        }, t = function(e, t) {
            return t.shift(), t.shift() || "start";
        };
        this.normalizeRules = function() {
            function i(s) {
                var o = r[s];
                o.processed = !0;
                for(var u = 0; u < o.length; u++){
                    var a = o[u], f = null;
                    Array.isArray(a) && (f = a, a = {}), !a.regex && a.start && (a.regex = a.start, a.next || (a.next = []), a.next.push({
                        defaultToken: a.token
                    }, {
                        token: a.token + ".end",
                        regex: a.end || a.start,
                        next: "pop"
                    }), a.token = a.token + ".start", a.push = !0);
                    var l = a.next || a.push;
                    if (l && Array.isArray(l)) {
                        var c = a.stateName;
                        c || (c = a.token, typeof c != "string" && (c = c[0] || ""), r[c] && (c += n++)), r[c] = l, a.next = c, i(c);
                    } else l == "pop" && (a.next = t);
                    a.push && (a.nextState = a.next || a.push, a.next = e, delete a.push);
                    if (a.rules) for(var h in a.rules)r[h] ? r[h].push && r[h].push.apply(r[h], a.rules[h]) : r[h] = a.rules[h];
                    var p = typeof a == "string" ? a : a.include;
                    p && (p === "$self" && (p = "start"), Array.isArray(p) ? f = p.map(function(e) {
                        return r[e];
                    }) : f = r[p]);
                    if (f) {
                        var d = [
                            u,
                            1
                        ].concat(f);
                        a.noEscape && (d = d.filter(function(e) {
                            return !e.next;
                        })), o.splice.apply(o, d), u--;
                    }
                    a.keywordMap && (a.token = this.createKeywordMapper(a.keywordMap, a.defaultToken || "text", a.caseInsensitive), delete a.defaultToken);
                }
            }
            var n = 0, r = this.$rules;
            Object.keys(r).forEach(i, this);
        }, this.createKeywordMapper = function(e, t, n, r) {
            var i = Object.create(null);
            return this.$keywordList = [], Object.keys(e).forEach(function(t) {
                var s = e[t], o = s.split(r || "|");
                for(var u = o.length; u--;){
                    var a = o[u];
                    this.$keywordList.push(a), n && (a = a.toLowerCase()), i[a] = t;
                }
            }, this), e = null, n ? function(e) {
                return i[e.toLowerCase()] || t;
            } : function(e) {
                return i[e] || t;
            };
        }, this.getKeywords = function() {
            return this.$keywords;
        };
    }).call(i.prototype), t.TextHighlightRules = i;
}), ace.define("ace/mode/behaviour", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    var r;
    r = function() {
        this.$behaviours = {};
    }, (function() {
        this.add = function(e, t, n) {
            switch(undefined){
                case this.$behaviours:
                    this.$behaviours = {};
                case this.$behaviours[e]:
                    this.$behaviours[e] = {};
            }
            this.$behaviours[e][t] = n;
        }, this.addBehaviours = function(e) {
            for(var t in e)for(var n in e[t])this.add(t, n, e[t][n]);
        }, this.remove = function(e) {
            this.$behaviours && this.$behaviours[e] && delete this.$behaviours[e];
        }, this.inherit = function(e, t) {
            if (typeof e == "function") var n = (new e).getBehaviours(t);
            else var n = e.getBehaviours(t);
            this.addBehaviours(n);
        }, this.getBehaviours = function(e) {
            if (!e) return this.$behaviours;
            var t = {};
            for(var n = 0; n < e.length; n++)this.$behaviours[e[n]] && (t[e[n]] = this.$behaviours[e[n]]);
            return t;
        };
    }).call(r.prototype), t.Behaviour = r;
}), ace.define("ace/token_iterator", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("./range").Range, i = function() {
        function e(e, t, n) {
            this.$session = e, this.$row = t, this.$rowTokens = e.getTokens(t);
            var r = e.getTokenAt(t, n);
            this.$tokenIndex = r ? r.index : -1;
        }
        return e.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while(this.$tokenIndex < 0){
                this.$row -= 1;
                if (this.$row < 0) return this.$row = 0, null;
                this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
        }, e.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var e;
            while(this.$tokenIndex >= this.$rowTokens.length){
                this.$row += 1, e || (e = this.$session.getLength());
                if (this.$row >= e) return this.$row = e - 1, null;
                this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
        }, e.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
        }, e.prototype.getCurrentTokenRow = function() {
            return this.$row;
        }, e.prototype.getCurrentTokenColumn = function() {
            var e = this.$rowTokens, t = this.$tokenIndex, n = e[t].start;
            if (n !== undefined) return n;
            n = 0;
            while(t > 0)t -= 1, n += e[t].value.length;
            return n;
        }, e.prototype.getCurrentTokenPosition = function() {
            return {
                row: this.$row,
                column: this.getCurrentTokenColumn()
            };
        }, e.prototype.getCurrentTokenRange = function() {
            var e = this.$rowTokens[this.$tokenIndex], t = this.getCurrentTokenColumn();
            return new r(this.$row, t, this.$row, t + e.value.length);
        }, e;
    }();
    t.TokenIterator = i;
}), ace.define("ace/mode/behaviour/cstyle", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/mode/behaviour",
    "ace/token_iterator",
    "ace/lib/lang"
], function(e, t, n) {
    "use strict";
    var r = e("../../lib/oop"), i = e("../behaviour").Behaviour, s = e("../../token_iterator").TokenIterator, o = e("../../lib/lang"), u = [
        "text",
        "paren.rparen",
        "rparen",
        "paren",
        "punctuation.operator"
    ], a = [
        "text",
        "paren.rparen",
        "rparen",
        "paren",
        "punctuation.operator",
        "comment"
    ], f, l = {}, c = {
        '"': '"',
        "'": "'"
    }, h = function(e) {
        var t = -1;
        e.multiSelect && (t = e.selection.index, l.rangeCount != e.multiSelect.rangeCount && (l = {
            rangeCount: e.multiSelect.rangeCount
        }));
        if (l[t]) return f = l[t];
        f = l[t] = {
            autoInsertedBrackets: 0,
            autoInsertedRow: -1,
            autoInsertedLineEnd: "",
            maybeInsertedBrackets: 0,
            maybeInsertedRow: -1,
            maybeInsertedLineStart: "",
            maybeInsertedLineEnd: ""
        };
    }, p = function(e, t, n, r) {
        var i = e.end.row - e.start.row;
        return {
            text: n + t + r,
            selection: [
                0,
                e.start.column + 1,
                i,
                e.end.column + (i ? 0 : 1)
            ]
        };
    }, d;
    d = function(e) {
        e = e || {}, this.add("braces", "insertion", function(t, n, r, i, s) {
            var u = r.getCursorPosition(), a = i.doc.getLine(u.row);
            if (s == "{") {
                h(r);
                var l = r.getSelectionRange(), c = i.doc.getTextRange(l), v = i.getTokenAt(u.row, u.column);
                if (c !== "" && c !== "{" && r.getWrapBehavioursEnabled()) return p(l, c, "{", "}");
                if (v && /(?:string)\.quasi|\.xml/.test(v.type)) {
                    var m = [
                        /tag\-(?:open|name)/,
                        /attribute\-name/
                    ];
                    if (m.some(function(e) {
                        return e.test(v.type);
                    }) || /(string)\.quasi/.test(v.type) && v.value[u.column - v.start - 1] !== "$") return;
                    return d.recordAutoInsert(r, i, "}"), {
                        text: "{}",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
                if (d.isSaneInsertion(r, i)) return /[\]\}\)]/.test(a[u.column]) || r.inMultiSelectMode || e.braces ? (d.recordAutoInsert(r, i, "}"), {
                    text: "{}",
                    selection: [
                        1,
                        1
                    ]
                }) : (d.recordMaybeInsert(r, i, "{"), {
                    text: "{",
                    selection: [
                        1,
                        1
                    ]
                });
            } else if (s == "}") {
                h(r);
                var g = a.substring(u.column, u.column + 1);
                if (g == "}") {
                    var y = i.$findOpeningBracket("}", {
                        column: u.column + 1,
                        row: u.row
                    });
                    if (y !== null && d.isAutoInsertedClosing(u, a, s)) return d.popAutoInsertedClosing(), {
                        text: "",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            } else {
                if (s == "\n" || s == "\r\n") {
                    h(r);
                    var b = "";
                    d.isMaybeInsertedClosing(u, a) && (b = o.stringRepeat("}", f.maybeInsertedBrackets), d.clearMaybeInsertedClosing());
                    var g = a.substring(u.column, u.column + 1);
                    if (g === "}") {
                        var w = i.findMatchingBracket({
                            row: u.row,
                            column: u.column + 1
                        }, "}");
                        if (!w) return null;
                        var E = this.$getIndent(i.getLine(w.row));
                    } else {
                        if (!b) {
                            d.clearMaybeInsertedClosing();
                            return;
                        }
                        var E = this.$getIndent(a);
                    }
                    var S = E + i.getTabString();
                    return {
                        text: "\n" + S + "\n" + E + b,
                        selection: [
                            1,
                            S.length,
                            1,
                            S.length
                        ]
                    };
                }
                d.clearMaybeInsertedClosing();
            }
        }), this.add("braces", "deletion", function(e, t, n, r, i) {
            var s = r.doc.getTextRange(i);
            if (!i.isMultiLine() && s == "{") {
                h(n);
                var o = r.doc.getLine(i.start.row), u = o.substring(i.end.column, i.end.column + 1);
                if (u == "}") return i.end.column++, i;
                f.maybeInsertedBrackets--;
            }
        }), this.add("parens", "insertion", function(e, t, n, r, i) {
            if (i == "(") {
                h(n);
                var s = n.getSelectionRange(), o = r.doc.getTextRange(s);
                if (o !== "" && n.getWrapBehavioursEnabled()) return p(s, o, "(", ")");
                if (d.isSaneInsertion(n, r)) return d.recordAutoInsert(n, r, ")"), {
                    text: "()",
                    selection: [
                        1,
                        1
                    ]
                };
            } else if (i == ")") {
                h(n);
                var u = n.getCursorPosition(), a = r.doc.getLine(u.row), f = a.substring(u.column, u.column + 1);
                if (f == ")") {
                    var l = r.$findOpeningBracket(")", {
                        column: u.column + 1,
                        row: u.row
                    });
                    if (l !== null && d.isAutoInsertedClosing(u, a, i)) return d.popAutoInsertedClosing(), {
                        text: "",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            }
        }), this.add("parens", "deletion", function(e, t, n, r, i) {
            var s = r.doc.getTextRange(i);
            if (!i.isMultiLine() && s == "(") {
                h(n);
                var o = r.doc.getLine(i.start.row), u = o.substring(i.start.column + 1, i.start.column + 2);
                if (u == ")") return i.end.column++, i;
            }
        }), this.add("brackets", "insertion", function(e, t, n, r, i) {
            if (i == "[") {
                h(n);
                var s = n.getSelectionRange(), o = r.doc.getTextRange(s);
                if (o !== "" && n.getWrapBehavioursEnabled()) return p(s, o, "[", "]");
                if (d.isSaneInsertion(n, r)) return d.recordAutoInsert(n, r, "]"), {
                    text: "[]",
                    selection: [
                        1,
                        1
                    ]
                };
            } else if (i == "]") {
                h(n);
                var u = n.getCursorPosition(), a = r.doc.getLine(u.row), f = a.substring(u.column, u.column + 1);
                if (f == "]") {
                    var l = r.$findOpeningBracket("]", {
                        column: u.column + 1,
                        row: u.row
                    });
                    if (l !== null && d.isAutoInsertedClosing(u, a, i)) return d.popAutoInsertedClosing(), {
                        text: "",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            }
        }), this.add("brackets", "deletion", function(e, t, n, r, i) {
            var s = r.doc.getTextRange(i);
            if (!i.isMultiLine() && s == "[") {
                h(n);
                var o = r.doc.getLine(i.start.row), u = o.substring(i.start.column + 1, i.start.column + 2);
                if (u == "]") return i.end.column++, i;
            }
        }), this.add("string_dquotes", "insertion", function(e, t, n, r, i) {
            var s = r.$mode.$quotes || c;
            if (i.length == 1 && s[i]) {
                if (this.lineCommentStart && this.lineCommentStart.indexOf(i) != -1) return;
                h(n);
                var o = i, u = n.getSelectionRange(), a = r.doc.getTextRange(u);
                if (a !== "" && (a.length != 1 || !s[a]) && n.getWrapBehavioursEnabled()) return p(u, a, o, o);
                if (!a) {
                    var f = n.getCursorPosition(), l = r.doc.getLine(f.row), d = l.substring(f.column - 1, f.column), v = l.substring(f.column, f.column + 1), m = r.getTokenAt(f.row, f.column), g = r.getTokenAt(f.row, f.column + 1);
                    if (d == "\\" && m && /escape/.test(m.type)) return null;
                    var y = m && /string|escape/.test(m.type), b = !g || /string|escape/.test(g.type), w;
                    if (v == o) w = y !== b, w && /string\.end/.test(g.type) && (w = !1);
                    else {
                        if (y && !b) return null;
                        if (y && b) return null;
                        var E = r.$mode.tokenRe;
                        E.lastIndex = 0;
                        var S = E.test(d);
                        E.lastIndex = 0;
                        var x = E.test(v), T = r.$mode.$pairQuotesAfter, N = T && T[o] && T[o].test(d);
                        if (!N && S || x) return null;
                        if (v && !/[\s;,.})\]\\]/.test(v)) return null;
                        var C = l[f.column - 2];
                        if (!(d != o || C != o && !E.test(C))) return null;
                        w = !0;
                    }
                    return {
                        text: w ? o + o : "",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            }
        }), this.add("string_dquotes", "deletion", function(e, t, n, r, i) {
            var s = r.$mode.$quotes || c, o = r.doc.getTextRange(i);
            if (!i.isMultiLine() && s.hasOwnProperty(o)) {
                h(n);
                var u = r.doc.getLine(i.start.row), a = u.substring(i.start.column + 1, i.start.column + 2);
                if (a == o) return i.end.column++, i;
            }
        }), e.closeDocComment !== !1 && this.add("doc comment end", "insertion", function(e, t, n, r, i) {
            if (e === "doc-start" && (i === "\n" || i === "\r\n") && n.selection.isEmpty()) {
                var s = n.getCursorPosition();
                if (s.column === 0) return;
                var o = r.doc.getLine(s.row), u = r.doc.getLine(s.row + 1), a = r.getTokens(s.row), f = 0;
                for(var l = 0; l < a.length; l++){
                    f += a[l].value.length;
                    var c = a[l];
                    if (f >= s.column) {
                        if (f === s.column) {
                            if (!/\.doc/.test(c.type)) return;
                            if (/\*\//.test(c.value)) {
                                var h = a[l + 1];
                                if (!h || !/\.doc/.test(h.type)) return;
                            }
                        }
                        var p = s.column - (f - c.value.length), d = c.value.indexOf("*/"), v = c.value.indexOf("/**", d > -1 ? d + 2 : 0);
                        if (v !== -1 && p > v && p < v + 3) return;
                        if (d !== -1 && v !== -1 && p >= d && p <= v || !/\.doc/.test(c.type)) return;
                        break;
                    }
                }
                var m = this.$getIndent(o);
                if (/\s*\*/.test(u)) return /^\s*\*/.test(o) ? {
                    text: i + m + "* ",
                    selection: [
                        1,
                        2 + m.length,
                        1,
                        2 + m.length
                    ]
                } : {
                    text: i + m + " * ",
                    selection: [
                        1,
                        3 + m.length,
                        1,
                        3 + m.length
                    ]
                };
                if (/\/\*\*/.test(o.substring(0, s.column))) return {
                    text: i + m + " * " + i + " " + m + "*/",
                    selection: [
                        1,
                        4 + m.length,
                        1,
                        4 + m.length
                    ]
                };
            }
        });
    }, d.isSaneInsertion = function(e, t) {
        var n = e.getCursorPosition(), r = new s(t, n.row, n.column);
        if (!this.$matchTokenType(r.getCurrentToken() || "text", u)) {
            if (/[)}\]]/.test(e.session.getLine(n.row)[n.column])) return !0;
            var i = new s(t, n.row, n.column + 1);
            if (!this.$matchTokenType(i.getCurrentToken() || "text", u)) return !1;
        }
        return r.stepForward(), r.getCurrentTokenRow() !== n.row || this.$matchTokenType(r.getCurrentToken() || "text", a);
    }, d.$matchTokenType = function(e, t) {
        return t.indexOf(e.type || e) > -1;
    }, d.recordAutoInsert = function(e, t, n) {
        var r = e.getCursorPosition(), i = t.doc.getLine(r.row);
        this.isAutoInsertedClosing(r, i, f.autoInsertedLineEnd[0]) || (f.autoInsertedBrackets = 0), f.autoInsertedRow = r.row, f.autoInsertedLineEnd = n + i.substr(r.column), f.autoInsertedBrackets++;
    }, d.recordMaybeInsert = function(e, t, n) {
        var r = e.getCursorPosition(), i = t.doc.getLine(r.row);
        this.isMaybeInsertedClosing(r, i) || (f.maybeInsertedBrackets = 0), f.maybeInsertedRow = r.row, f.maybeInsertedLineStart = i.substr(0, r.column) + n, f.maybeInsertedLineEnd = i.substr(r.column), f.maybeInsertedBrackets++;
    }, d.isAutoInsertedClosing = function(e, t, n) {
        return f.autoInsertedBrackets > 0 && e.row === f.autoInsertedRow && n === f.autoInsertedLineEnd[0] && t.substr(e.column) === f.autoInsertedLineEnd;
    }, d.isMaybeInsertedClosing = function(e, t) {
        return f.maybeInsertedBrackets > 0 && e.row === f.maybeInsertedRow && t.substr(e.column) === f.maybeInsertedLineEnd && t.substr(0, e.column) == f.maybeInsertedLineStart;
    }, d.popAutoInsertedClosing = function() {
        f.autoInsertedLineEnd = f.autoInsertedLineEnd.substr(1), f.autoInsertedBrackets--;
    }, d.clearMaybeInsertedClosing = function() {
        f && (f.maybeInsertedBrackets = 0, f.maybeInsertedRow = -1);
    }, r.inherits(d, i), t.CstyleBehaviour = d;
}), ace.define("ace/unicode", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    var r = [
        48,
        9,
        8,
        25,
        5,
        0,
        2,
        25,
        48,
        0,
        11,
        0,
        5,
        0,
        6,
        22,
        2,
        30,
        2,
        457,
        5,
        11,
        15,
        4,
        8,
        0,
        2,
        0,
        18,
        116,
        2,
        1,
        3,
        3,
        9,
        0,
        2,
        2,
        2,
        0,
        2,
        19,
        2,
        82,
        2,
        138,
        2,
        4,
        3,
        155,
        12,
        37,
        3,
        0,
        8,
        38,
        10,
        44,
        2,
        0,
        2,
        1,
        2,
        1,
        2,
        0,
        9,
        26,
        6,
        2,
        30,
        10,
        7,
        61,
        2,
        9,
        5,
        101,
        2,
        7,
        3,
        9,
        2,
        18,
        3,
        0,
        17,
        58,
        3,
        100,
        15,
        53,
        5,
        0,
        6,
        45,
        211,
        57,
        3,
        18,
        2,
        5,
        3,
        11,
        3,
        9,
        2,
        1,
        7,
        6,
        2,
        2,
        2,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        0,
        4,
        3,
        3,
        8,
        3,
        1,
        3,
        3,
        9,
        0,
        5,
        1,
        2,
        4,
        3,
        11,
        16,
        2,
        2,
        5,
        5,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        1,
        2,
        1,
        3,
        0,
        2,
        4,
        5,
        1,
        3,
        2,
        4,
        0,
        8,
        3,
        2,
        0,
        8,
        15,
        12,
        2,
        2,
        8,
        2,
        2,
        2,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        3,
        9,
        2,
        2,
        2,
        2,
        3,
        0,
        16,
        3,
        3,
        9,
        18,
        2,
        2,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        3,
        8,
        3,
        1,
        3,
        2,
        9,
        1,
        5,
        1,
        2,
        4,
        3,
        9,
        2,
        0,
        17,
        1,
        2,
        5,
        4,
        2,
        2,
        3,
        4,
        1,
        2,
        0,
        2,
        1,
        4,
        1,
        4,
        2,
        4,
        11,
        5,
        4,
        4,
        2,
        2,
        3,
        3,
        0,
        7,
        0,
        15,
        9,
        18,
        2,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        9,
        2,
        4,
        4,
        7,
        2,
        2,
        2,
        3,
        8,
        1,
        2,
        1,
        7,
        3,
        3,
        9,
        19,
        1,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        9,
        2,
        4,
        3,
        8,
        2,
        2,
        2,
        3,
        8,
        1,
        8,
        0,
        2,
        3,
        3,
        9,
        19,
        1,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        15,
        4,
        7,
        2,
        2,
        2,
        3,
        10,
        0,
        9,
        3,
        3,
        9,
        11,
        5,
        3,
        1,
        2,
        17,
        4,
        23,
        2,
        8,
        2,
        0,
        3,
        6,
        4,
        0,
        5,
        5,
        2,
        0,
        2,
        7,
        19,
        1,
        14,
        57,
        6,
        14,
        2,
        9,
        40,
        1,
        2,
        0,
        3,
        1,
        2,
        0,
        3,
        0,
        7,
        3,
        2,
        6,
        2,
        2,
        2,
        0,
        2,
        0,
        3,
        1,
        2,
        12,
        2,
        2,
        3,
        4,
        2,
        0,
        2,
        5,
        3,
        9,
        3,
        1,
        35,
        0,
        24,
        1,
        7,
        9,
        12,
        0,
        2,
        0,
        2,
        0,
        5,
        9,
        2,
        35,
        5,
        19,
        2,
        5,
        5,
        7,
        2,
        35,
        10,
        0,
        58,
        73,
        7,
        77,
        3,
        37,
        11,
        42,
        2,
        0,
        4,
        328,
        2,
        3,
        3,
        6,
        2,
        0,
        2,
        3,
        3,
        40,
        2,
        3,
        3,
        32,
        2,
        3,
        3,
        6,
        2,
        0,
        2,
        3,
        3,
        14,
        2,
        56,
        2,
        3,
        3,
        66,
        5,
        0,
        33,
        15,
        17,
        84,
        13,
        619,
        3,
        16,
        2,
        25,
        6,
        74,
        22,
        12,
        2,
        6,
        12,
        20,
        12,
        19,
        13,
        12,
        2,
        2,
        2,
        1,
        13,
        51,
        3,
        29,
        4,
        0,
        5,
        1,
        3,
        9,
        34,
        2,
        3,
        9,
        7,
        87,
        9,
        42,
        6,
        69,
        11,
        28,
        4,
        11,
        5,
        11,
        11,
        39,
        3,
        4,
        12,
        43,
        5,
        25,
        7,
        10,
        38,
        27,
        5,
        62,
        2,
        28,
        3,
        10,
        7,
        9,
        14,
        0,
        89,
        75,
        5,
        9,
        18,
        8,
        13,
        42,
        4,
        11,
        71,
        55,
        9,
        9,
        4,
        48,
        83,
        2,
        2,
        30,
        14,
        230,
        23,
        280,
        3,
        5,
        3,
        37,
        3,
        5,
        3,
        7,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        30,
        3,
        52,
        2,
        6,
        2,
        0,
        4,
        2,
        2,
        6,
        4,
        3,
        3,
        5,
        5,
        12,
        6,
        2,
        2,
        6,
        67,
        1,
        20,
        0,
        29,
        0,
        14,
        0,
        17,
        4,
        60,
        12,
        5,
        0,
        4,
        11,
        18,
        0,
        5,
        0,
        3,
        9,
        2,
        0,
        4,
        4,
        7,
        0,
        2,
        0,
        2,
        0,
        2,
        3,
        2,
        10,
        3,
        3,
        6,
        4,
        5,
        0,
        53,
        1,
        2684,
        46,
        2,
        46,
        2,
        132,
        7,
        6,
        15,
        37,
        11,
        53,
        10,
        0,
        17,
        22,
        10,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        31,
        48,
        0,
        470,
        1,
        36,
        5,
        2,
        4,
        6,
        1,
        5,
        85,
        3,
        1,
        3,
        2,
        2,
        89,
        2,
        3,
        6,
        40,
        4,
        93,
        18,
        23,
        57,
        15,
        513,
        6581,
        75,
        20939,
        53,
        1164,
        68,
        45,
        3,
        268,
        4,
        27,
        21,
        31,
        3,
        13,
        13,
        1,
        2,
        24,
        9,
        69,
        11,
        1,
        38,
        8,
        3,
        102,
        3,
        1,
        111,
        44,
        25,
        51,
        13,
        68,
        12,
        9,
        7,
        23,
        4,
        0,
        5,
        45,
        3,
        35,
        13,
        28,
        4,
        64,
        15,
        10,
        39,
        54,
        10,
        13,
        3,
        9,
        7,
        22,
        4,
        1,
        5,
        66,
        25,
        2,
        227,
        42,
        2,
        1,
        3,
        9,
        7,
        11171,
        13,
        22,
        5,
        48,
        8453,
        301,
        3,
        61,
        3,
        105,
        39,
        6,
        13,
        4,
        6,
        11,
        2,
        12,
        2,
        4,
        2,
        0,
        2,
        1,
        2,
        1,
        2,
        107,
        34,
        362,
        19,
        63,
        3,
        53,
        41,
        11,
        5,
        15,
        17,
        6,
        13,
        1,
        25,
        2,
        33,
        4,
        2,
        134,
        20,
        9,
        8,
        25,
        5,
        0,
        2,
        25,
        12,
        88,
        4,
        5,
        3,
        5,
        3,
        5,
        3,
        2
    ], i = 0, s = [];
    for(var o = 0; o < r.length; o += 2)s.push(i += r[o]), r[o + 1] && s.push(45, i += r[o + 1]);
    t.wordChars = String.fromCharCode.apply(null, s);
}), ace.define("ace/mode/text", [
    "require",
    "exports",
    "module",
    "ace/config",
    "ace/tokenizer",
    "ace/mode/text_highlight_rules",
    "ace/mode/behaviour/cstyle",
    "ace/unicode",
    "ace/lib/lang",
    "ace/token_iterator",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("../config"), i = e("../tokenizer").Tokenizer, s = e("./text_highlight_rules").TextHighlightRules, o = e("./behaviour/cstyle").CstyleBehaviour, u = e("../unicode"), a = e("../lib/lang"), f = e("../token_iterator").TokenIterator, l = e("../range").Range, c;
    c = function() {
        this.HighlightRules = s;
    }, (function() {
        this.$defaultBehaviour = new o, this.tokenRe = new RegExp("^[" + u.wordChars + "\\$_]+", "g"), this.nonTokenRe = new RegExp("^(?:[^" + u.wordChars + "\\$_]|\\s])+", "g"), this.getTokenizer = function() {
            return this.$tokenizer || (this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig), this.$tokenizer = new i(this.$highlightRules.getRules())), this.$tokenizer;
        }, this.lineCommentStart = "", this.blockComment = "", this.toggleCommentLines = function(e, t, n, r) {
            function w(e) {
                for(var t = n; t <= r; t++)e(i.getLine(t), t);
            }
            var i = t.doc, s = !0, o = !0, u = Infinity, f = t.getTabSize(), l = !1;
            if (!this.lineCommentStart) {
                if (!this.blockComment) return !1;
                var c = this.blockComment.start, h = this.blockComment.end, p = new RegExp("^(\\s*)(?:" + a.escapeRegExp(c) + ")"), d = new RegExp("(?:" + a.escapeRegExp(h) + ")\\s*$"), v = function(e, t) {
                    if (g(e, t)) return;
                    if (!s || /\S/.test(e)) i.insertInLine({
                        row: t,
                        column: e.length
                    }, h), i.insertInLine({
                        row: t,
                        column: u
                    }, c);
                }, m = function(e, t) {
                    var n;
                    (n = e.match(d)) && i.removeInLine(t, e.length - n[0].length, e.length), (n = e.match(p)) && i.removeInLine(t, n[1].length, n[0].length);
                }, g = function(e, n) {
                    if (p.test(e)) return !0;
                    var r = t.getTokens(n);
                    for(var i = 0; i < r.length; i++)if (r[i].type === "comment") return !0;
                };
            } else {
                if (Array.isArray(this.lineCommentStart)) var p = this.lineCommentStart.map(a.escapeRegExp).join("|"), c = this.lineCommentStart[0];
                else var p = a.escapeRegExp(this.lineCommentStart), c = this.lineCommentStart;
                p = new RegExp("^(\\s*)(?:" + p + ") ?"), l = t.getUseSoftTabs();
                var m = function(e, t) {
                    var n = e.match(p);
                    if (!n) return;
                    var r = n[1].length, s = n[0].length;
                    !b(e, r, s) && n[0][s - 1] == " " && s--, i.removeInLine(t, r, s);
                }, y = c + " ", v = function(e, t) {
                    if (!s || /\S/.test(e)) b(e, u, u) ? i.insertInLine({
                        row: t,
                        column: u
                    }, y) : i.insertInLine({
                        row: t,
                        column: u
                    }, c);
                }, g = function(e, t) {
                    return p.test(e);
                }, b = function(e, t, n) {
                    var r = 0;
                    while(t-- && e.charAt(t) == " ")r++;
                    if (r % f != 0) return !1;
                    var r = 0;
                    while(e.charAt(n++) == " ")r++;
                    return f > 2 ? r % f != f - 1 : r % f == 0;
                };
            }
            var E = Infinity;
            w(function(e, t) {
                var n = e.search(/\S/);
                n !== -1 ? (n < u && (u = n), o && !g(e, t) && (o = !1)) : E > e.length && (E = e.length);
            }), u == Infinity && (u = E, s = !1, o = !1), l && u % f != 0 && (u = Math.floor(u / f) * f), w(o ? m : v);
        }, this.toggleBlockComment = function(e, t, n, r) {
            var i = this.blockComment;
            if (!i) return;
            !i.start && i[0] && (i = i[0]);
            var s = new f(t, r.row, r.column), o = s.getCurrentToken(), u = t.selection, a = t.selection.toOrientedRange(), c, h;
            if (o && /comment/.test(o.type)) {
                var p, d;
                while(o && /comment/.test(o.type)){
                    var v = o.value.indexOf(i.start);
                    if (v != -1) {
                        var m = s.getCurrentTokenRow(), g = s.getCurrentTokenColumn() + v;
                        p = new l(m, g, m, g + i.start.length);
                        break;
                    }
                    o = s.stepBackward();
                }
                var s = new f(t, r.row, r.column), o = s.getCurrentToken();
                while(o && /comment/.test(o.type)){
                    var v = o.value.indexOf(i.end);
                    if (v != -1) {
                        var m = s.getCurrentTokenRow(), g = s.getCurrentTokenColumn() + v;
                        d = new l(m, g, m, g + i.end.length);
                        break;
                    }
                    o = s.stepForward();
                }
                d && t.remove(d), p && (t.remove(p), c = p.start.row, h = -i.start.length);
            } else h = i.start.length, c = n.start.row, t.insert(n.end, i.end), t.insert(n.start, i.start);
            a.start.row == c && (a.start.column += h), a.end.row == c && (a.end.column += h), t.selection.fromOrientedRange(a);
        }, this.getNextLineIndent = function(e, t, n) {
            return this.$getIndent(t);
        }, this.checkOutdent = function(e, t, n) {
            return !1;
        }, this.autoOutdent = function(e, t, n) {}, this.$getIndent = function(e) {
            return e.match(/^\s*/)[0];
        }, this.createWorker = function(e) {
            return null;
        }, this.createModeDelegates = function(e) {
            this.$embeds = [], this.$modes = {};
            for(var t in e)if (e[t]) {
                var n = e[t], i = n.prototype.$id, s = r.$modes[i];
                s || (r.$modes[i] = s = new n), r.$modes[t] || (r.$modes[t] = s), this.$embeds.push(t), this.$modes[t] = s;
            }
            var o = [
                "toggleBlockComment",
                "toggleCommentLines",
                "getNextLineIndent",
                "checkOutdent",
                "autoOutdent",
                "transformAction",
                "getCompletions"
            ], u = function(e) {
                (function(t) {
                    var n = o[e], r = t[n];
                    t[o[e]] = function() {
                        return this.$delegator(n, arguments, r);
                    };
                })(a);
            }, a = this;
            for(var t = 0; t < o.length; t++)u(t);
        }, this.$delegator = function(e, t, n) {
            var r = t[0] || "start";
            if (typeof r != "string") {
                if (Array.isArray(r[2])) {
                    var i = r[2][r[2].length - 1], s = this.$modes[i];
                    if (s) return s[e].apply(s, [
                        r[1]
                    ].concat([].slice.call(t, 1)));
                }
                r = r[0] || "start";
            }
            for(var o = 0; o < this.$embeds.length; o++){
                if (!this.$modes[this.$embeds[o]]) continue;
                var u = r.split(this.$embeds[o]);
                if (!u[0] && u[1]) {
                    t[0] = u[1];
                    var s = this.$modes[this.$embeds[o]];
                    return s[e].apply(s, t);
                }
            }
            var a = n.apply(this, t);
            return n ? a : undefined;
        }, this.transformAction = function(e, t, n, r, i) {
            if (this.$behaviour) {
                var s = this.$behaviour.getBehaviours();
                for(var o in s)if (s[o][t]) {
                    var u = s[o][t].apply(this, arguments);
                    if (u) return u;
                }
            }
        }, this.getKeywords = function(e) {
            if (!this.completionKeywords) {
                var t = this.$tokenizer.rules, n = [];
                for(var r in t){
                    var i = t[r];
                    for(var s = 0, o = i.length; s < o; s++)if (typeof i[s].token == "string") /keyword|support|storage/.test(i[s].token) && n.push(i[s].regex);
                    else if (typeof i[s].token == "object") {
                        for(var u = 0, a = i[s].token.length; u < a; u++)if (/keyword|support|storage/.test(i[s].token[u])) {
                            var r = i[s].regex.match(/\(.+?\)/g)[u];
                            n.push(r.substr(1, r.length - 2));
                        }
                    }
                }
                this.completionKeywords = n;
            }
            return e ? n.concat(this.$keywordList || []) : this.$keywordList;
        }, this.$createKeywordList = function() {
            return this.$highlightRules || this.getTokenizer(), this.$keywordList = this.$highlightRules.$keywordList || [];
        }, this.getCompletions = function(e, t, n, r) {
            var i = this.$keywordList || this.$createKeywordList();
            return i.map(function(e) {
                return {
                    name: e,
                    value: e,
                    score: 0,
                    meta: "keyword"
                };
            });
        }, this.$id = "ace/mode/text";
    }).call(c.prototype), t.Mode = c;
}), ace.define("ace/line_widgets", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/dom"), i = function() {
        function e(e) {
            this.session = e, this.session.widgetManager = this, this.session.getRowLength = this.getRowLength, this.session.$getWidgetScreenLength = this.$getWidgetScreenLength, this.updateOnChange = this.updateOnChange.bind(this), this.renderWidgets = this.renderWidgets.bind(this), this.measureWidgets = this.measureWidgets.bind(this), this.session._changedWidgets = [], this.$onChangeEditor = this.$onChangeEditor.bind(this), this.session.on("change", this.updateOnChange), this.session.on("changeFold", this.updateOnFold), this.session.on("changeEditor", this.$onChangeEditor);
        }
        return e.prototype.getRowLength = function(e) {
            var t;
            return this.lineWidgets ? t = this.lineWidgets[e] && this.lineWidgets[e].rowCount || 0 : t = 0, !this.$useWrapMode || !this.$wrapData[e] ? 1 + t : this.$wrapData[e].length + 1 + t;
        }, e.prototype.$getWidgetScreenLength = function() {
            var e = 0;
            return this.lineWidgets.forEach(function(t) {
                t && t.rowCount && !t.hidden && (e += t.rowCount);
            }), e;
        }, e.prototype.$onChangeEditor = function(e) {
            this.attach(e.editor);
        }, e.prototype.attach = function(e) {
            e && e.widgetManager && e.widgetManager != this && e.widgetManager.detach();
            if (this.editor == e) return;
            this.detach(), this.editor = e, e && (e.widgetManager = this, e.renderer.on("beforeRender", this.measureWidgets), e.renderer.on("afterRender", this.renderWidgets));
        }, e.prototype.detach = function(e) {
            var t = this.editor;
            if (!t) return;
            this.editor = null, t.widgetManager = null, t.renderer.off("beforeRender", this.measureWidgets), t.renderer.off("afterRender", this.renderWidgets);
            var n = this.session.lineWidgets;
            n && n.forEach(function(e) {
                e && e.el && e.el.parentNode && (e._inDocument = !1, e.el.parentNode.removeChild(e.el));
            });
        }, e.prototype.updateOnFold = function(e, t) {
            var n = t.lineWidgets;
            if (!n || !e.action) return;
            var r = e.data, i = r.start.row, s = r.end.row, o = e.action == "add";
            for(var u = i + 1; u < s; u++)n[u] && (n[u].hidden = o);
            n[s] && (o ? n[i] ? n[s].hidden = o : n[i] = n[s] : (n[i] == n[s] && (n[i] = undefined), n[s].hidden = o));
        }, e.prototype.updateOnChange = function(e) {
            var t = this.session.lineWidgets;
            if (!t) return;
            var n = e.start.row, r = e.end.row - n;
            if (r !== 0) {
                if (e.action == "remove") {
                    var i = t.splice(n + 1, r);
                    !t[n] && i[i.length - 1] && (t[n] = i.pop()), i.forEach(function(e) {
                        e && this.removeLineWidget(e);
                    }, this), this.$updateRows();
                } else {
                    var s = new Array(r);
                    t[n] && t[n].column != null && e.start.column > t[n].column && n++, s.unshift(n, 0), t.splice.apply(t, s), this.$updateRows();
                }
            }
        }, e.prototype.$updateRows = function() {
            var e = this.session.lineWidgets;
            if (!e) return;
            var t = !0;
            e.forEach(function(e, n) {
                if (e) {
                    t = !1, e.row = n;
                    while(e.$oldWidget)e.$oldWidget.row = n, e = e.$oldWidget;
                }
            }), t && (this.session.lineWidgets = null);
        }, e.prototype.$registerLineWidget = function(e) {
            this.session.lineWidgets || (this.session.lineWidgets = new Array(this.session.getLength()));
            var t = this.session.lineWidgets[e.row];
            return t && (e.$oldWidget = t, t.el && t.el.parentNode && (t.el.parentNode.removeChild(t.el), t._inDocument = !1)), this.session.lineWidgets[e.row] = e, e;
        }, e.prototype.addLineWidget = function(e) {
            this.$registerLineWidget(e), e.session = this.session;
            if (!this.editor) return e;
            var t = this.editor.renderer;
            e.html && !e.el && (e.el = r.createElement("div"), e.el.innerHTML = e.html), e.text && !e.el && (e.el = r.createElement("div"), e.el.textContent = e.text), e.el && (r.addCssClass(e.el, "ace_lineWidgetContainer"), e.className && r.addCssClass(e.el, e.className), e.el.style.position = "absolute", e.el.style.zIndex = "5", t.container.appendChild(e.el), e._inDocument = !0, e.coverGutter || (e.el.style.zIndex = "3"), e.pixelHeight == null && (e.pixelHeight = e.el.offsetHeight)), e.rowCount == null && (e.rowCount = e.pixelHeight / t.layerConfig.lineHeight);
            var n = this.session.getFoldAt(e.row, 0);
            e.$fold = n;
            if (n) {
                var i = this.session.lineWidgets;
                e.row == n.end.row && !i[n.start.row] ? i[n.start.row] = e : e.hidden = !0;
            }
            return this.session._emit("changeFold", {
                data: {
                    start: {
                        row: e.row
                    }
                }
            }), this.$updateRows(), this.renderWidgets(null, t), this.onWidgetChanged(e), e;
        }, e.prototype.removeLineWidget = function(e) {
            e._inDocument = !1, e.session = null, e.el && e.el.parentNode && e.el.parentNode.removeChild(e.el);
            if (e.editor && e.editor.destroy) try {
                e.editor.destroy();
            } catch (t) {}
            if (this.session.lineWidgets) {
                var n = this.session.lineWidgets[e.row];
                if (n == e) this.session.lineWidgets[e.row] = e.$oldWidget, e.$oldWidget && this.onWidgetChanged(e.$oldWidget);
                else while(n){
                    if (n.$oldWidget == e) {
                        n.$oldWidget = e.$oldWidget;
                        break;
                    }
                    n = n.$oldWidget;
                }
            }
            this.session._emit("changeFold", {
                data: {
                    start: {
                        row: e.row
                    }
                }
            }), this.$updateRows();
        }, e.prototype.getWidgetsAtRow = function(e) {
            var t = this.session.lineWidgets, n = t && t[e], r = [];
            while(n)r.push(n), n = n.$oldWidget;
            return r;
        }, e.prototype.onWidgetChanged = function(e) {
            this.session._changedWidgets.push(e), this.editor && this.editor.renderer.updateFull();
        }, e.prototype.measureWidgets = function(e, t) {
            var n = this.session._changedWidgets, r = t.layerConfig;
            if (!n || !n.length) return;
            var i = Infinity;
            for(var s = 0; s < n.length; s++){
                var o = n[s];
                if (!o || !o.el) continue;
                if (o.session != this.session) continue;
                if (!o._inDocument) {
                    if (this.session.lineWidgets[o.row] != o) continue;
                    o._inDocument = !0, t.container.appendChild(o.el);
                }
                o.h = o.el.offsetHeight, o.fixedWidth || (o.w = o.el.offsetWidth, o.screenWidth = Math.ceil(o.w / r.characterWidth));
                var u = o.h / r.lineHeight;
                o.coverLine && (u -= this.session.getRowLineCount(o.row), u < 0 && (u = 0)), o.rowCount != u && (o.rowCount = u, o.row < i && (i = o.row));
            }
            i != Infinity && (this.session._emit("changeFold", {
                data: {
                    start: {
                        row: i
                    }
                }
            }), this.session.lineWidgetWidth = null), this.session._changedWidgets = [];
        }, e.prototype.renderWidgets = function(e, t) {
            var n = t.layerConfig, r = this.session.lineWidgets;
            if (!r) return;
            var i = Math.min(this.firstRow, n.firstRow), s = Math.max(this.lastRow, n.lastRow, r.length);
            while(i > 0 && !r[i])i--;
            this.firstRow = n.firstRow, this.lastRow = n.lastRow, t.$cursorLayer.config = n;
            for(var o = i; o <= s; o++){
                var u = r[o];
                if (!u || !u.el) continue;
                if (u.hidden) {
                    u.el.style.top = -100 - (u.pixelHeight || 0) + "px";
                    continue;
                }
                u._inDocument || (u._inDocument = !0, t.container.appendChild(u.el));
                var a = t.$cursorLayer.getPixelPosition({
                    row: o,
                    column: 0
                }, !0).top;
                u.coverLine || (a += n.lineHeight * this.session.getRowLineCount(u.row)), u.el.style.top = a - n.offset + "px";
                var f = u.coverGutter ? 0 : t.gutterWidth;
                u.fixedWidth || (f -= t.scrollLeft), u.el.style.left = f + "px", u.fullWidth && u.screenWidth && (u.el.style.minWidth = n.width + 2 * n.padding + "px"), u.fixedWidth ? u.el.style.right = t.scrollBar.getWidth() + "px" : u.el.style.right = "";
            }
        }, e;
    }();
    t.LineWidgets = i;
}), ace.define("ace/apply_delta", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    "use strict";
    function r(e, t) {
        throw console.log("Invalid Delta:", e), "Invalid Delta: " + t;
    }
    function i(e, t) {
        return t.row >= 0 && t.row < e.length && t.column >= 0 && t.column <= e[t.row].length;
    }
    function s(e, t) {
        t.action != "insert" && t.action != "remove" && r(t, "delta.action must be 'insert' or 'remove'"), t.lines instanceof Array || r(t, "delta.lines must be an Array"), (!t.start || !t.end) && r(t, "delta.start/end must be an present");
        var n = t.start;
        i(e, t.start) || r(t, "delta.start must be contained in document");
        var s = t.end;
        t.action == "remove" && !i(e, s) && r(t, "delta.end must contained in document for 'remove' actions");
        var o = s.row - n.row, u = s.column - (o == 0 ? n.column : 0);
        (o != t.lines.length - 1 || t.lines[o].length != u) && r(t, "delta.range must match delta lines");
    }
    t.applyDelta = function(e, t, n) {
        var r = t.start.row, i = t.start.column, s = e[r] || "";
        switch(t.action){
            case "insert":
                var o = t.lines;
                if (o.length === 1) e[r] = s.substring(0, i) + t.lines[0] + s.substring(i);
                else {
                    var u = [
                        r,
                        1
                    ].concat(t.lines);
                    e.splice.apply(e, u), e[r] = s.substring(0, i) + e[r], e[r + t.lines.length - 1] += s.substring(i);
                }
                break;
            case "remove":
                var a = t.end.column, f = t.end.row;
                r === f ? e[r] = s.substring(0, i) + s.substring(a) : e.splice(r, f - r + 1, s.substring(0, i) + e[f].substring(a));
        }
    };
}), ace.define("ace/anchor", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    function o(e, t, n) {
        var r = n ? e.column <= t.column : e.column < t.column;
        return e.row < t.row || e.row == t.row && r;
    }
    function u(e, t, n) {
        var r = e.action == "insert", i = (r ? 1 : -1) * (e.end.row - e.start.row), s = (r ? 1 : -1) * (e.end.column - e.start.column), u = e.start, a = r ? u : e.end;
        return o(t, u, n) ? {
            row: t.row,
            column: t.column
        } : o(a, t, !n) ? {
            row: t.row + i,
            column: t.column + (t.row == a.row ? s : 0)
        } : {
            row: u.row,
            column: u.column
        };
    }
    var r = e("./lib/oop"), i = e("./lib/event_emitter").EventEmitter, s = function() {
        function e(e, t, n) {
            this.$onChange = this.onChange.bind(this), this.attach(e), typeof t != "number" ? this.setPosition(t.row, t.column) : this.setPosition(t, n);
        }
        return e.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
        }, e.prototype.getDocument = function() {
            return this.document;
        }, e.prototype.onChange = function(e) {
            if (e.start.row == e.end.row && e.start.row != this.row) return;
            if (e.start.row > this.row) return;
            var t = u(e, {
                row: this.row,
                column: this.column
            }, this.$insertRight);
            this.setPosition(t.row, t.column, !0);
        }, e.prototype.setPosition = function(e, t, n) {
            var r;
            n ? r = {
                row: e,
                column: t
            } : r = this.$clipPositionToDocument(e, t);
            if (this.row == r.row && this.column == r.column) return;
            var i = {
                row: this.row,
                column: this.column
            };
            this.row = r.row, this.column = r.column, this._signal("change", {
                old: i,
                value: r
            });
        }, e.prototype.detach = function() {
            this.document.off("change", this.$onChange);
        }, e.prototype.attach = function(e) {
            this.document = e || this.document, this.document.on("change", this.$onChange);
        }, e.prototype.$clipPositionToDocument = function(e, t) {
            var n = {};
            return e >= this.document.getLength() ? (n.row = Math.max(0, this.document.getLength() - 1), n.column = this.document.getLine(n.row).length) : e < 0 ? (n.row = 0, n.column = 0) : (n.row = e, n.column = Math.min(this.document.getLine(n.row).length, Math.max(0, t))), t < 0 && (n.column = 0), n;
        }, e;
    }();
    s.prototype.$insertRight = !1, r.implement(s.prototype, i), t.Anchor = s;
}), ace.define("ace/document", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/apply_delta",
    "ace/lib/event_emitter",
    "ace/range",
    "ace/anchor"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/oop"), i = e("./apply_delta").applyDelta, s = e("./lib/event_emitter").EventEmitter, o = e("./range").Range, u = e("./anchor").Anchor, a = function() {
        function e(e) {
            this.$lines = [
                ""
            ], e.length === 0 ? this.$lines = [
                ""
            ] : Array.isArray(e) ? this.insertMergedLines({
                row: 0,
                column: 0
            }, e) : this.insert({
                row: 0,
                column: 0
            }, e);
        }
        return e.prototype.setValue = function(e) {
            var t = this.getLength() - 1;
            this.remove(new o(0, 0, t, this.getLine(t).length)), this.insert({
                row: 0,
                column: 0
            }, e || "");
        }, e.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
        }, e.prototype.createAnchor = function(e, t) {
            return new u(this, e, t);
        }, e.prototype.$detectNewLine = function(e) {
            var t = e.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = t ? t[1] : "\n", this._signal("changeNewLineMode");
        }, e.prototype.getNewLineCharacter = function() {
            switch(this.$newLineMode){
                case "windows":
                    return "\r\n";
                case "unix":
                    return "\n";
                default:
                    return this.$autoNewLine || "\n";
            }
        }, e.prototype.setNewLineMode = function(e) {
            if (this.$newLineMode === e) return;
            this.$newLineMode = e, this._signal("changeNewLineMode");
        }, e.prototype.getNewLineMode = function() {
            return this.$newLineMode;
        }, e.prototype.isNewLine = function(e) {
            return e == "\r\n" || e == "\r" || e == "\n";
        }, e.prototype.getLine = function(e) {
            return this.$lines[e] || "";
        }, e.prototype.getLines = function(e, t) {
            return this.$lines.slice(e, t + 1);
        }, e.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
        }, e.prototype.getLength = function() {
            return this.$lines.length;
        }, e.prototype.getTextRange = function(e) {
            return this.getLinesForRange(e).join(this.getNewLineCharacter());
        }, e.prototype.getLinesForRange = function(e) {
            var t;
            if (e.start.row === e.end.row) t = [
                this.getLine(e.start.row).substring(e.start.column, e.end.column)
            ];
            else {
                t = this.getLines(e.start.row, e.end.row), t[0] = (t[0] || "").substring(e.start.column);
                var n = t.length - 1;
                e.end.row - e.start.row == n && (t[n] = t[n].substring(0, e.end.column));
            }
            return t;
        }, e.prototype.insertLines = function(e, t) {
            return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."), this.insertFullLines(e, t);
        }, e.prototype.removeLines = function(e, t) {
            return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."), this.removeFullLines(e, t);
        }, e.prototype.insertNewLine = function(e) {
            return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."), this.insertMergedLines(e, [
                "",
                ""
            ]);
        }, e.prototype.insert = function(e, t) {
            return this.getLength() <= 1 && this.$detectNewLine(t), this.insertMergedLines(e, this.$split(t));
        }, e.prototype.insertInLine = function(e, t) {
            var n = this.clippedPos(e.row, e.column), r = this.pos(e.row, e.column + t.length);
            return this.applyDelta({
                start: n,
                end: r,
                action: "insert",
                lines: [
                    t
                ]
            }, !0), this.clonePos(r);
        }, e.prototype.clippedPos = function(e, t) {
            var n = this.getLength();
            e === undefined ? e = n : e < 0 ? e = 0 : e >= n && (e = n - 1, t = undefined);
            var r = this.getLine(e);
            return t == undefined && (t = r.length), t = Math.min(Math.max(t, 0), r.length), {
                row: e,
                column: t
            };
        }, e.prototype.clonePos = function(e) {
            return {
                row: e.row,
                column: e.column
            };
        }, e.prototype.pos = function(e, t) {
            return {
                row: e,
                column: t
            };
        }, e.prototype.$clipPosition = function(e) {
            var t = this.getLength();
            return e.row >= t ? (e.row = Math.max(0, t - 1), e.column = this.getLine(t - 1).length) : (e.row = Math.max(0, e.row), e.column = Math.min(Math.max(e.column, 0), this.getLine(e.row).length)), e;
        }, e.prototype.insertFullLines = function(e, t) {
            e = Math.min(Math.max(e, 0), this.getLength());
            var n = 0;
            e < this.getLength() ? (t = t.concat([
                ""
            ]), n = 0) : (t = [
                ""
            ].concat(t), e--, n = this.$lines[e].length), this.insertMergedLines({
                row: e,
                column: n
            }, t);
        }, e.prototype.insertMergedLines = function(e, t) {
            var n = this.clippedPos(e.row, e.column), r = {
                row: n.row + t.length - 1,
                column: (t.length == 1 ? n.column : 0) + t[t.length - 1].length
            };
            return this.applyDelta({
                start: n,
                end: r,
                action: "insert",
                lines: t
            }), this.clonePos(r);
        }, e.prototype.remove = function(e) {
            var t = this.clippedPos(e.start.row, e.start.column), n = this.clippedPos(e.end.row, e.end.column);
            return this.applyDelta({
                start: t,
                end: n,
                action: "remove",
                lines: this.getLinesForRange({
                    start: t,
                    end: n
                })
            }), this.clonePos(t);
        }, e.prototype.removeInLine = function(e, t, n) {
            var r = this.clippedPos(e, t), i = this.clippedPos(e, n);
            return this.applyDelta({
                start: r,
                end: i,
                action: "remove",
                lines: this.getLinesForRange({
                    start: r,
                    end: i
                })
            }, !0), this.clonePos(r);
        }, e.prototype.removeFullLines = function(e, t) {
            e = Math.min(Math.max(0, e), this.getLength() - 1), t = Math.min(Math.max(0, t), this.getLength() - 1);
            var n = t == this.getLength() - 1 && e > 0, r = t < this.getLength() - 1, i = n ? e - 1 : e, s = n ? this.getLine(i).length : 0, u = r ? t + 1 : t, a = r ? 0 : this.getLine(u).length, f = new o(i, s, u, a), l = this.$lines.slice(e, t + 1);
            return this.applyDelta({
                start: f.start,
                end: f.end,
                action: "remove",
                lines: this.getLinesForRange(f)
            }), l;
        }, e.prototype.removeNewLine = function(e) {
            e < this.getLength() - 1 && e >= 0 && this.applyDelta({
                start: this.pos(e, this.getLine(e).length),
                end: this.pos(e + 1, 0),
                action: "remove",
                lines: [
                    "",
                    ""
                ]
            });
        }, e.prototype.replace = function(e, t) {
            e instanceof o || (e = o.fromPoints(e.start, e.end));
            if (t.length === 0 && e.isEmpty()) return e.start;
            if (t == this.getTextRange(e)) return e.end;
            this.remove(e);
            var n;
            return t ? n = this.insert(e.start, t) : n = e.start, n;
        }, e.prototype.applyDeltas = function(e) {
            for(var t = 0; t < e.length; t++)this.applyDelta(e[t]);
        }, e.prototype.revertDeltas = function(e) {
            for(var t = e.length - 1; t >= 0; t--)this.revertDelta(e[t]);
        }, e.prototype.applyDelta = function(e, t) {
            var n = e.action == "insert";
            if (n ? e.lines.length <= 1 && !e.lines[0] : !o.comparePoints(e.start, e.end)) return;
            n && e.lines.length > 2e4 ? this.$splitAndapplyLargeDelta(e, 2e4) : (i(this.$lines, e, t), this._signal("change", e));
        }, e.prototype.$safeApplyDelta = function(e) {
            var t = this.$lines.length;
            (e.action == "remove" && e.start.row < t && e.end.row < t || e.action == "insert" && e.start.row <= t) && this.applyDelta(e);
        }, e.prototype.$splitAndapplyLargeDelta = function(e, t) {
            var n = e.lines, r = n.length - t + 1, i = e.start.row, s = e.start.column;
            for(var o = 0, u = 0; o < r; o = u){
                u += t - 1;
                var a = n.slice(o, u);
                a.push(""), this.applyDelta({
                    start: this.pos(i + o, s),
                    end: this.pos(i + u, s = 0),
                    action: e.action,
                    lines: a
                }, !0);
            }
            e.lines = n.slice(o), e.start.row = i + o, e.start.column = s, this.applyDelta(e, !0);
        }, e.prototype.revertDelta = function(e) {
            this.$safeApplyDelta({
                start: this.clonePos(e.start),
                end: this.clonePos(e.end),
                action: e.action == "insert" ? "remove" : "insert",
                lines: e.lines.slice()
            });
        }, e.prototype.indexToPosition = function(e, t) {
            var n = this.$lines || this.getAllLines(), r = this.getNewLineCharacter().length;
            for(var i = t || 0, s = n.length; i < s; i++){
                e -= n[i].length + r;
                if (e < 0) return {
                    row: i,
                    column: e + n[i].length + r
                };
            }
            return {
                row: s - 1,
                column: e + n[s - 1].length + r
            };
        }, e.prototype.positionToIndex = function(e, t) {
            var n = this.$lines || this.getAllLines(), r = this.getNewLineCharacter().length, i = 0, s = Math.min(e.row, n.length);
            for(var o = t || 0; o < s; ++o)i += n[o].length + r;
            return i + e.column;
        }, e.prototype.$split = function(e) {
            return e.split(/\r\n|\r|\n/);
        }, e;
    }();
    a.prototype.$autoNewLine = "", a.prototype.$newLineMode = "auto", r.implement(a.prototype, s), t.Document = a;
}), ace.define("ace/background_tokenizer", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/oop"), i = e("./lib/event_emitter").EventEmitter, s = function() {
        function e(e, t) {
            this.running = !1, this.lines = [], this.states = [], this.currentLine = 0, this.tokenizer = e;
            var n = this;
            this.$worker = function() {
                if (!n.running) return;
                var e = new Date, t = n.currentLine, r = -1, i = n.doc, s = t;
                while(n.lines[t])t++;
                var o = i.getLength(), u = 0;
                n.running = !1;
                while(t < o){
                    n.$tokenizeRow(t), r = t;
                    do t++;
                    while (n.lines[t]);
                    u++;
                    if (u % 5 === 0 && new Date - e > 20) {
                        n.running = setTimeout(n.$worker, 20);
                        break;
                    }
                }
                n.currentLine = t, r == -1 && (r = t), s <= r && n.fireUpdateEvent(s, r);
            };
        }
        return e.prototype.setTokenizer = function(e) {
            this.tokenizer = e, this.lines = [], this.states = [], this.start(0);
        }, e.prototype.setDocument = function(e) {
            this.doc = e, this.lines = [], this.states = [], this.stop();
        }, e.prototype.fireUpdateEvent = function(e, t) {
            var n = {
                first: e,
                last: t
            };
            this._signal("update", {
                data: n
            });
        }, e.prototype.start = function(e) {
            this.currentLine = Math.min(e || 0, this.currentLine, this.doc.getLength()), this.lines.splice(this.currentLine, this.lines.length), this.states.splice(this.currentLine, this.states.length), this.stop(), this.running = setTimeout(this.$worker, 700);
        }, e.prototype.scheduleStart = function() {
            this.running || (this.running = setTimeout(this.$worker, 700));
        }, e.prototype.$updateOnChange = function(e) {
            var t = e.start.row, n = e.end.row - t;
            if (n === 0) this.lines[t] = null;
            else if (e.action == "remove") this.lines.splice(t, n + 1, null), this.states.splice(t, n + 1, null);
            else {
                var r = Array(n + 1);
                r.unshift(t, 1), this.lines.splice.apply(this.lines, r), this.states.splice.apply(this.states, r);
            }
            this.currentLine = Math.min(t, this.currentLine, this.doc.getLength()), this.stop();
        }, e.prototype.stop = function() {
            this.running && clearTimeout(this.running), this.running = !1;
        }, e.prototype.getTokens = function(e) {
            return this.lines[e] || this.$tokenizeRow(e);
        }, e.prototype.getState = function(e) {
            return this.currentLine == e && this.$tokenizeRow(e), this.states[e] || "start";
        }, e.prototype.$tokenizeRow = function(e) {
            var t = this.doc.getLine(e), n = this.states[e - 1], r = this.tokenizer.getLineTokens(t, n, e);
            return this.states[e] + "" != r.state + "" ? (this.states[e] = r.state, this.lines[e + 1] = null, this.currentLine > e + 1 && (this.currentLine = e + 1)) : this.currentLine == e && (this.currentLine = e + 1), this.lines[e] = r.tokens;
        }, e.prototype.cleanup = function() {
            this.running = !1, this.lines = [], this.states = [], this.currentLine = 0, this.removeAllListeners();
        }, e;
    }();
    r.implement(s.prototype, i), t.BackgroundTokenizer = s;
}), ace.define("ace/search_highlight", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/lang"), i = e("./range").Range, s = function() {
        function e(e, t, n) {
            n === void 0 && (n = "text"), this.setRegexp(e), this.clazz = t, this.type = n, this.docLen = 0;
        }
        return e.prototype.setRegexp = function(e) {
            if (this.regExp + "" == e + "") return;
            this.regExp = e, this.cache = [];
        }, e.prototype.update = function(e, t, n, s) {
            if (!this.regExp) return;
            var o = s.firstRow, u = s.lastRow, a = {}, f = n.$editor && n.$editor.$search, l = f && f.$isMultilineSearch(n.$editor.getLastSearchOptions());
            for(var c = o; c <= u; c++){
                var h = this.cache[c];
                if (h == null || n.getValue().length != this.docLen) {
                    if (l) {
                        h = [];
                        var p = f.$multiLineForward(n, this.regExp, c, u);
                        if (p) {
                            var d = p.endRow <= u ? p.endRow - 1 : u;
                            d > c && (c = d), h.push(new i(p.startRow, p.startCol, p.endRow, p.endCol));
                        }
                        h.length > this.MAX_RANGES && (h = h.slice(0, this.MAX_RANGES));
                    } else h = r.getMatchOffsets(n.getLine(c), this.regExp), h.length > this.MAX_RANGES && (h = h.slice(0, this.MAX_RANGES)), h = h.map(function(e) {
                        return new i(c, e.offset, c, e.offset + e.length);
                    });
                    this.cache[c] = h.length ? h : "";
                }
                if (h.length === 0) continue;
                for(var v = h.length; v--;){
                    var m = h[v].toScreenRange(n), g = m.toString();
                    if (a[g]) continue;
                    a[g] = !0, t.drawSingleLineMarker(e, m, this.clazz, s);
                }
            }
            this.docLen = n.getValue().length;
        }, e;
    }();
    s.prototype.MAX_RANGES = 500, t.SearchHighlight = s;
}), ace.define("ace/undomanager", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(e, t, n) {
    "use strict";
    function i(e, t) {
        for(var n = t; n--;){
            var r = e[n];
            if (r && !r[0].ignore) {
                while(n < t - 1){
                    var i = d(e[n], e[n + 1]);
                    e[n] = i[0], e[n + 1] = i[1], n++;
                }
                return !0;
            }
        }
    }
    function a(e) {
        var t = e.action == "insert", n = e.start, r = e.end, i = (r.row - n.row) * (t ? 1 : -1), s = (r.column - n.column) * (t ? 1 : -1);
        t && (r = n);
        for(var o in this.marks){
            var a = this.marks[o], f = u(a, n);
            if (f < 0) continue;
            if (f === 0 && t) {
                if (a.bias != 1) {
                    a.bias;
                    continue;
                }
                f = 1;
            }
            var l = t ? f : u(a, r);
            if (l > 0) {
                a.row += i, a.column += a.row == r.row ? s : 0;
                continue;
            }
            !t && l <= 0 && (a.row = n.row, a.column = n.column, l === 0 && (a.bias = 1));
        }
    }
    function f(e) {
        return {
            row: e.row,
            column: e.column
        };
    }
    function l(e) {
        return {
            start: f(e.start),
            end: f(e.end),
            action: e.action,
            lines: e.lines.slice()
        };
    }
    function c(e) {
        e = e || this;
        if (Array.isArray(e)) return e.map(c).join("\n");
        var t = "";
        e.action ? (t = e.action == "insert" ? "+" : "-", t += "[" + e.lines + "]") : e.value && (Array.isArray(e.value) ? t = e.value.map(h).join("\n") : t = h(e.value)), e.start && (t += h(e));
        if (e.id || e.rev) t += "	(" + (e.id || e.rev) + ")";
        return t;
    }
    function h(e) {
        return e.start.row + ":" + e.start.column + "=>" + e.end.row + ":" + e.end.column;
    }
    function p(e, t) {
        var n = e.action == "insert", r = t.action == "insert";
        if (n && r) {
            if (o(t.start, e.end) >= 0) m(t, e, -1);
            else {
                if (!(o(t.start, e.start) <= 0)) return null;
                m(e, t, 1);
            }
        } else if (n && !r) {
            if (o(t.start, e.end) >= 0) m(t, e, -1);
            else {
                if (!(o(t.end, e.start) <= 0)) return null;
                m(e, t, -1);
            }
        } else if (!n && r) {
            if (o(t.start, e.start) >= 0) m(t, e, 1);
            else {
                if (!(o(t.start, e.start) <= 0)) return null;
                m(e, t, 1);
            }
        } else if (!n && !r) {
            if (o(t.start, e.start) >= 0) m(t, e, 1);
            else {
                if (!(o(t.end, e.start) <= 0)) return null;
                m(e, t, -1);
            }
        }
        return [
            t,
            e
        ];
    }
    function d(e, t) {
        for(var n = e.length; n--;)for(var r = 0; r < t.length; r++)if (!p(e[n], t[r])) {
            while(n < e.length){
                while(r--)p(t[r], e[n]);
                r = t.length, n++;
            }
            return [
                e,
                t
            ];
        }
        return e.selectionBefore = t.selectionBefore = e.selectionAfter = t.selectionAfter = null, [
            t,
            e
        ];
    }
    function v(e, t) {
        var n = e.action == "insert", r = t.action == "insert";
        if (n && r) o(e.start, t.start) < 0 ? m(t, e, 1) : m(e, t, 1);
        else if (n && !r) o(e.start, t.end) >= 0 ? m(e, t, -1) : o(e.start, t.start) <= 0 ? m(t, e, 1) : (m(e, s.fromPoints(t.start, e.start), -1), m(t, e, 1));
        else if (!n && r) o(t.start, e.end) >= 0 ? m(t, e, -1) : o(t.start, e.start) <= 0 ? m(e, t, 1) : (m(t, s.fromPoints(e.start, t.start), -1), m(e, t, 1));
        else if (!n && !r) {
            if (o(t.start, e.end) >= 0) m(t, e, -1);
            else {
                if (!(o(t.end, e.start) <= 0)) {
                    var i, u;
                    return o(e.start, t.start) < 0 && (i = e, e = y(e, t.start)), o(e.end, t.end) > 0 && (u = y(e, t.end)), g(t.end, e.start, e.end, -1), u && !i && (e.lines = u.lines, e.start = u.start, e.end = u.end, u = e), [
                        t,
                        i,
                        u
                    ].filter(Boolean);
                }
                m(e, t, -1);
            }
        }
        return [
            t,
            e
        ];
    }
    function m(e, t, n) {
        g(e.start, t.start, t.end, n), g(e.end, t.start, t.end, n);
    }
    function g(e, t, n, r) {
        e.row == (r == 1 ? t : n).row && (e.column += r * (n.column - t.column)), e.row += r * (n.row - t.row);
    }
    function y(e, t) {
        var n = e.lines, r = e.end;
        e.end = f(t);
        var i = e.end.row - e.start.row, s = n.splice(i, n.length), o = i ? t.column : t.column - e.start.column;
        n.push(s[0].substring(0, o)), s[0] = s[0].substr(o);
        var u = {
            start: f(t),
            end: r,
            lines: s,
            action: e.action
        };
        return u;
    }
    function b(e, t) {
        t = l(t);
        for(var n = e.length; n--;){
            var r = e[n];
            for(var i = 0; i < r.length; i++){
                var s = r[i], o = v(s, t);
                t = o[0], o.length != 2 && (o[2] ? (r.splice(i + 1, 1, o[1], o[2]), i++) : o[1] || (r.splice(i, 1), i--));
            }
            r.length || e.splice(n, 1);
        }
        return e;
    }
    function w(e, t) {
        for(var n = 0; n < t.length; n++){
            var r = t[n];
            for(var i = 0; i < r.length; i++)b(e, r[i]);
        }
    }
    var r = function() {
        function e() {
            this.$keepRedoStack, this.$maxRev = 0, this.$fromUndo = !1, this.$undoDepth = Infinity, this.reset();
        }
        return e.prototype.addSession = function(e) {
            this.$session = e;
        }, e.prototype.add = function(e, t, n) {
            if (this.$fromUndo) return;
            if (e == this.$lastDelta) return;
            this.$keepRedoStack || (this.$redoStack.length = 0);
            if (t === !1 || !this.lastDeltas) {
                this.lastDeltas = [];
                var r = this.$undoStack.length;
                r > this.$undoDepth - 1 && this.$undoStack.splice(0, r - this.$undoDepth + 1), this.$undoStack.push(this.lastDeltas), e.id = this.$rev = ++this.$maxRev;
            }
            if (e.action == "remove" || e.action == "insert") this.$lastDelta = e;
            this.lastDeltas.push(e);
        }, e.prototype.addSelection = function(e, t) {
            this.selections.push({
                value: e,
                rev: t || this.$rev
            });
        }, e.prototype.startNewGroup = function() {
            return this.lastDeltas = null, this.$rev;
        }, e.prototype.markIgnored = function(e, t) {
            t == null && (t = this.$rev + 1);
            var n = this.$undoStack;
            for(var r = n.length; r--;){
                var i = n[r][0];
                if (i.id <= e) break;
                i.id < t && (i.ignore = !0);
            }
            this.lastDeltas = null;
        }, e.prototype.getSelection = function(e, t) {
            var n = this.selections;
            for(var r = n.length; r--;){
                var i = n[r];
                if (i.rev < e) return t && (i = n[r + 1]), i;
            }
        }, e.prototype.getRevision = function() {
            return this.$rev;
        }, e.prototype.getDeltas = function(e, t) {
            t == null && (t = this.$rev + 1);
            var n = this.$undoStack, r = null, i = 0;
            for(var s = n.length; s--;){
                var o = n[s][0];
                o.id < t && !r && (r = s + 1);
                if (o.id <= e) {
                    i = s + 1;
                    break;
                }
            }
            return n.slice(i, r);
        }, e.prototype.getChangedRanges = function(e, t) {
            t == null && (t = this.$rev + 1);
        }, e.prototype.getChangedLines = function(e, t) {
            t == null && (t = this.$rev + 1);
        }, e.prototype.undo = function(e, t) {
            this.lastDeltas = null;
            var n = this.$undoStack;
            if (!i(n, n.length)) return;
            e || (e = this.$session), this.$redoStackBaseRev !== this.$rev && this.$redoStack.length && (this.$redoStack = []), this.$fromUndo = !0;
            var r = n.pop(), s = null;
            return r && (s = e.undoChanges(r, t), this.$redoStack.push(r), this.$syncRev()), this.$fromUndo = !1, s;
        }, e.prototype.redo = function(e, t) {
            this.lastDeltas = null, e || (e = this.$session), this.$fromUndo = !0;
            if (this.$redoStackBaseRev != this.$rev) {
                var n = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
                w(this.$redoStack, n), this.$redoStackBaseRev = this.$rev, this.$redoStack.forEach(function(e) {
                    e[0].id = ++this.$maxRev;
                }, this);
            }
            var r = this.$redoStack.pop(), i = null;
            return r && (i = e.redoChanges(r, t), this.$undoStack.push(r), this.$syncRev()), this.$fromUndo = !1, i;
        }, e.prototype.$syncRev = function() {
            var e = this.$undoStack, t = e[e.length - 1], n = t && t[0].id || 0;
            this.$redoStackBaseRev = n, this.$rev = n;
        }, e.prototype.reset = function() {
            this.lastDeltas = null, this.$lastDelta = null, this.$undoStack = [], this.$redoStack = [], this.$rev = 0, this.mark = 0, this.$redoStackBaseRev = this.$rev, this.selections = [];
        }, e.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
        }, e.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
        }, e.prototype.bookmark = function(e) {
            e == undefined && (e = this.$rev), this.mark = e;
        }, e.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
        }, e.prototype.toJSON = function() {
            return {
                $redoStack: this.$redoStack,
                $undoStack: this.$undoStack
            };
        }, e.prototype.fromJSON = function(e) {
            this.reset(), this.$undoStack = e.$undoStack, this.$redoStack = e.$redoStack;
        }, e.prototype.$prettyPrint = function(e) {
            return e ? c(e) : c(this.$undoStack) + "\n---\n" + c(this.$redoStack);
        }, e;
    }();
    r.prototype.hasUndo = r.prototype.canUndo, r.prototype.hasRedo = r.prototype.canRedo, r.prototype.isClean = r.prototype.isAtBookmark, r.prototype.markClean = r.prototype.bookmark;
    var s = e("./range").Range, o = s.comparePoints, u = s.comparePoints;
    t.UndoManager = r;
}), ace.define("ace/edit_session/fold_line", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("../range").Range, i = function() {
        function e(e, t) {
            this.foldData = e, Array.isArray(t) ? this.folds = t : t = this.folds = [
                t
            ];
            var n = t[t.length - 1];
            this.range = new r(t[0].start.row, t[0].start.column, n.end.row, n.end.column), this.start = this.range.start, this.end = this.range.end, this.folds.forEach(function(e) {
                e.setFoldLine(this);
            }, this);
        }
        return e.prototype.shiftRow = function(e) {
            this.start.row += e, this.end.row += e, this.folds.forEach(function(t) {
                t.start.row += e, t.end.row += e;
            });
        }, e.prototype.addFold = function(e) {
            if (e.sameRow) {
                if (e.start.row < this.startRow || e.endRow > this.endRow) throw new Error("Can't add a fold to this FoldLine as it has no connection");
                this.folds.push(e), this.folds.sort(function(e, t) {
                    return -e.range.compareEnd(t.start.row, t.start.column);
                }), this.range.compareEnd(e.start.row, e.start.column) > 0 ? (this.end.row = e.end.row, this.end.column = e.end.column) : this.range.compareStart(e.end.row, e.end.column) < 0 && (this.start.row = e.start.row, this.start.column = e.start.column);
            } else if (e.start.row == this.end.row) this.folds.push(e), this.end.row = e.end.row, this.end.column = e.end.column;
            else {
                if (e.end.row != this.start.row) throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
                this.folds.unshift(e), this.start.row = e.start.row, this.start.column = e.start.column;
            }
            e.foldLine = this;
        }, e.prototype.containsRow = function(e) {
            return e >= this.start.row && e <= this.end.row;
        }, e.prototype.walk = function(e, t, n) {
            var r = 0, i = this.folds, s, o, u, a = !0;
            t == null && (t = this.end.row, n = this.end.column);
            for(var f = 0; f < i.length; f++){
                s = i[f], o = s.range.compareStart(t, n);
                if (o == -1) {
                    e(null, t, n, r, a);
                    return;
                }
                u = e(null, s.start.row, s.start.column, r, a), u = !u && e(s.placeholder, s.start.row, s.start.column, r);
                if (u || o === 0) return;
                a = !s.sameRow, r = s.end.column;
            }
            e(null, t, n, r, a);
        }, e.prototype.getNextFoldTo = function(e, t) {
            var n, r;
            for(var i = 0; i < this.folds.length; i++){
                n = this.folds[i], r = n.range.compareEnd(e, t);
                if (r == -1) return {
                    fold: n,
                    kind: "after"
                };
                if (r === 0) return {
                    fold: n,
                    kind: "inside"
                };
            }
            return null;
        }, e.prototype.addRemoveChars = function(e, t, n) {
            var r = this.getNextFoldTo(e, t), i, s;
            if (r) {
                i = r.fold;
                if (r.kind == "inside" && i.start.column != t && i.start.row != e) window.console && window.console.log(e, t, i);
                else if (i.start.row == e) {
                    s = this.folds;
                    var o = s.indexOf(i);
                    o === 0 && (this.start.column += n);
                    for(o; o < s.length; o++){
                        i = s[o], i.start.column += n;
                        if (!i.sameRow) return;
                        i.end.column += n;
                    }
                    this.end.column += n;
                }
            }
        }, e.prototype.split = function(t, n) {
            var r = this.getNextFoldTo(t, n);
            if (!r || r.kind == "inside") return null;
            var i = r.fold, s = this.folds, o = this.foldData, u = s.indexOf(i), a = s[u - 1];
            this.end.row = a.end.row, this.end.column = a.end.column, s = s.splice(u, s.length - u);
            var f = new e(o, s);
            return o.splice(o.indexOf(this) + 1, 0, f), f;
        }, e.prototype.merge = function(e) {
            var t = e.folds;
            for(var n = 0; n < t.length; n++)this.addFold(t[n]);
            var r = this.foldData;
            r.splice(r.indexOf(e), 1);
        }, e.prototype.toString = function() {
            var e = [
                this.range.toString() + ": ["
            ];
            return this.folds.forEach(function(t) {
                e.push("  " + t.toString());
            }), e.push("]"), e.join("\n");
        }, e.prototype.idxToPosition = function(e) {
            var t = 0;
            for(var n = 0; n < this.folds.length; n++){
                var r = this.folds[n];
                e -= r.start.column - t;
                if (e < 0) return {
                    row: r.start.row,
                    column: r.start.column + e
                };
                e -= r.placeholder.length;
                if (e < 0) return r.start;
                t = r.end.column;
            }
            return {
                row: this.end.row,
                column: this.end.column + e
            };
        }, e;
    }();
    t.FoldLine = i;
}), ace.define("ace/range_list", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("./range").Range, i = r.comparePoints, s = function() {
        function e() {
            this.ranges = [], this.$bias = 1;
        }
        return e.prototype.pointIndex = function(e, t, n) {
            var r = this.ranges;
            for(var s = n || 0; s < r.length; s++){
                var o = r[s], u = i(e, o.end);
                if (u > 0) continue;
                var a = i(e, o.start);
                return u === 0 ? t && a !== 0 ? -s - 2 : s : a > 0 || a === 0 && !t ? s : -s - 1;
            }
            return -s - 1;
        }, e.prototype.add = function(e) {
            var t = !e.isEmpty(), n = this.pointIndex(e.start, t);
            n < 0 && (n = -n - 1);
            var r = this.pointIndex(e.end, t, n);
            return r < 0 ? r = -r - 1 : r++, this.ranges.splice(n, r - n, e);
        }, e.prototype.addList = function(e) {
            var t = [];
            for(var n = e.length; n--;)t.push.apply(t, this.add(e[n]));
            return t;
        }, e.prototype.substractPoint = function(e) {
            var t = this.pointIndex(e);
            if (t >= 0) return this.ranges.splice(t, 1);
        }, e.prototype.merge = function() {
            var e = [], t = this.ranges;
            t = t.sort(function(e, t) {
                return i(e.start, t.start);
            });
            var n = t[0], r;
            for(var s = 1; s < t.length; s++){
                r = n, n = t[s];
                var o = i(r.end, n.start);
                if (o < 0) continue;
                if (o == 0 && !r.isEmpty() && !n.isEmpty()) continue;
                i(r.end, n.end) < 0 && (r.end.row = n.end.row, r.end.column = n.end.column), t.splice(s, 1), e.push(n), n = r, s--;
            }
            return this.ranges = t, e;
        }, e.prototype.contains = function(e, t) {
            return this.pointIndex({
                row: e,
                column: t
            }) >= 0;
        }, e.prototype.containsPoint = function(e) {
            return this.pointIndex(e) >= 0;
        }, e.prototype.rangeAtPoint = function(e) {
            var t = this.pointIndex(e);
            if (t >= 0) return this.ranges[t];
        }, e.prototype.clipRows = function(e, t) {
            var n = this.ranges;
            if (n[0].start.row > t || n[n.length - 1].start.row < e) return [];
            var r = this.pointIndex({
                row: e,
                column: 0
            });
            r < 0 && (r = -r - 1);
            var i = this.pointIndex({
                row: t,
                column: 0
            }, r);
            i < 0 && (i = -i - 1);
            var s = [];
            for(var o = r; o < i; o++)s.push(n[o]);
            return s;
        }, e.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
        }, e.prototype.attach = function(e) {
            this.session && this.detach(), this.session = e, this.onChange = this.$onChange.bind(this), this.session.on("change", this.onChange);
        }, e.prototype.detach = function() {
            if (!this.session) return;
            this.session.removeListener("change", this.onChange), this.session = null;
        }, e.prototype.$onChange = function(e) {
            var t = e.start, n = e.end, r = t.row, i = n.row, s = this.ranges;
            for(var o = 0, u = s.length; o < u; o++){
                var a = s[o];
                if (a.end.row >= r) break;
            }
            if (e.action == "insert") {
                var f = i - r, l = -t.column + n.column;
                for(; o < u; o++){
                    var a = s[o];
                    if (a.start.row > r) break;
                    a.start.row == r && a.start.column >= t.column && (a.start.column == t.column && this.$bias <= 0 || (a.start.column += l, a.start.row += f));
                    if (a.end.row == r && a.end.column >= t.column) {
                        if (a.end.column == t.column && this.$bias < 0) continue;
                        a.end.column == t.column && l > 0 && o < u - 1 && a.end.column > a.start.column && a.end.column == s[o + 1].start.column && (a.end.column -= l), a.end.column += l, a.end.row += f;
                    }
                }
            } else {
                var f = r - i, l = t.column - n.column;
                for(; o < u; o++){
                    var a = s[o];
                    if (a.start.row > i) break;
                    if (a.end.row < i && (r < a.end.row || r == a.end.row && t.column < a.end.column)) a.end.row = r, a.end.column = t.column;
                    else if (a.end.row == i) {
                        if (a.end.column <= n.column) {
                            if (f || a.end.column > t.column) a.end.column = t.column, a.end.row = t.row;
                        } else a.end.column += l, a.end.row += f;
                    } else a.end.row > i && (a.end.row += f);
                    if (a.start.row < i && (r < a.start.row || r == a.start.row && t.column < a.start.column)) a.start.row = r, a.start.column = t.column;
                    else if (a.start.row == i) {
                        if (a.start.column <= n.column) {
                            if (f || a.start.column > t.column) a.start.column = t.column, a.start.row = t.row;
                        } else a.start.column += l, a.start.row += f;
                    } else a.start.row > i && (a.start.row += f);
                }
            }
            if (f != 0 && o < u) for(; o < u; o++){
                var a = s[o];
                a.start.row += f, a.end.row += f;
            }
        }, e;
    }();
    s.prototype.comparePoints = i, t.RangeList = s;
}), ace.define("ace/edit_session/fold", [
    "require",
    "exports",
    "module",
    "ace/range_list"
], function(e, t, n) {
    "use strict";
    function o(e, t) {
        e.row -= t.row, e.row == 0 && (e.column -= t.column);
    }
    function u(e, t) {
        o(e.start, t), o(e.end, t);
    }
    function a(e, t) {
        e.row == 0 && (e.column += t.column), e.row += t.row;
    }
    function f(e, t) {
        a(e.start, t), a(e.end, t);
    }
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = e("../range_list").RangeList, s = function(e) {
        function t(t, n) {
            var r = e.call(this) || this;
            return r.foldLine = null, r.placeholder = n, r.range = t, r.start = t.start, r.end = t.end, r.sameRow = t.start.row == t.end.row, r.subFolds = r.ranges = [], r;
        }
        return r(t, e), t.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
        }, t.prototype.setFoldLine = function(e) {
            this.foldLine = e, this.subFolds.forEach(function(t) {
                t.setFoldLine(e);
            });
        }, t.prototype.clone = function() {
            var e = this.range.clone(), n = new t(e, this.placeholder);
            return this.subFolds.forEach(function(e) {
                n.subFolds.push(e.clone());
            }), n.collapseChildren = this.collapseChildren, n;
        }, t.prototype.addSubFold = function(e) {
            if (this.range.isEqual(e)) return;
            u(e, this.start);
            var t = e.start.row, n = e.start.column;
            for(var r = 0, i = -1; r < this.subFolds.length; r++){
                i = this.subFolds[r].range.compare(t, n);
                if (i != 1) break;
            }
            var s = this.subFolds[r], o = 0;
            if (i == 0) {
                if (s.range.containsRange(e)) return s.addSubFold(e);
                o = 1;
            }
            var t = e.range.end.row, n = e.range.end.column;
            for(var a = r, i = -1; a < this.subFolds.length; a++){
                i = this.subFolds[a].range.compare(t, n);
                if (i != 1) break;
            }
            i == 0 && a++;
            var f = this.subFolds.splice(r, a - r, e), l = i == 0 ? f.length - 1 : f.length;
            for(var c = o; c < l; c++)e.addSubFold(f[c]);
            return e.setFoldLine(this.foldLine), e;
        }, t.prototype.restoreRange = function(e) {
            return f(e, this.start);
        }, t;
    }(i);
    t.Fold = s;
}), ace.define("ace/edit_session/folding", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/edit_session/fold_line",
    "ace/edit_session/fold",
    "ace/token_iterator",
    "ace/mouse/mouse_event"
], function(e, t, n) {
    "use strict";
    function a() {
        this.getFoldAt = function(e, t, n) {
            var r = this.getFoldLine(e);
            if (!r) return null;
            var i = r.folds;
            for(var s = 0; s < i.length; s++){
                var o = i[s].range;
                if (o.contains(e, t)) {
                    if (n == 1 && o.isEnd(e, t) && !o.isEmpty()) continue;
                    if (n == -1 && o.isStart(e, t) && !o.isEmpty()) continue;
                    return i[s];
                }
            }
        }, this.getFoldsInRange = function(e) {
            var t = e.start, n = e.end, r = this.$foldData, i = [];
            t.column += 1, n.column -= 1;
            for(var s = 0; s < r.length; s++){
                var o = r[s].range.compareRange(e);
                if (o == 2) continue;
                if (o == -2) break;
                var u = r[s].folds;
                for(var a = 0; a < u.length; a++){
                    var f = u[a];
                    o = f.range.compareRange(e);
                    if (o == -2) break;
                    if (o == 2) continue;
                    if (o == 42) break;
                    i.push(f);
                }
            }
            return t.column -= 1, n.column += 1, i;
        }, this.getFoldsInRangeList = function(e) {
            if (Array.isArray(e)) {
                var t = [];
                e.forEach(function(e) {
                    t = t.concat(this.getFoldsInRange(e));
                }, this);
            } else var t = this.getFoldsInRange(e);
            return t;
        }, this.getAllFolds = function() {
            var e = [], t = this.$foldData;
            for(var n = 0; n < t.length; n++)for(var r = 0; r < t[n].folds.length; r++)e.push(t[n].folds[r]);
            return e;
        }, this.getFoldStringAt = function(e, t, n, r) {
            r = r || this.getFoldLine(e);
            if (!r) return null;
            var i = {
                end: {
                    column: 0
                }
            }, s, o;
            for(var u = 0; u < r.folds.length; u++){
                o = r.folds[u];
                var a = o.range.compareEnd(e, t);
                if (a == -1) {
                    s = this.getLine(o.start.row).substring(i.end.column, o.start.column);
                    break;
                }
                if (a === 0) return null;
                i = o;
            }
            return s || (s = this.getLine(o.start.row).substring(i.end.column)), n == -1 ? s.substring(0, t - i.end.column) : n == 1 ? s.substring(t - i.end.column) : s;
        }, this.getFoldLine = function(e, t) {
            var n = this.$foldData, r = 0;
            t && (r = n.indexOf(t)), r == -1 && (r = 0);
            for(r; r < n.length; r++){
                var i = n[r];
                if (i.start.row <= e && i.end.row >= e) return i;
                if (i.end.row > e) return null;
            }
            return null;
        }, this.getNextFoldLine = function(e, t) {
            var n = this.$foldData, r = 0;
            t && (r = n.indexOf(t)), r == -1 && (r = 0);
            for(r; r < n.length; r++){
                var i = n[r];
                if (i.end.row >= e) return i;
            }
            return null;
        }, this.getFoldedRowCount = function(e, t) {
            var n = this.$foldData, r = t - e + 1;
            for(var i = 0; i < n.length; i++){
                var s = n[i], o = s.end.row, u = s.start.row;
                if (o >= t) {
                    u < t && (u >= e ? r -= t - u : r = 0);
                    break;
                }
                o >= e && (u >= e ? r -= o - u : r -= o - e + 1);
            }
            return r;
        }, this.$addFoldLine = function(e) {
            return this.$foldData.push(e), this.$foldData.sort(function(e, t) {
                return e.start.row - t.start.row;
            }), e;
        }, this.addFold = function(e, t) {
            var n = this.$foldData, r = !1, o;
            e instanceof s ? o = e : (o = new s(t, e), o.collapseChildren = t.collapseChildren), this.$clipRangeToDocument(o.range);
            var u = o.start.row, a = o.start.column, f = o.end.row, l = o.end.column, c = this.getFoldAt(u, a, 1), h = this.getFoldAt(f, l, -1);
            if (c && h == c) return c.addSubFold(o);
            c && !c.range.isStart(u, a) && this.removeFold(c), h && !h.range.isEnd(f, l) && this.removeFold(h);
            var p = this.getFoldsInRange(o.range);
            p.length > 0 && (this.removeFolds(p), o.collapseChildren || p.forEach(function(e) {
                o.addSubFold(e);
            }));
            for(var d = 0; d < n.length; d++){
                var v = n[d];
                if (f == v.start.row) {
                    v.addFold(o), r = !0;
                    break;
                }
                if (u == v.end.row) {
                    v.addFold(o), r = !0;
                    if (!o.sameRow) {
                        var m = n[d + 1];
                        if (m && m.start.row == f) {
                            v.merge(m);
                            break;
                        }
                    }
                    break;
                }
                if (f <= v.start.row) break;
            }
            return r || (v = this.$addFoldLine(new i(this.$foldData, o))), this.$useWrapMode ? this.$updateWrapData(v.start.row, v.start.row) : this.$updateRowLengthCache(v.start.row, v.start.row), this.$modified = !0, this._signal("changeFold", {
                data: o,
                action: "add"
            }), o;
        }, this.addFolds = function(e) {
            e.forEach(function(e) {
                this.addFold(e);
            }, this);
        }, this.removeFold = function(e) {
            var t = e.foldLine, n = t.start.row, r = t.end.row, i = this.$foldData, s = t.folds;
            if (s.length == 1) i.splice(i.indexOf(t), 1);
            else if (t.range.isEnd(e.end.row, e.end.column)) s.pop(), t.end.row = s[s.length - 1].end.row, t.end.column = s[s.length - 1].end.column;
            else if (t.range.isStart(e.start.row, e.start.column)) s.shift(), t.start.row = s[0].start.row, t.start.column = s[0].start.column;
            else if (e.sameRow) s.splice(s.indexOf(e), 1);
            else {
                var o = t.split(e.start.row, e.start.column);
                s = o.folds, s.shift(), o.start.row = s[0].start.row, o.start.column = s[0].start.column;
            }
            this.$updating || (this.$useWrapMode ? this.$updateWrapData(n, r) : this.$updateRowLengthCache(n, r)), this.$modified = !0, this._signal("changeFold", {
                data: e,
                action: "remove"
            });
        }, this.removeFolds = function(e) {
            var t = [];
            for(var n = 0; n < e.length; n++)t.push(e[n]);
            t.forEach(function(e) {
                this.removeFold(e);
            }, this), this.$modified = !0;
        }, this.expandFold = function(e) {
            this.removeFold(e), e.subFolds.forEach(function(t) {
                e.restoreRange(t), this.addFold(t);
            }, this), e.collapseChildren > 0 && this.foldAll(e.start.row + 1, e.end.row, e.collapseChildren - 1), e.subFolds = [];
        }, this.expandFolds = function(e) {
            e.forEach(function(e) {
                this.expandFold(e);
            }, this);
        }, this.unfold = function(e, t) {
            var n, i;
            if (e == null) n = new r(0, 0, this.getLength(), 0), t == null && (t = !0);
            else if (typeof e == "number") n = new r(e, 0, e, this.getLine(e).length);
            else if ("row" in e) n = r.fromPoints(e, e);
            else {
                if (Array.isArray(e)) return i = [], e.forEach(function(e) {
                    i = i.concat(this.unfold(e));
                }, this), i;
                n = e;
            }
            i = this.getFoldsInRangeList(n);
            var s = i;
            while(i.length == 1 && r.comparePoints(i[0].start, n.start) < 0 && r.comparePoints(i[0].end, n.end) > 0)this.expandFolds(i), i = this.getFoldsInRangeList(n);
            t != 0 ? this.removeFolds(i) : this.expandFolds(i);
            if (s.length) return s;
        }, this.isRowFolded = function(e, t) {
            return !!this.getFoldLine(e, t);
        }, this.getRowFoldEnd = function(e, t) {
            var n = this.getFoldLine(e, t);
            return n ? n.end.row : e;
        }, this.getRowFoldStart = function(e, t) {
            var n = this.getFoldLine(e, t);
            return n ? n.start.row : e;
        }, this.getFoldDisplayLine = function(e, t, n, r, i) {
            r == null && (r = e.start.row), i == null && (i = 0), t == null && (t = e.end.row), n == null && (n = this.getLine(t).length);
            var s = this.doc, o = "";
            return e.walk(function(e, t, n, u) {
                if (t < r) return;
                if (t == r) {
                    if (n < i) return;
                    u = Math.max(i, u);
                }
                e != null ? o += e : o += s.getLine(t).substring(u, n);
            }, t, n), o;
        }, this.getDisplayLine = function(e, t, n, r) {
            var i = this.getFoldLine(e);
            if (!i) {
                var s;
                return s = this.doc.getLine(e), s.substring(r || 0, t || s.length);
            }
            return this.getFoldDisplayLine(i, e, t, n, r);
        }, this.$cloneFoldData = function() {
            var e = [];
            return e = this.$foldData.map(function(t) {
                var n = t.folds.map(function(e) {
                    return e.clone();
                });
                return new i(e, n);
            }), e;
        }, this.toggleFold = function(e) {
            var t = this.selection, n = t.getRange(), r, i;
            if (n.isEmpty()) {
                var s = n.start;
                r = this.getFoldAt(s.row, s.column);
                if (r) {
                    this.expandFold(r);
                    return;
                }
                if (e) {
                    var o = this.getFoldLine(s.row);
                    o && this.expandFolds(o.folds);
                    return;
                }
                (i = this.findMatchingBracket(s)) ? n.comparePoint(i) == 1 ? n.end = i : (n.start = i, n.start.column++, n.end.column--) : (i = this.findMatchingBracket({
                    row: s.row,
                    column: s.column + 1
                })) ? (n.comparePoint(i) == 1 ? n.end = i : n.start = i, n.start.column++) : n = this.getCommentFoldRange(s.row, s.column) || n;
            } else {
                var u = this.getFoldsInRange(n);
                if (e && u.length) {
                    this.expandFolds(u);
                    return;
                }
                u.length == 1 && (r = u[0]);
            }
            r || (r = this.getFoldAt(n.start.row, n.start.column));
            if (r && r.range.toString() == n.toString()) {
                this.expandFold(r);
                return;
            }
            var a = "...";
            if (!n.isMultiLine()) {
                a = this.getTextRange(n);
                if (a.length < 4) return;
                a = a.trim().substring(0, 2) + "..";
            }
            this.addFold(a, n);
        }, this.getCommentFoldRange = function(e, t, n) {
            var i = new o(this, e, t), s = i.getCurrentToken(), u = s && s.type;
            if (s && /^comment|string/.test(u)) {
                u = u.match(/comment|string/)[0], u == "comment" && (u += "|doc-start|\\.doc");
                var a = new RegExp(u), f = new r;
                if (n != 1) {
                    do s = i.stepBackward();
                    while (s && a.test(s.type));
                    s = i.stepForward();
                }
                f.start.row = i.getCurrentTokenRow(), f.start.column = i.getCurrentTokenColumn() + s.value.length, i = new o(this, e, t);
                var l = this.getState(i.$row);
                if (n != -1) {
                    var c = -1;
                    do {
                        s = i.stepForward();
                        if (c == -1) {
                            var h = this.getState(i.$row);
                            l.toString() !== h.toString() && (c = i.$row);
                        } else if (i.$row > c) break;
                    }while (s && a.test(s.type));
                    s = i.stepBackward();
                } else s = i.getCurrentToken();
                f.end.row = i.getCurrentTokenRow(), f.end.column = i.getCurrentTokenColumn();
                if (f.start.row == f.end.row && f.start.column > f.end.column) return;
                return f;
            }
        }, this.foldAll = function(e, t, n, r) {
            n == undefined && (n = 1e5);
            var i = this.foldWidgets;
            if (!i) return;
            t = t || this.getLength(), e = e || 0;
            for(var s = e; s < t; s++){
                i[s] == null && (i[s] = this.getFoldWidget(s));
                if (i[s] != "start") continue;
                if (r && !r(s)) continue;
                var o = this.getFoldWidgetRange(s);
                o && o.isMultiLine() && o.end.row <= t && o.start.row >= e && (s = o.end.row, o.collapseChildren = n, this.addFold("...", o));
            }
        }, this.foldToLevel = function(e) {
            this.foldAll();
            while(e-- > 0)this.unfold(null, !1);
        }, this.foldAllComments = function() {
            var e = this;
            this.foldAll(null, null, null, function(t) {
                var n = e.getTokens(t);
                for(var r = 0; r < n.length; r++){
                    var i = n[r];
                    if (i.type == "text" && /^\s+$/.test(i.value)) continue;
                    return /comment/.test(i.type) ? !0 : !1;
                }
            });
        }, this.$foldStyles = {
            manual: 1,
            markbegin: 1,
            markbeginend: 1
        }, this.$foldStyle = "markbegin", this.setFoldStyle = function(e) {
            if (!this.$foldStyles[e]) throw new Error("invalid fold style: " + e + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            if (this.$foldStyle == e) return;
            this.$foldStyle = e, e == "manual" && this.unfold();
            var t = this.$foldMode;
            this.$setFolding(null), this.$setFolding(t);
        }, this.$setFolding = function(e) {
            if (this.$foldMode == e) return;
            this.$foldMode = e, this.off("change", this.$updateFoldWidgets), this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets), this._signal("changeAnnotation");
            if (!e || this.$foldStyle == "manual") {
                this.foldWidgets = null;
                return;
            }
            this.foldWidgets = [], this.getFoldWidget = e.getFoldWidget.bind(e, this, this.$foldStyle), this.getFoldWidgetRange = e.getFoldWidgetRange.bind(e, this, this.$foldStyle), this.$updateFoldWidgets = this.updateFoldWidgets.bind(this), this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this), this.on("change", this.$updateFoldWidgets), this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        }, this.getParentFoldRangeData = function(e, t) {
            var n = this.foldWidgets;
            if (!n || t && n[e]) return {};
            var r = e - 1, i;
            while(r >= 0){
                var s = n[r];
                s == null && (s = n[r] = this.getFoldWidget(r));
                if (s == "start") {
                    var o = this.getFoldWidgetRange(r);
                    i || (i = o);
                    if (o && o.end.row >= e) break;
                }
                r--;
            }
            return {
                range: r !== -1 && o,
                firstRange: i
            };
        }, this.onFoldWidgetClick = function(e, t) {
            t instanceof u && (t = t.domEvent);
            var n = {
                children: t.shiftKey,
                all: t.ctrlKey || t.metaKey,
                siblings: t.altKey
            }, r = this.$toggleFoldWidget(e, n);
            if (!r) {
                var i = t.target || t.srcElement;
                i && /ace_fold-widget/.test(i.className) && (i.className += " ace_invalid");
            }
        }, this.$toggleFoldWidget = function(e, t) {
            if (!this.getFoldWidget) return;
            var n = this.getFoldWidget(e), r = this.getLine(e), i = n === "end" ? -1 : 1, s = this.getFoldAt(e, i === -1 ? 0 : r.length, i);
            if (s) return t.children || t.all ? this.removeFold(s) : this.expandFold(s), s;
            var o = this.getFoldWidgetRange(e, !0);
            if (o && !o.isMultiLine()) {
                s = this.getFoldAt(o.start.row, o.start.column, 1);
                if (s && o.isEqual(s.range)) return this.removeFold(s), s;
            }
            if (t.siblings) {
                var u = this.getParentFoldRangeData(e);
                if (u.range) var a = u.range.start.row + 1, f = u.range.end.row;
                this.foldAll(a, f, t.all ? 1e4 : 0);
            } else t.children ? (f = o ? o.end.row : this.getLength(), this.foldAll(e + 1, f, t.all ? 1e4 : 0)) : o && (t.all && (o.collapseChildren = 1e4), this.addFold("...", o));
            return o;
        }, this.toggleFoldWidget = function(e) {
            var t = this.selection.getCursor().row;
            t = this.getRowFoldStart(t);
            var n = this.$toggleFoldWidget(t, {});
            if (n) return;
            var r = this.getParentFoldRangeData(t, !0);
            n = r.range || r.firstRange;
            if (n) {
                t = n.start.row;
                var i = this.getFoldAt(t, this.getLine(t).length, 1);
                i ? this.removeFold(i) : this.addFold("...", n);
            }
        }, this.updateFoldWidgets = function(e) {
            var t = e.start.row, n = e.end.row - t;
            if (n === 0) this.foldWidgets[t] = null;
            else if (e.action == "remove") this.foldWidgets.splice(t, n + 1, null);
            else {
                var r = Array(n + 1);
                r.unshift(t, 1), this.foldWidgets.splice.apply(this.foldWidgets, r);
            }
        }, this.tokenizerUpdateFoldWidgets = function(e) {
            var t = e.data;
            t.first != t.last && this.foldWidgets.length > t.first && this.foldWidgets.splice(t.first, this.foldWidgets.length);
        };
    }
    var r = e("../range").Range, i = e("./fold_line").FoldLine, s = e("./fold").Fold, o = e("../token_iterator").TokenIterator, u = e("../mouse/mouse_event").MouseEvent;
    t.Folding = a;
}), ace.define("ace/edit_session/bracket_match", [
    "require",
    "exports",
    "module",
    "ace/token_iterator",
    "ace/range"
], function(e, t, n) {
    "use strict";
    function s() {
        this.findMatchingBracket = function(e, t) {
            if (e.column == 0) return null;
            var n = t || this.getLine(e.row).charAt(e.column - 1);
            if (n == "") return null;
            var r = n.match(/([\(\[\{])|([\)\]\}])/);
            return r ? r[1] ? this.$findClosingBracket(r[1], e) : this.$findOpeningBracket(r[2], e) : null;
        }, this.getBracketRange = function(e) {
            var t = this.getLine(e.row), n = !0, r, s = t.charAt(e.column - 1), o = s && s.match(/([\(\[\{])|([\)\]\}])/);
            o || (s = t.charAt(e.column), e = {
                row: e.row,
                column: e.column + 1
            }, o = s && s.match(/([\(\[\{])|([\)\]\}])/), n = !1);
            if (!o) return null;
            if (o[1]) {
                var u = this.$findClosingBracket(o[1], e);
                if (!u) return null;
                r = i.fromPoints(e, u), n || (r.end.column++, r.start.column--), r.cursor = r.end;
            } else {
                var u = this.$findOpeningBracket(o[2], e);
                if (!u) return null;
                r = i.fromPoints(u, e), n || (r.start.column++, r.end.column--), r.cursor = r.start;
            }
            return r;
        }, this.getMatchingBracketRanges = function(e, t) {
            var n = this.getLine(e.row), r = /([\(\[\{])|([\)\]\}])/, s = !t && n.charAt(e.column - 1), o = s && s.match(r);
            o || (s = (t === undefined || t) && n.charAt(e.column), e = {
                row: e.row,
                column: e.column + 1
            }, o = s && s.match(r));
            if (!o) return null;
            var u = new i(e.row, e.column - 1, e.row, e.column), a = o[1] ? this.$findClosingBracket(o[1], e) : this.$findOpeningBracket(o[2], e);
            if (!a) return [
                u
            ];
            var f = new i(a.row, a.column, a.row, a.column + 1);
            return [
                u,
                f
            ];
        }, this.$brackets = {
            ")": "(",
            "(": ")",
            "]": "[",
            "[": "]",
            "{": "}",
            "}": "{",
            "<": ">",
            ">": "<"
        }, this.$findOpeningBracket = function(e, t, n) {
            var i = this.$brackets[e], s = 1, o = new r(this, t.row, t.column), u = o.getCurrentToken();
            u || (u = o.stepForward());
            if (!u) return;
            n || (n = new RegExp("(\\.?" + u.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+"));
            var a = t.column - o.getCurrentTokenColumn() - 2, f = u.value;
            for(;;){
                while(a >= 0){
                    var l = f.charAt(a);
                    if (l == i) {
                        s -= 1;
                        if (s == 0) return {
                            row: o.getCurrentTokenRow(),
                            column: a + o.getCurrentTokenColumn()
                        };
                    } else l == e && (s += 1);
                    a -= 1;
                }
                do u = o.stepBackward();
                while (u && !n.test(u.type));
                if (u == null) break;
                f = u.value, a = f.length - 1;
            }
            return null;
        }, this.$findClosingBracket = function(e, t, n) {
            var i = this.$brackets[e], s = 1, o = new r(this, t.row, t.column), u = o.getCurrentToken();
            u || (u = o.stepForward());
            if (!u) return;
            n || (n = new RegExp("(\\.?" + u.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+"));
            var a = t.column - o.getCurrentTokenColumn();
            for(;;){
                var f = u.value, l = f.length;
                while(a < l){
                    var c = f.charAt(a);
                    if (c == i) {
                        s -= 1;
                        if (s == 0) return {
                            row: o.getCurrentTokenRow(),
                            column: a + o.getCurrentTokenColumn()
                        };
                    } else c == e && (s += 1);
                    a += 1;
                }
                do u = o.stepForward();
                while (u && !n.test(u.type));
                if (u == null) break;
                a = 0;
            }
            return null;
        }, this.getMatchingTags = function(e) {
            var t = new r(this, e.row, e.column), n = this.$findTagName(t);
            if (!n) return;
            var i = t.stepBackward();
            return i.value === "<" ? this.$findClosingTag(t, n) : this.$findOpeningTag(t, n);
        }, this.$findTagName = function(e) {
            var t = e.getCurrentToken(), n = !1, r = !1;
            if (t && t.type.indexOf("tag-name") === -1) do r ? t = e.stepBackward() : t = e.stepForward(), t && (t.value === "/>" ? r = !0 : t.type.indexOf("tag-name") !== -1 && (n = !0));
            while (t && !n);
            return t;
        }, this.$findClosingTag = function(e, t) {
            var n, r = t.value, s = t.value, o = 0, u = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
            t = e.stepForward();
            var a = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + t.value.length), f = !1;
            do {
                n = t;
                if (n.type.indexOf("tag-close") !== -1 && !f) {
                    var l = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
                    f = !0;
                }
                t = e.stepForward();
                if (t) {
                    if (t.value === ">" && !f) {
                        var l = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
                        f = !0;
                    }
                    if (t.type.indexOf("tag-name") !== -1) {
                        r = t.value;
                        if (s === r) {
                            if (n.value === "<") o++;
                            else if (n.value === "</") {
                                o--;
                                if (o < 0) {
                                    e.stepBackward();
                                    var c = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 2);
                                    t = e.stepForward();
                                    var h = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + t.value.length);
                                    t.type.indexOf("tag-close") === -1 && (t = e.stepForward());
                                    if (!t || t.value !== ">") return;
                                    var p = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
                                }
                            }
                        }
                    } else if (s === r && t.value === "/>") {
                        o--;
                        if (o < 0) var c = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 2), h = c, p = h, l = new i(a.end.row, a.end.column, a.end.row, a.end.column + 1);
                    }
                }
            }while (t && o >= 0);
            if (u && l && c && p && a && h) return {
                openTag: new i(u.start.row, u.start.column, l.end.row, l.end.column),
                closeTag: new i(c.start.row, c.start.column, p.end.row, p.end.column),
                openTagName: a,
                closeTagName: h
            };
        }, this.$findOpeningTag = function(e, t) {
            var n = e.getCurrentToken(), r = t.value, s = 0, o = e.getCurrentTokenRow(), u = e.getCurrentTokenColumn(), a = u + 2, f = new i(o, u, o, a);
            e.stepForward();
            var l = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + t.value.length);
            t.type.indexOf("tag-close") === -1 && (t = e.stepForward());
            if (!t || t.value !== ">") return;
            var c = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
            e.stepBackward(), e.stepBackward();
            do {
                t = n, o = e.getCurrentTokenRow(), u = e.getCurrentTokenColumn(), a = u + t.value.length, n = e.stepBackward();
                if (t) {
                    if (t.type.indexOf("tag-name") !== -1) {
                        if (r === t.value) {
                            if (n.value === "<") {
                                s++;
                                if (s > 0) {
                                    var h = new i(o, u, o, a), p = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
                                    do t = e.stepForward();
                                    while (t && t.value !== ">");
                                    var d = new i(e.getCurrentTokenRow(), e.getCurrentTokenColumn(), e.getCurrentTokenRow(), e.getCurrentTokenColumn() + 1);
                                }
                            } else n.value === "</" && s--;
                        }
                    } else if (t.value === "/>") {
                        var v = 0, m = n;
                        while(m){
                            if (m.type.indexOf("tag-name") !== -1 && m.value === r) {
                                s--;
                                break;
                            }
                            if (m.value === "<") break;
                            m = e.stepBackward(), v++;
                        }
                        for(var g = 0; g < v; g++)e.stepForward();
                    }
                }
            }while (n && s <= 0);
            if (p && d && f && c && h && l) return {
                openTag: new i(p.start.row, p.start.column, d.end.row, d.end.column),
                closeTag: new i(f.start.row, f.start.column, c.end.row, c.end.column),
                openTagName: h,
                closeTagName: l
            };
        };
    }
    var r = e("../token_iterator").TokenIterator, i = e("../range").Range;
    t.BracketMatch = s;
}), ace.define("ace/edit_session", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/bidihandler",
    "ace/config",
    "ace/lib/event_emitter",
    "ace/selection",
    "ace/mode/text",
    "ace/range",
    "ace/line_widgets",
    "ace/document",
    "ace/background_tokenizer",
    "ace/search_highlight",
    "ace/undomanager",
    "ace/edit_session/folding",
    "ace/edit_session/bracket_match"
], function(e, t, n) {
    "use strict";
    function N(e) {
        return e < 4352 ? !1 : e >= 4352 && e <= 4447 || e >= 4515 && e <= 4519 || e >= 4602 && e <= 4607 || e >= 9001 && e <= 9002 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12283 || e >= 12288 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12589 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12730 || e >= 12736 && e <= 12771 || e >= 12784 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 13054 || e >= 13056 && e <= 19903 || e >= 19968 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 55216 && e <= 55238 || e >= 55243 && e <= 55291 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
    }
    var r = e("./lib/oop"), i = e("./lib/lang"), s = e("./bidihandler").BidiHandler, o = e("./config"), u = e("./lib/event_emitter").EventEmitter, a = e("./selection").Selection, f = e("./mode/text").Mode, l = e("./range").Range, c = e("./line_widgets").LineWidgets, h = e("./document").Document, p = e("./background_tokenizer").BackgroundTokenizer, d = e("./search_highlight").SearchHighlight, v = e("./undomanager").UndoManager, m = function() {
        function e(t, n) {
            this.doc, this.$breakpoints = [], this.$decorations = [], this.$frontMarkers = {}, this.$backMarkers = {}, this.$markerId = 1, this.$undoSelect = !0, this.$editor = null, this.prevOp = {}, this.$foldData = [], this.id = "session" + ++e.$uid, this.$foldData.toString = function() {
                return this.join("\n");
            }, this.$gutterCustomWidgets = {}, this.bgTokenizer = new p((new f).getTokenizer(), this);
            var r = this;
            this.bgTokenizer.on("update", function(e) {
                r._signal("tokenizerUpdate", e);
            }), this.on("changeFold", this.onChangeFold.bind(this)), this.$onChange = this.onChange.bind(this);
            if (typeof t != "object" || !t.getLine) t = new h(t);
            this.setDocument(t), this.selection = new a(this), this.$onSelectionChange = this.onSelectionChange.bind(this), this.selection.on("changeSelection", this.$onSelectionChange), this.selection.on("changeCursor", this.$onSelectionChange), this.$bidiHandler = new s(this), o.resetOptions(this), this.setMode(n), o._signal("session", this), this.destroyed = !1, this.$initOperationListeners();
        }
        return e.prototype.$initOperationListeners = function() {
            var e = this;
            this.curOp = null, this.on("change", function() {
                e.curOp || (e.startOperation(), e.curOp.selectionBefore = e.$lastSel), e.curOp.docChanged = !0;
            }, !0), this.on("changeSelection", function() {
                e.curOp || (e.startOperation(), e.curOp.selectionBefore = e.$lastSel), e.curOp.selectionChanged = !0;
            }, !0), this.$operationResetTimer = i.delayedCall(this.endOperation.bind(this, !0));
        }, e.prototype.startOperation = function(e) {
            if (this.curOp) {
                if (!e || this.curOp.command) return;
                this.prevOp = this.curOp;
            }
            e || (e = {}), this.$operationResetTimer.schedule(), this.curOp = {
                command: e.command || {},
                args: e.args
            }, this.curOp.selectionBefore = this.selection.toJSON(), this._signal("startOperation", e);
        }, e.prototype.endOperation = function(e) {
            if (this.curOp) {
                if (e && e.returnValue === !1) {
                    this.curOp = null, this._signal("endOperation", e);
                    return;
                }
                if (e == 1 && this.curOp.command && this.curOp.command.name == "mouse") return;
                var t = this.selection.toJSON();
                this.curOp.selectionAfter = t, this.$lastSel = this.selection.toJSON(), this.getUndoManager().addSelection(t), this._signal("beforeEndOperation"), this.prevOp = this.curOp, this.curOp = null, this._signal("endOperation", e);
            }
        }, e.prototype.setDocument = function(e) {
            this.doc && this.doc.off("change", this.$onChange), this.doc = e, e.on("change", this.$onChange, !0), this.bgTokenizer.setDocument(this.getDocument()), this.resetCaches();
        }, e.prototype.getDocument = function() {
            return this.doc;
        }, Object.defineProperty(e.prototype, "widgetManager", {
            get: function() {
                var e = new c(this);
                return this.widgetManager = e, this.$editor && e.attach(this.$editor), e;
            },
            set: function(e) {
                Object.defineProperty(this, "widgetManager", {
                    writable: !0,
                    enumerable: !0,
                    configurable: !0,
                    value: e
                });
            },
            enumerable: !1,
            configurable: !0
        }), e.prototype.$resetRowCache = function(e) {
            if (!e) {
                this.$docRowCache = [], this.$screenRowCache = [];
                return;
            }
            var t = this.$docRowCache.length, n = this.$getRowCacheIndex(this.$docRowCache, e) + 1;
            t > n && (this.$docRowCache.splice(n, t), this.$screenRowCache.splice(n, t));
        }, e.prototype.$getRowCacheIndex = function(e, t) {
            var n = 0, r = e.length - 1;
            while(n <= r){
                var i = n + r >> 1, s = e[i];
                if (t > s) n = i + 1;
                else {
                    if (!(t < s)) return i;
                    r = i - 1;
                }
            }
            return n - 1;
        }, e.prototype.resetCaches = function() {
            this.$modified = !0, this.$wrapData = [], this.$rowLengthCache = [], this.$resetRowCache(0), this.destroyed || this.bgTokenizer.start(0);
        }, e.prototype.onChangeFold = function(e) {
            var t = e.data;
            this.$resetRowCache(t.start.row);
        }, e.prototype.onChange = function(e) {
            this.$modified = !0, this.$bidiHandler.onChange(e), this.$resetRowCache(e.start.row);
            var t = this.$updateInternalDataOnChange(e);
            !this.$fromUndo && this.$undoManager && (t && t.length && (this.$undoManager.add({
                action: "removeFolds",
                folds: t
            }, this.mergeUndoDeltas), this.mergeUndoDeltas = !0), this.$undoManager.add(e, this.mergeUndoDeltas), this.mergeUndoDeltas = !0, this.$informUndoManager.schedule()), this.bgTokenizer.$updateOnChange(e), this._signal("change", e);
        }, e.prototype.onSelectionChange = function() {
            this._signal("changeSelection");
        }, e.prototype.setValue = function(e) {
            this.doc.setValue(e), this.selection.moveTo(0, 0), this.$resetRowCache(0), this.setUndoManager(this.$undoManager), this.getUndoManager().reset();
        }, e.fromJSON = function(t) {
            typeof t == "string" && (t = JSON.parse(t));
            var n = new v;
            n.$undoStack = t.history.undo, n.$redoStack = t.history.redo, n.mark = t.history.mark, n.$rev = t.history.rev;
            var r = new e(t.value);
            return t.folds.forEach(function(e) {
                r.addFold("...", l.fromPoints(e.start, e.end));
            }), r.setAnnotations(t.annotations), r.setBreakpoints(t.breakpoints), r.setMode(t.mode), r.setScrollLeft(t.scrollLeft), r.setScrollTop(t.scrollTop), r.setUndoManager(n), r.selection.fromJSON(t.selection), r;
        }, e.prototype.toJSON = function() {
            return {
                annotations: this.$annotations,
                breakpoints: this.$breakpoints,
                folds: this.getAllFolds().map(function(e) {
                    return e.range;
                }),
                history: this.getUndoManager(),
                mode: this.$mode.$id,
                scrollLeft: this.$scrollLeft,
                scrollTop: this.$scrollTop,
                selection: this.selection.toJSON(),
                value: this.doc.getValue()
            };
        }, e.prototype.toString = function() {
            return this.doc.getValue();
        }, e.prototype.getSelection = function() {
            return this.selection;
        }, e.prototype.getState = function(e) {
            return this.bgTokenizer.getState(e);
        }, e.prototype.getTokens = function(e) {
            return this.bgTokenizer.getTokens(e);
        }, e.prototype.getTokenAt = function(e, t) {
            var n = this.bgTokenizer.getTokens(e), r, i = 0;
            if (t == null) {
                var s = n.length - 1;
                i = this.getLine(e).length;
            } else for(var s = 0; s < n.length; s++){
                i += n[s].value.length;
                if (i >= t) break;
            }
            return r = n[s], r ? (r.index = s, r.start = i - r.value.length, r) : null;
        }, e.prototype.setUndoManager = function(e) {
            this.$undoManager = e, this.$informUndoManager && this.$informUndoManager.cancel();
            if (e) {
                var t = this;
                e.addSession(this), this.$syncInformUndoManager = function() {
                    t.$informUndoManager.cancel(), t.mergeUndoDeltas = !1;
                }, this.$informUndoManager = i.delayedCall(this.$syncInformUndoManager);
            } else this.$syncInformUndoManager = function() {};
        }, e.prototype.markUndoGroup = function() {
            this.$syncInformUndoManager && this.$syncInformUndoManager();
        }, e.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
        }, e.prototype.getTabString = function() {
            return this.getUseSoftTabs() ? i.stringRepeat(" ", this.getTabSize()) : "	";
        }, e.prototype.setUseSoftTabs = function(e) {
            this.setOption("useSoftTabs", e);
        }, e.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        }, e.prototype.setTabSize = function(e) {
            this.setOption("tabSize", e);
        }, e.prototype.getTabSize = function() {
            return this.$tabSize;
        }, e.prototype.isTabStop = function(e) {
            return this.$useSoftTabs && e.column % this.$tabSize === 0;
        }, e.prototype.setNavigateWithinSoftTabs = function(e) {
            this.setOption("navigateWithinSoftTabs", e);
        }, e.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
        }, e.prototype.setOverwrite = function(e) {
            this.setOption("overwrite", e);
        }, e.prototype.getOverwrite = function() {
            return this.$overwrite;
        }, e.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
        }, e.prototype.addGutterDecoration = function(e, t) {
            this.$decorations[e] || (this.$decorations[e] = ""), this.$decorations[e] += " " + t, this._signal("changeBreakpoint", {});
        }, e.prototype.removeGutterCustomWidget = function(e) {
            this.$editor && this.$editor.renderer.$gutterLayer.$removeCustomWidget(e);
        }, e.prototype.addGutterCustomWidget = function(e, t) {
            this.$editor && this.$editor.renderer.$gutterLayer.$addCustomWidget(e, t);
        }, e.prototype.removeGutterDecoration = function(e, t) {
            this.$decorations[e] = (this.$decorations[e] || "").replace(" " + t, ""), this._signal("changeBreakpoint", {});
        }, e.prototype.getBreakpoints = function() {
            return this.$breakpoints;
        }, e.prototype.setBreakpoints = function(e) {
            this.$breakpoints = [];
            for(var t = 0; t < e.length; t++)this.$breakpoints[e[t]] = "ace_breakpoint";
            this._signal("changeBreakpoint", {});
        }, e.prototype.clearBreakpoints = function() {
            this.$breakpoints = [], this._signal("changeBreakpoint", {});
        }, e.prototype.setBreakpoint = function(e, t) {
            t === undefined && (t = "ace_breakpoint"), t ? this.$breakpoints[e] = t : delete this.$breakpoints[e], this._signal("changeBreakpoint", {});
        }, e.prototype.clearBreakpoint = function(e) {
            delete this.$breakpoints[e], this._signal("changeBreakpoint", {});
        }, e.prototype.addMarker = function(e, t, n, r) {
            var i = this.$markerId++, s = {
                range: e,
                type: n || "line",
                renderer: typeof n == "function" ? n : null,
                clazz: t,
                inFront: !!r,
                id: i
            };
            return r ? (this.$frontMarkers[i] = s, this._signal("changeFrontMarker")) : (this.$backMarkers[i] = s, this._signal("changeBackMarker")), i;
        }, e.prototype.addDynamicMarker = function(e, t) {
            if (!e.update) return;
            var n = this.$markerId++;
            return e.id = n, e.inFront = !!t, t ? (this.$frontMarkers[n] = e, this._signal("changeFrontMarker")) : (this.$backMarkers[n] = e, this._signal("changeBackMarker")), e;
        }, e.prototype.removeMarker = function(e) {
            var t = this.$frontMarkers[e] || this.$backMarkers[e];
            if (!t) return;
            var n = t.inFront ? this.$frontMarkers : this.$backMarkers;
            delete n[e], this._signal(t.inFront ? "changeFrontMarker" : "changeBackMarker");
        }, e.prototype.getMarkers = function(e) {
            return e ? this.$frontMarkers : this.$backMarkers;
        }, e.prototype.highlight = function(e) {
            if (!this.$searchHighlight) {
                var t = new d(null, "ace_selected-word", "text");
                this.$searchHighlight = this.addDynamicMarker(t);
            }
            this.$searchHighlight.setRegexp(e);
        }, e.prototype.highlightLines = function(e, t, n, r) {
            typeof t != "number" && (n = t, t = e), n || (n = "ace_step");
            var i = new l(e, 0, t, Infinity);
            return i.id = this.addMarker(i, n, "fullLine", r), i;
        }, e.prototype.setAnnotations = function(e) {
            this.$annotations = e, this._signal("changeAnnotation", {});
        }, e.prototype.getAnnotations = function() {
            return this.$annotations || [];
        }, e.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
        }, e.prototype.$detectNewLine = function(e) {
            var t = e.match(/^.*?(\r?\n)/m);
            t ? this.$autoNewLine = t[1] : this.$autoNewLine = "\n";
        }, e.prototype.getWordRange = function(e, t) {
            var n = this.getLine(e), r = !1;
            t > 0 && (r = !!n.charAt(t - 1).match(this.tokenRe)), r || (r = !!n.charAt(t).match(this.tokenRe));
            if (r) var i = this.tokenRe;
            else if (/^\s+$/.test(n.slice(t - 1, t + 1))) var i = /\s/;
            else var i = this.nonTokenRe;
            var s = t;
            if (s > 0) {
                do s--;
                while (s >= 0 && n.charAt(s).match(i));
                s++;
            }
            var o = t;
            while(o < n.length && n.charAt(o).match(i))o++;
            return new l(e, s, e, o);
        }, e.prototype.getAWordRange = function(e, t) {
            var n = this.getWordRange(e, t), r = this.getLine(n.end.row);
            while(r.charAt(n.end.column).match(/[ \t]/))n.end.column += 1;
            return n;
        }, e.prototype.setNewLineMode = function(e) {
            this.doc.setNewLineMode(e);
        }, e.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
        }, e.prototype.setUseWorker = function(e) {
            this.setOption("useWorker", e);
        }, e.prototype.getUseWorker = function() {
            return this.$useWorker;
        }, e.prototype.onReloadTokenizer = function(e) {
            var t = e.data;
            this.bgTokenizer.start(t.first), this._signal("tokenizerUpdate", e);
        }, e.prototype.setMode = function(e, t) {
            if (e && typeof e == "object") {
                if (e.getTokenizer) return this.$onChangeMode(e);
                var n = e, r = n.path;
            } else r = e || "ace/mode/text";
            this.$modes["ace/mode/text"] || (this.$modes["ace/mode/text"] = new f);
            if (this.$modes[r] && !n) {
                this.$onChangeMode(this.$modes[r]), t && t();
                return;
            }
            this.$modeId = r, o.loadModule([
                "mode",
                r
            ], (function(e) {
                if (this.destroyed) return;
                if (this.$modeId !== r) return t && t();
                this.$modes[r] && !n ? this.$onChangeMode(this.$modes[r]) : e && e.Mode && (e = new e.Mode(n), n || (this.$modes[r] = e, e.$id = r), this.$onChangeMode(e)), t && t();
            }).bind(this)), this.$mode || this.$onChangeMode(this.$modes["ace/mode/text"], !0);
        }, e.prototype.$onChangeMode = function(e, t) {
            t || (this.$modeId = e.$id);
            if (this.$mode === e) return;
            var n = this.$mode;
            this.$mode = e, this.$stopWorker(), this.$useWorker && this.$startWorker();
            var r = e.getTokenizer();
            if (r.on !== undefined) {
                var i = this.onReloadTokenizer.bind(this);
                r.on("update", i);
            }
            this.bgTokenizer.setTokenizer(r), this.bgTokenizer.setDocument(this.getDocument()), this.tokenRe = e.tokenRe, this.nonTokenRe = e.nonTokenRe, t || (e.attachToSession && e.attachToSession(this), this.$options.wrapMethod.set.call(this, this.$wrapMethod), this.$setFolding(e.foldingRules), this.bgTokenizer.start(0), this._emit("changeMode", {
                oldMode: n,
                mode: e
            }));
        }, e.prototype.$stopWorker = function() {
            this.$worker && (this.$worker.terminate(), this.$worker = null);
        }, e.prototype.$startWorker = function() {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                o.warn("Could not load worker", e), this.$worker = null;
            }
        }, e.prototype.getMode = function() {
            return this.$mode;
        }, e.prototype.setScrollTop = function(e) {
            if (this.$scrollTop === e || isNaN(e)) return;
            this.$scrollTop = e, this._signal("changeScrollTop", e);
        }, e.prototype.getScrollTop = function() {
            return this.$scrollTop;
        }, e.prototype.setScrollLeft = function(e) {
            if (this.$scrollLeft === e || isNaN(e)) return;
            this.$scrollLeft = e, this._signal("changeScrollLeft", e);
        }, e.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
        }, e.prototype.getScreenWidth = function() {
            return this.$computeWidth(), this.lineWidgets ? Math.max(this.getLineWidgetMaxWidth(), this.screenWidth) : this.screenWidth;
        }, e.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
            var e = 0;
            return this.lineWidgets.forEach(function(t) {
                t && t.screenWidth > e && (e = t.screenWidth);
            }), this.lineWidgetWidth = e;
        }, e.prototype.$computeWidth = function(e) {
            if (this.$modified || e) {
                this.$modified = !1;
                if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;
                var t = this.doc.getAllLines(), n = this.$rowLengthCache, r = 0, i = 0, s = this.$foldData[i], o = s ? s.start.row : Infinity, u = t.length;
                for(var a = 0; a < u; a++){
                    if (a > o) {
                        a = s.end.row + 1;
                        if (a >= u) break;
                        s = this.$foldData[i++], o = s ? s.start.row : Infinity;
                    }
                    n[a] == null && (n[a] = this.$getStringScreenWidth(t[a])[0]), n[a] > r && (r = n[a]);
                }
                this.screenWidth = r;
            }
        }, e.prototype.getLine = function(e) {
            return this.doc.getLine(e);
        }, e.prototype.getLines = function(e, t) {
            return this.doc.getLines(e, t);
        }, e.prototype.getLength = function() {
            return this.doc.getLength();
        }, e.prototype.getTextRange = function(e) {
            return this.doc.getTextRange(e || this.selection.getRange());
        }, e.prototype.insert = function(e, t) {
            return this.doc.insert(e, t);
        }, e.prototype.remove = function(e) {
            return this.doc.remove(e);
        }, e.prototype.removeFullLines = function(e, t) {
            return this.doc.removeFullLines(e, t);
        }, e.prototype.undoChanges = function(e, t) {
            if (!e.length) return;
            this.$fromUndo = !0;
            for(var n = e.length - 1; n != -1; n--){
                var r = e[n];
                r.action == "insert" || r.action == "remove" ? this.doc.revertDelta(r) : r.folds && this.addFolds(r.folds);
            }
            !t && this.$undoSelect && (e.selectionBefore ? this.selection.fromJSON(e.selectionBefore) : this.selection.setRange(this.$getUndoSelection(e, !0))), this.$fromUndo = !1;
        }, e.prototype.redoChanges = function(e, t) {
            if (!e.length) return;
            this.$fromUndo = !0;
            for(var n = 0; n < e.length; n++){
                var r = e[n];
                (r.action == "insert" || r.action == "remove") && this.doc.$safeApplyDelta(r);
            }
            !t && this.$undoSelect && (e.selectionAfter ? this.selection.fromJSON(e.selectionAfter) : this.selection.setRange(this.$getUndoSelection(e, !1))), this.$fromUndo = !1;
        }, e.prototype.setUndoSelect = function(e) {
            this.$undoSelect = e;
        }, e.prototype.$getUndoSelection = function(e, t) {
            function n(e) {
                return t ? e.action !== "insert" : e.action === "insert";
            }
            var r, i;
            for(var s = 0; s < e.length; s++){
                var o = e[s];
                if (!o.start) continue;
                if (!r) {
                    n(o) ? r = l.fromPoints(o.start, o.end) : r = l.fromPoints(o.start, o.start);
                    continue;
                }
                n(o) ? (i = o.start, r.compare(i.row, i.column) == -1 && r.setStart(i), i = o.end, r.compare(i.row, i.column) == 1 && r.setEnd(i)) : (i = o.start, r.compare(i.row, i.column) == -1 && (r = l.fromPoints(o.start, o.start)));
            }
            return r;
        }, e.prototype.replace = function(e, t) {
            return this.doc.replace(e, t);
        }, e.prototype.moveText = function(e, t, n) {
            var r = this.getTextRange(e), i = this.getFoldsInRange(e), s = l.fromPoints(t, t);
            if (!n) {
                this.remove(e);
                var o = e.start.row - e.end.row, u = o ? -e.end.column : e.start.column - e.end.column;
                u && (s.start.row == e.end.row && s.start.column > e.end.column && (s.start.column += u), s.end.row == e.end.row && s.end.column > e.end.column && (s.end.column += u)), o && s.start.row >= e.end.row && (s.start.row += o, s.end.row += o);
            }
            s.end = this.insert(s.start, r);
            if (i.length) {
                var a = e.start, f = s.start, o = f.row - a.row, u = f.column - a.column;
                this.addFolds(i.map(function(e) {
                    return e = e.clone(), e.start.row == a.row && (e.start.column += u), e.end.row == a.row && (e.end.column += u), e.start.row += o, e.end.row += o, e;
                }));
            }
            return s;
        }, e.prototype.indentRows = function(e, t, n) {
            n = n.replace(/\t/g, this.getTabString());
            for(var r = e; r <= t; r++)this.doc.insertInLine({
                row: r,
                column: 0
            }, n);
        }, e.prototype.outdentRows = function(e) {
            var t = e.collapseRows(), n = new l(0, 0, 0, 0), r = this.getTabSize();
            for(var i = t.start.row; i <= t.end.row; ++i){
                var s = this.getLine(i);
                n.start.row = i, n.end.row = i;
                for(var o = 0; o < r; ++o)if (s.charAt(o) != " ") break;
                o < r && s.charAt(o) == "	" ? (n.start.column = o, n.end.column = o + 1) : (n.start.column = 0, n.end.column = o), this.remove(n);
            }
        }, e.prototype.$moveLines = function(e, t, n) {
            e = this.getRowFoldStart(e), t = this.getRowFoldEnd(t);
            if (n < 0) {
                var r = this.getRowFoldStart(e + n);
                if (r < 0) return 0;
                var i = r - e;
            } else if (n > 0) {
                var r = this.getRowFoldEnd(t + n);
                if (r > this.doc.getLength() - 1) return 0;
                var i = r - t;
            } else {
                e = this.$clipRowToDocument(e), t = this.$clipRowToDocument(t);
                var i = t - e + 1;
            }
            var s = new l(e, 0, t, Number.MAX_VALUE), o = this.getFoldsInRange(s).map(function(e) {
                return e = e.clone(), e.start.row += i, e.end.row += i, e;
            }), u = n == 0 ? this.doc.getLines(e, t) : this.doc.removeFullLines(e, t);
            return this.doc.insertFullLines(e + i, u), o.length && this.addFolds(o), i;
        }, e.prototype.moveLinesUp = function(e, t) {
            return this.$moveLines(e, t, -1);
        }, e.prototype.moveLinesDown = function(e, t) {
            return this.$moveLines(e, t, 1);
        }, e.prototype.duplicateLines = function(e, t) {
            return this.$moveLines(e, t, 0);
        }, e.prototype.$clipRowToDocument = function(e) {
            return Math.max(0, Math.min(e, this.doc.getLength() - 1));
        }, e.prototype.$clipColumnToRow = function(e, t) {
            return t < 0 ? 0 : Math.min(this.doc.getLine(e).length, t);
        }, e.prototype.$clipPositionToDocument = function(e, t) {
            t = Math.max(0, t);
            if (e < 0) e = 0, t = 0;
            else {
                var n = this.doc.getLength();
                e >= n ? (e = n - 1, t = this.doc.getLine(n - 1).length) : t = Math.min(this.doc.getLine(e).length, t);
            }
            return {
                row: e,
                column: t
            };
        }, e.prototype.$clipRangeToDocument = function(e) {
            e.start.row < 0 ? (e.start.row = 0, e.start.column = 0) : e.start.column = this.$clipColumnToRow(e.start.row, e.start.column);
            var t = this.doc.getLength() - 1;
            return e.end.row > t ? (e.end.row = t, e.end.column = this.doc.getLine(t).length) : e.end.column = this.$clipColumnToRow(e.end.row, e.end.column), e;
        }, e.prototype.setUseWrapMode = function(e) {
            if (e != this.$useWrapMode) {
                this.$useWrapMode = e, this.$modified = !0, this.$resetRowCache(0);
                if (e) {
                    var t = this.getLength();
                    this.$wrapData = Array(t), this.$updateWrapData(0, t - 1);
                }
                this._signal("changeWrapMode");
            }
        }, e.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
        }, e.prototype.setWrapLimitRange = function(e, t) {
            if (this.$wrapLimitRange.min !== e || this.$wrapLimitRange.max !== t) this.$wrapLimitRange = {
                min: e,
                max: t
            }, this.$modified = !0, this.$bidiHandler.markAsDirty(), this.$useWrapMode && this._signal("changeWrapMode");
        }, e.prototype.adjustWrapLimit = function(e, t) {
            var n = this.$wrapLimitRange;
            n.max < 0 && (n = {
                min: t,
                max: t
            });
            var r = this.$constrainWrapLimit(e, n.min, n.max);
            return r != this.$wrapLimit && r > 1 ? (this.$wrapLimit = r, this.$modified = !0, this.$useWrapMode && (this.$updateWrapData(0, this.getLength() - 1), this.$resetRowCache(0), this._signal("changeWrapLimit")), !0) : !1;
        }, e.prototype.$constrainWrapLimit = function(e, t, n) {
            return t && (e = Math.max(t, e)), n && (e = Math.min(n, e)), e;
        }, e.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
        }, e.prototype.setWrapLimit = function(e) {
            this.setWrapLimitRange(e, e);
        }, e.prototype.getWrapLimitRange = function() {
            return {
                min: this.$wrapLimitRange.min,
                max: this.$wrapLimitRange.max
            };
        }, e.prototype.$updateInternalDataOnChange = function(e) {
            var t = this.$useWrapMode, n = e.action, r = e.start, i = e.end, s = r.row, o = i.row, u = o - s, a = null;
            this.$updating = !0;
            if (u != 0) {
                if (n === "remove") {
                    this[t ? "$wrapData" : "$rowLengthCache"].splice(s, u);
                    var f = this.$foldData;
                    a = this.getFoldsInRange(e), this.removeFolds(a);
                    var l = this.getFoldLine(i.row), c = 0;
                    if (l) {
                        l.addRemoveChars(i.row, i.column, r.column - i.column), l.shiftRow(-u);
                        var h = this.getFoldLine(s);
                        h && h !== l && (h.merge(l), l = h), c = f.indexOf(l) + 1;
                    }
                    for(c; c < f.length; c++){
                        var l = f[c];
                        l.start.row >= i.row && l.shiftRow(-u);
                    }
                    o = s;
                } else {
                    var p = Array(u);
                    p.unshift(s, 0);
                    var d = t ? this.$wrapData : this.$rowLengthCache;
                    d.splice.apply(d, p);
                    var f = this.$foldData, l = this.getFoldLine(s), c = 0;
                    if (l) {
                        var v = l.range.compareInside(r.row, r.column);
                        v == 0 ? (l = l.split(r.row, r.column), l && (l.shiftRow(u), l.addRemoveChars(o, 0, i.column - r.column))) : v == -1 && (l.addRemoveChars(s, 0, i.column - r.column), l.shiftRow(u)), c = f.indexOf(l) + 1;
                    }
                    for(c; c < f.length; c++){
                        var l = f[c];
                        l.start.row >= s && l.shiftRow(u);
                    }
                }
            } else {
                u = Math.abs(e.start.column - e.end.column), n === "remove" && (a = this.getFoldsInRange(e), this.removeFolds(a), u = -u);
                var l = this.getFoldLine(s);
                l && l.addRemoveChars(s, r.column, u);
            }
            return t && this.$wrapData.length != this.doc.getLength() && console.error("doc.getLength() and $wrapData.length have to be the same!"), this.$updating = !1, t ? this.$updateWrapData(s, o) : this.$updateRowLengthCache(s, o), a;
        }, e.prototype.$updateRowLengthCache = function(e, t) {
            this.$rowLengthCache[e] = null, this.$rowLengthCache[t] = null;
        }, e.prototype.$updateWrapData = function(e, t) {
            var n = this.doc.getAllLines(), r = this.getTabSize(), i = this.$wrapData, s = this.$wrapLimit, o, u, a = e;
            t = Math.min(t, n.length - 1);
            while(a <= t)u = this.getFoldLine(a, u), u ? (o = [], u.walk((function(e, t, r, i) {
                var s;
                if (e != null) {
                    s = this.$getDisplayTokens(e, o.length), s[0] = b;
                    for(var u = 1; u < s.length; u++)s[u] = w;
                } else s = this.$getDisplayTokens(n[t].substring(i, r), o.length);
                o = o.concat(s);
            }).bind(this), u.end.row, n[u.end.row].length + 1), i[u.start.row] = this.$computeWrapSplits(o, s, r), a = u.end.row + 1) : (o = this.$getDisplayTokens(n[a]), i[a] = this.$computeWrapSplits(o, s, r), a++);
        }, e.prototype.$computeWrapSplits = function(e, t, n) {
            function l() {
                var t = 0;
                if (f === 0) return t;
                if (a) for(var r = 0; r < e.length; r++){
                    var i = e[r];
                    if (i == S) t += 1;
                    else {
                        if (i != x) {
                            if (i == T) continue;
                            break;
                        }
                        t += n;
                    }
                }
                return u && a !== !1 && (t += n), Math.min(t, f);
            }
            function c(t) {
                var n = t - s;
                for(var i = s; i < t; i++){
                    var u = e[i];
                    if (u === 12 || u === 2) n -= 1;
                }
                r.length || (h = l(), r.indent = h), o += n, r.push(o), s = t;
            }
            if (e.length == 0) return [];
            var r = [], i = e.length, s = 0, o = 0, u = this.$wrapAsCode, a = this.$indentedSoftWrap, f = t <= Math.max(2 * n, 8) || a === !1 ? 0 : Math.floor(t / 2), h = 0;
            while(i - s > t - h){
                var p = s + t - h;
                if (e[p - 1] >= S && e[p] >= S) {
                    c(p);
                    continue;
                }
                if (e[p] == b || e[p] == w) {
                    for(p; p != s - 1; p--)if (e[p] == b) break;
                    if (p > s) {
                        c(p);
                        continue;
                    }
                    p = s + t;
                    for(p; p < e.length; p++)if (e[p] != w) break;
                    if (p == e.length) break;
                    c(p);
                    continue;
                }
                var d = Math.max(p - (t - (t >> 2)), s - 1);
                while(p > d && e[p] < b)p--;
                if (u) {
                    while(p > d && e[p] < b)p--;
                    while(p > d && e[p] == E)p--;
                } else while(p > d && e[p] < S)p--;
                if (p > d) {
                    c(++p);
                    continue;
                }
                p = s + t, e[p] == y && p--, c(p - h);
            }
            return r;
        }, e.prototype.$getDisplayTokens = function(e, t) {
            var n = [], r;
            t = t || 0;
            for(var i = 0; i < e.length; i++){
                var s = e.charCodeAt(i);
                if (s == 9) {
                    r = this.getScreenTabSize(n.length + t), n.push(x);
                    for(var o = 1; o < r; o++)n.push(T);
                } else s == 32 ? n.push(S) : s > 39 && s < 48 || s > 57 && s < 64 ? n.push(E) : s >= 4352 && N(s) ? n.push(g, y) : n.push(g);
            }
            return n;
        }, e.prototype.$getStringScreenWidth = function(e, t, n) {
            if (t == 0) return [
                0,
                0
            ];
            t == null && (t = Infinity), n = n || 0;
            var r, i;
            for(i = 0; i < e.length; i++){
                r = e.charCodeAt(i), r == 9 ? n += this.getScreenTabSize(n) : r >= 4352 && N(r) ? n += 2 : n += 1;
                if (n > t) break;
            }
            return [
                n,
                i
            ];
        }, e.prototype.getRowLength = function(e) {
            var t = 1;
            return this.lineWidgets && (t += this.lineWidgets[e] && this.lineWidgets[e].rowCount || 0), !this.$useWrapMode || !this.$wrapData[e] ? t : this.$wrapData[e].length + t;
        }, e.prototype.getRowLineCount = function(e) {
            return !this.$useWrapMode || !this.$wrapData[e] ? 1 : this.$wrapData[e].length + 1;
        }, e.prototype.getRowWrapIndent = function(e) {
            if (this.$useWrapMode) {
                var t = this.screenToDocumentPosition(e, Number.MAX_VALUE), n = this.$wrapData[t.row];
                return n.length && n[0] < t.column ? n.indent : 0;
            }
            return 0;
        }, e.prototype.getScreenLastRowColumn = function(e) {
            var t = this.screenToDocumentPosition(e, Number.MAX_VALUE);
            return this.documentToScreenColumn(t.row, t.column);
        }, e.prototype.getDocumentLastRowColumn = function(e, t) {
            var n = this.documentToScreenRow(e, t);
            return this.getScreenLastRowColumn(n);
        }, e.prototype.getDocumentLastRowColumnPosition = function(e, t) {
            var n = this.documentToScreenRow(e, t);
            return this.screenToDocumentPosition(n, Number.MAX_VALUE / 10);
        }, e.prototype.getRowSplitData = function(e) {
            return this.$useWrapMode ? this.$wrapData[e] : undefined;
        }, e.prototype.getScreenTabSize = function(e) {
            return this.$tabSize - (e % this.$tabSize | 0);
        }, e.prototype.screenToDocumentRow = function(e, t) {
            return this.screenToDocumentPosition(e, t).row;
        }, e.prototype.screenToDocumentColumn = function(e, t) {
            return this.screenToDocumentPosition(e, t).column;
        }, e.prototype.screenToDocumentPosition = function(e, t, n) {
            if (e < 0) return {
                row: 0,
                column: 0
            };
            var r, i = 0, s = 0, o, u = 0, a = 0, f = this.$screenRowCache, l = this.$getRowCacheIndex(f, e), c = f.length;
            if (c && l >= 0) var u = f[l], i = this.$docRowCache[l], h = e > f[c - 1];
            else var h = !c;
            var p = this.getLength() - 1, d = this.getNextFoldLine(i), v = d ? d.start.row : Infinity;
            while(u <= e){
                a = this.getRowLength(i);
                if (u + a > e || i >= p) break;
                u += a, i++, i > v && (i = d.end.row + 1, d = this.getNextFoldLine(i, d), v = d ? d.start.row : Infinity), h && (this.$docRowCache.push(i), this.$screenRowCache.push(u));
            }
            if (d && d.start.row <= i) r = this.getFoldDisplayLine(d), i = d.start.row;
            else {
                if (u + a <= e || i > p) return {
                    row: p,
                    column: this.getLine(p).length
                };
                r = this.getLine(i), d = null;
            }
            var m = 0, g = Math.floor(e - u);
            if (this.$useWrapMode) {
                var y = this.$wrapData[i];
                y && (o = y[g], g > 0 && y.length && (m = y.indent, s = y[g - 1] || y[y.length - 1], r = r.substring(s)));
            }
            return n !== undefined && this.$bidiHandler.isBidiRow(u + g, i, g) && (t = this.$bidiHandler.offsetToCol(n)), s += this.$getStringScreenWidth(r, t - m)[1], this.$useWrapMode && s >= o && (s = o - 1), d ? d.idxToPosition(s) : {
                row: i,
                column: s
            };
        }, e.prototype.documentToScreenPosition = function(e, t) {
            if (typeof t == "undefined") var n = this.$clipPositionToDocument(e.row, e.column);
            else n = this.$clipPositionToDocument(e, t);
            e = n.row, t = n.column;
            var r = 0, i = null, s = null;
            s = this.getFoldAt(e, t, 1), s && (e = s.start.row, t = s.start.column);
            var o, u = 0, a = this.$docRowCache, f = this.$getRowCacheIndex(a, e), l = a.length;
            if (l && f >= 0) var u = a[f], r = this.$screenRowCache[f], c = e > a[l - 1];
            else var c = !l;
            var h = this.getNextFoldLine(u), p = h ? h.start.row : Infinity;
            while(u < e){
                if (u >= p) {
                    o = h.end.row + 1;
                    if (o > e) break;
                    h = this.getNextFoldLine(o, h), p = h ? h.start.row : Infinity;
                } else o = u + 1;
                r += this.getRowLength(u), u = o, c && (this.$docRowCache.push(u), this.$screenRowCache.push(r));
            }
            var d = "";
            h && u >= p ? (d = this.getFoldDisplayLine(h, e, t), i = h.start.row) : (d = this.getLine(e).substring(0, t), i = e);
            var v = 0;
            if (this.$useWrapMode) {
                var m = this.$wrapData[i];
                if (m) {
                    var g = 0;
                    while(d.length >= m[g])r++, g++;
                    d = d.substring(m[g - 1] || 0, d.length), v = g > 0 ? m.indent : 0;
                }
            }
            return this.lineWidgets && this.lineWidgets[u] && this.lineWidgets[u].rowsAbove && (r += this.lineWidgets[u].rowsAbove), {
                row: r,
                column: v + this.$getStringScreenWidth(d)[0]
            };
        }, e.prototype.documentToScreenColumn = function(e, t) {
            return this.documentToScreenPosition(e, t).column;
        }, e.prototype.documentToScreenRow = function(e, t) {
            return this.documentToScreenPosition(e, t).row;
        }, e.prototype.getScreenLength = function() {
            var e = 0, t = null;
            if (!this.$useWrapMode) {
                e = this.getLength();
                var n = this.$foldData;
                for(var r = 0; r < n.length; r++)t = n[r], e -= t.end.row - t.start.row;
            } else {
                var i = this.$wrapData.length, s = 0, r = 0, t = this.$foldData[r++], o = t ? t.start.row : Infinity;
                while(s < i){
                    var u = this.$wrapData[s];
                    e += u ? u.length + 1 : 1, s++, s > o && (s = t.end.row + 1, t = this.$foldData[r++], o = t ? t.start.row : Infinity);
                }
            }
            return this.lineWidgets && (e += this.$getWidgetScreenLength()), e;
        }, e.prototype.$setFontMetrics = function(e) {
            if (!this.$enableVarChar) return;
            this.$getStringScreenWidth = function(t, n, r) {
                if (n === 0) return [
                    0,
                    0
                ];
                n || (n = Infinity), r = r || 0;
                var i, s;
                for(s = 0; s < t.length; s++){
                    i = t.charAt(s), i === "	" ? r += this.getScreenTabSize(r) : r += e.getCharacterWidth(i);
                    if (r > n) break;
                }
                return [
                    r,
                    s
                ];
            };
        }, e.prototype.getPrecedingCharacter = function() {
            var e = this.selection.getCursor();
            if (e.column === 0) return e.row === 0 ? "" : this.doc.getNewLineCharacter();
            var t = this.getLine(e.row);
            return t[e.column - 1];
        }, e.prototype.destroy = function() {
            this.destroyed || (this.bgTokenizer.setDocument(null), this.bgTokenizer.cleanup(), this.destroyed = !0), this.endOperation(), this.$stopWorker(), this.removeAllListeners(), this.doc && this.doc.off("change", this.$onChange), this.selection && (this.selection.off("changeCursor", this.$onSelectionChange), this.selection.off("changeSelection", this.$onSelectionChange)), this.selection.detach();
        }, e;
    }();
    m.$uid = 0, m.prototype.$modes = o.$modes, m.prototype.getValue = m.prototype.toString, m.prototype.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        hasUndo: function() {},
        hasRedo: function() {},
        reset: function() {},
        add: function() {},
        addSelection: function() {},
        startNewGroup: function() {},
        addSession: function() {}
    }, m.prototype.$overwrite = !1, m.prototype.$mode = null, m.prototype.$modeId = null, m.prototype.$scrollTop = 0, m.prototype.$scrollLeft = 0, m.prototype.$wrapLimit = 80, m.prototype.$useWrapMode = !1, m.prototype.$wrapLimitRange = {
        min: null,
        max: null
    }, m.prototype.lineWidgets = null, m.prototype.isFullWidth = N, r.implement(m.prototype, u);
    var g = 1, y = 2, b = 3, w = 4, E = 9, S = 10, x = 11, T = 12;
    e("./edit_session/folding").Folding.call(m.prototype), e("./edit_session/bracket_match").BracketMatch.call(m.prototype), o.defineOptions(m.prototype, "session", {
        wrap: {
            set: function(e) {
                !e || e == "off" ? e = !1 : e == "free" ? e = !0 : e == "printMargin" ? e = -1 : typeof e == "string" && (e = parseInt(e, 10) || !1);
                if (this.$wrap == e) return;
                this.$wrap = e;
                if (!e) this.setUseWrapMode(!1);
                else {
                    var t = typeof e == "number" ? e : null;
                    this.setWrapLimitRange(t, t), this.setUseWrapMode(!0);
                }
            },
            get: function() {
                return this.getUseWrapMode() ? this.$wrap == -1 ? "printMargin" : this.getWrapLimitRange().min ? this.$wrap : "free" : "off";
            },
            handlesSet: !0
        },
        wrapMethod: {
            set: function(e) {
                e = e == "auto" ? this.$mode.type != "text" : e != "text", e != this.$wrapAsCode && (this.$wrapAsCode = e, this.$useWrapMode && (this.$useWrapMode = !1, this.setUseWrapMode(!0)));
            },
            initialValue: "auto"
        },
        indentedSoftWrap: {
            set: function() {
                this.$useWrapMode && (this.$useWrapMode = !1, this.setUseWrapMode(!0));
            },
            initialValue: !0
        },
        firstLineNumber: {
            set: function() {
                this._signal("changeBreakpoint");
            },
            initialValue: 1
        },
        useWorker: {
            set: function(e) {
                this.$useWorker = e, this.$stopWorker(), e && this.$startWorker();
            },
            initialValue: !0
        },
        useSoftTabs: {
            initialValue: !0
        },
        tabSize: {
            set: function(e) {
                e = parseInt(e), e > 0 && this.$tabSize !== e && (this.$modified = !0, this.$rowLengthCache = [], this.$tabSize = e, this._signal("changeTabSize"));
            },
            initialValue: 4,
            handlesSet: !0
        },
        navigateWithinSoftTabs: {
            initialValue: !1
        },
        foldStyle: {
            set: function(e) {
                this.setFoldStyle(e);
            },
            handlesSet: !0
        },
        overwrite: {
            set: function(e) {
                this._signal("changeOverwrite");
            },
            initialValue: !1
        },
        newLineMode: {
            set: function(e) {
                this.doc.setNewLineMode(e);
            },
            get: function() {
                return this.doc.getNewLineMode();
            },
            handlesSet: !0
        },
        mode: {
            set: function(e) {
                this.setMode(e);
            },
            get: function() {
                return this.$modeId;
            },
            handlesSet: !0
        }
    }), t.EditSession = m;
}), ace.define("ace/search", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/lib/oop",
    "ace/range"
], function(e, t, n) {
    "use strict";
    function u(e, t) {
        function i(e, r) {
            r === void 0 && (r = !0);
            var i = n && t.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
            if (i.test(e) || t.regExp) return n && t.$supportsUnicodeFlag ? r ? "(?<=^|[^\\p{L}\\p{N}_])" : "(?=[^\\p{L}\\p{N}_]|$)" : "\\b";
            return "";
        }
        var n = r.supportsLookbehind(), s = Array.from(e), o = s[0], u = s[s.length - 1];
        return i(o) + e + i(u, !1);
    }
    function a(e, t, n) {
        var r = null, i = 0;
        while(i <= e.length){
            t.lastIndex = i;
            var s = t.exec(e);
            if (!s) break;
            var o = s.index + s[0].length;
            if (o > e.length - n) break;
            if (!r || o > r.index + r[0].length) r = s;
            i = s.index + 1;
        }
        return r;
    }
    function f(e, t) {
        var n = 5e3, r = {
            row: t,
            column: 0
        }, i = e.doc.positionToIndex(r), s = i + n, o = e.doc.indexToPosition(s), u = o.row;
        return u + 1;
    }
    var r = e("./lib/lang"), i = e("./lib/oop"), s = e("./range").Range, o = function() {
        function e() {
            this.$options = {};
        }
        return e.prototype.set = function(e) {
            return i.mixin(this.$options, e), this;
        }, e.prototype.getOptions = function() {
            return r.copyObject(this.$options);
        }, e.prototype.setOptions = function(e) {
            this.$options = e;
        }, e.prototype.find = function(e) {
            var t = this.$options, n = this.$matchIterator(e, t);
            if (!n) return !1;
            var r = null;
            return n.forEach(function(e, n, i, o) {
                return r = new s(e, n, i, o), n == o && t.start && t.start.start && t.skipCurrent != 0 && r.isEqual(t.start) ? (r = null, !1) : !0;
            }), r;
        }, e.prototype.findAll = function(e) {
            var t = this.$options;
            if (!t.needle) return [];
            this.$assembleRegExp(t);
            var n = t.range, i = n ? e.getLines(n.start.row, n.end.row) : e.doc.getAllLines(), o = [], u = t.re;
            if (t.$isMultiLine) {
                var a = u.length, f = i.length - a, l;
                e: for(var c = u.offset || 0; c <= f; c++){
                    for(var h = 0; h < a; h++)if (i[c + h].search(u[h]) == -1) continue e;
                    var p = i[c], d = i[c + a - 1], v = p.length - p.match(u[0])[0].length, m = d.match(u[a - 1])[0].length;
                    if (l && l.end.row === c && l.end.column > v) continue;
                    o.push(l = new s(c, v, c + a - 1, m)), a > 2 && (c = c + a - 2);
                }
            } else for(var g, y = 0; y < i.length; y++)if (this.$isMultilineSearch(t)) {
                var b = i.length - 1;
                g = this.$multiLineForward(e, u, y, b);
                if (g) {
                    var w = g.endRow <= b ? g.endRow - 1 : b;
                    w > y && (y = w), o.push(new s(g.startRow, g.startCol, g.endRow, g.endCol));
                }
            } else {
                g = r.getMatchOffsets(i[y], u);
                for(var h = 0; h < g.length; h++){
                    var E = g[h];
                    o.push(new s(y, E.offset, y, E.offset + E.length));
                }
            }
            if (n) {
                var S = n.start.column, x = n.end.column, y = 0, h = o.length - 1;
                while(y < h && o[y].start.column < S && o[y].start.row == 0)y++;
                var T = n.end.row - n.start.row;
                while(y < h && o[h].end.column > x && o[h].end.row == T)h--;
                o = o.slice(y, h + 1);
                for(y = 0, h = o.length; y < h; y++)o[y].start.row += n.start.row, o[y].end.row += n.start.row;
            }
            return o;
        }, e.prototype.parseReplaceString = function(e) {
            var t = {
                DollarSign: 36,
                Ampersand: 38,
                Digit0: 48,
                Digit1: 49,
                Digit9: 57,
                Backslash: 92,
                n: 110,
                t: 116
            }, n = "";
            for(var r = 0, i = e.length; r < i; r++){
                var s = e.charCodeAt(r);
                if (s === t.Backslash) {
                    r++;
                    if (r >= i) {
                        n += "\\";
                        break;
                    }
                    var o = e.charCodeAt(r);
                    switch(o){
                        case t.Backslash:
                            n += "\\";
                            break;
                        case t.n:
                            n += "\n";
                            break;
                        case t.t:
                            n += "	";
                    }
                    continue;
                }
                if (s === t.DollarSign) {
                    r++;
                    if (r >= i) {
                        n += "$";
                        break;
                    }
                    var u = e.charCodeAt(r);
                    if (u === t.DollarSign) {
                        n += "$$";
                        continue;
                    }
                    if (u === t.Digit0 || u === t.Ampersand) {
                        n += "$&";
                        continue;
                    }
                    if (t.Digit1 <= u && u <= t.Digit9) {
                        n += "$" + e[r];
                        continue;
                    }
                }
                n += e[r];
            }
            return n || e;
        }, e.prototype.replace = function(e, t) {
            var n = this.$options, r = this.$assembleRegExp(n);
            if (n.$isMultiLine) return t;
            if (!r) return;
            var i = this.$isMultilineSearch(n);
            i && (e = e.replace(/\r\n|\r|\n/g, "\n"));
            var s = r.exec(e);
            if (!s || !i && s[0].length != e.length) return null;
            t = n.regExp ? this.parseReplaceString(t) : t.replace(/\$/g, "$$$$"), t = e.replace(r, t);
            if (n.preserveCase) {
                t = t.split("");
                for(var o = Math.min(e.length, e.length); o--;){
                    var u = e[o];
                    u && u.toLowerCase() != u ? t[o] = t[o].toUpperCase() : t[o] = t[o].toLowerCase();
                }
                t = t.join("");
            }
            return t;
        }, e.prototype.$assembleRegExp = function(e, t) {
            if (e.needle instanceof RegExp) return e.re = e.needle;
            var n = e.needle;
            if (!e.needle) return e.re = !1;
            e.regExp || (n = r.escapeRegExp(n));
            var i = e.caseSensitive ? "gm" : "gmi";
            try {
                new RegExp(n, "u"), e.$supportsUnicodeFlag = !0, i += "u";
            } catch (s) {
                e.$supportsUnicodeFlag = !1;
            }
            e.wholeWord && (n = u(n, e)), e.$isMultiLine = !t && /[\n\r]/.test(n);
            if (e.$isMultiLine) return e.re = this.$assembleMultilineRegExp(n, i);
            try {
                var o = new RegExp(n, i);
            } catch (s) {
                o = !1;
            }
            return e.re = o;
        }, e.prototype.$assembleMultilineRegExp = function(e, t) {
            var n = e.replace(/\r\n|\r|\n/g, "$\n^").split("\n"), r = [];
            for(var i = 0; i < n.length; i++)try {
                r.push(new RegExp(n[i], t));
            } catch (s) {
                return !1;
            }
            return r;
        }, e.prototype.$isMultilineSearch = function(e) {
            return e.re && /\\r\\n|\\r|\\n/.test(e.re.source) && e.regExp && !e.$isMultiLine;
        }, e.prototype.$multiLineForward = function(e, t, n, r) {
            var i, s = f(e, n);
            for(var o = n; o <= r;){
                for(var u = 0; u < s; u++){
                    if (o > r) break;
                    var a = e.getLine(o++);
                    i = i == null ? a : i + "\n" + a;
                }
                var l = t.exec(i);
                t.lastIndex = 0;
                if (l) {
                    var c = i.slice(0, l.index).split("\n"), h = l[0].split("\n"), p = n + c.length - 1, d = c[c.length - 1].length, v = p + h.length - 1, m = h.length == 1 ? d + h[0].length : h[h.length - 1].length;
                    return {
                        startRow: p,
                        startCol: d,
                        endRow: v,
                        endCol: m
                    };
                }
            }
            return null;
        }, e.prototype.$multiLineBackward = function(e, t, n, r, i) {
            var s, o = f(e, r), u = e.getLine(r).length - n;
            for(var l = r; l >= i;){
                for(var c = 0; c < o && l >= i; c++){
                    var h = e.getLine(l--);
                    s = s == null ? h : h + "\n" + s;
                }
                var p = a(s, t, u);
                if (p) {
                    var d = s.slice(0, p.index).split("\n"), v = p[0].split("\n"), m = l + d.length, g = d[d.length - 1].length, y = m + v.length - 1, b = v.length == 1 ? g + v[0].length : v[v.length - 1].length;
                    return {
                        startRow: m,
                        startCol: g,
                        endRow: y,
                        endCol: b
                    };
                }
            }
            return null;
        }, e.prototype.$matchIterator = function(e, t) {
            var n = this.$assembleRegExp(t);
            if (!n) return !1;
            var i = this.$isMultilineSearch(t), s = this.$multiLineForward, o = this.$multiLineBackward, u = t.backwards == 1, a = t.skipCurrent != 0, f = n.unicode, l = t.range, c = t.start;
            c || (c = l ? l[u ? "end" : "start"] : e.selection.getRange()), c.start && (c = c[a != u ? "end" : "start"]);
            var h = l ? l.start.row : 0, p = l ? l.end.row : e.getLength() - 1;
            if (u) var d = function(e) {
                var n = c.row;
                if (m(n, c.column, e)) return;
                for(n--; n >= h; n--)if (m(n, Number.MAX_VALUE, e)) return;
                if (t.wrap == 0) return;
                for(n = p, h = c.row; n >= h; n--)if (m(n, Number.MAX_VALUE, e)) return;
            };
            else var d = function(e) {
                var n = c.row;
                if (m(n, c.column, e)) return;
                for(n += 1; n <= p; n++)if (m(n, 0, e)) return;
                if (t.wrap == 0) return;
                for(n = h, p = c.row; n <= p; n++)if (m(n, 0, e)) return;
            };
            if (t.$isMultiLine) var v = n.length, m = function(t, r, i) {
                var s = u ? t - v + 1 : t;
                if (s < 0 || s + v > e.getLength()) return;
                var o = e.getLine(s), a = o.search(n[0]);
                if (!u && a < r || a === -1) return;
                for(var f = 1; f < v; f++){
                    o = e.getLine(s + f);
                    if (o.search(n[f]) == -1) return;
                }
                var l = o.match(n[v - 1])[0].length;
                if (u && l > r) return;
                if (i(s, a, s + v - 1, l)) return !0;
            };
            else if (u) var m = function(t, s, u) {
                if (i) {
                    var a = o(e, n, s, t, h);
                    if (!a) return !1;
                    if (u(a.startRow, a.startCol, a.endRow, a.endCol)) return !0;
                } else {
                    var l = e.getLine(t), c = [], p, d = 0;
                    n.lastIndex = 0;
                    while(p = n.exec(l)){
                        var v = p[0].length;
                        d = p.index;
                        if (!v) {
                            if (d >= l.length) break;
                            n.lastIndex = d += r.skipEmptyMatch(l, d, f);
                        }
                        if (p.index + v > s) break;
                        c.push(p.index, v);
                    }
                    for(var m = c.length - 1; m >= 0; m -= 2){
                        var g = c[m - 1], v = c[m];
                        if (u(t, g, t, g + v)) return !0;
                    }
                }
            };
            else var m = function(t, o, u) {
                n.lastIndex = o;
                if (i) {
                    var a = s(e, n, t, p);
                    if (a) {
                        var l = a.endRow <= p ? a.endRow - 1 : p;
                        l > t && (t = l);
                    }
                    if (!a) return !1;
                    if (u(a.startRow, a.startCol, a.endRow, a.endCol)) return !0;
                } else {
                    var c = e.getLine(t), h, d;
                    while(d = n.exec(c)){
                        var v = d[0].length;
                        h = d.index;
                        if (u(t, h, t, h + v)) return !0;
                        if (!v) {
                            n.lastIndex = h += r.skipEmptyMatch(c, h, f);
                            if (h >= c.length) return !1;
                        }
                    }
                }
            };
            return {
                forEach: d
            };
        }, e;
    }();
    t.Search = o;
}), ace.define("ace/keyboard/hash_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/useragent"
], function(e, t, n) {
    "use strict";
    function a(e) {
        return typeof e == "object" && e.bindKey && e.bindKey.position || (e.isDefault ? -100 : 0);
    }
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = e("../lib/keys"), s = e("../lib/useragent"), o = i.KEY_MODS, u = function() {
        function e(e, t) {
            this.$init(e, t, !1);
        }
        return e.prototype.$init = function(e, t, n) {
            this.platform = t || (s.isMac ? "mac" : "win"), this.commands = {}, this.commandKeyBinding = {}, this.addCommands(e), this.$singleCommand = n;
        }, e.prototype.addCommand = function(e) {
            this.commands[e.name] && this.removeCommand(e), this.commands[e.name] = e, e.bindKey && this._buildKeyHash(e);
        }, e.prototype.removeCommand = function(e, t) {
            var n = e && (typeof e == "string" ? e : e.name);
            e = this.commands[n], t || delete this.commands[n];
            var r = this.commandKeyBinding;
            for(var i in r){
                var s = r[i];
                if (s == e) delete r[i];
                else if (Array.isArray(s)) {
                    var o = s.indexOf(e);
                    o != -1 && (s.splice(o, 1), s.length == 1 && (r[i] = s[0]));
                }
            }
        }, e.prototype.bindKey = function(e, t, n) {
            typeof e == "object" && e && (n == undefined && (n = e.position), e = e[this.platform]);
            if (!e) return;
            if (typeof t == "function") return this.addCommand({
                exec: t,
                bindKey: e,
                name: t.name || e
            });
            e.split("|").forEach(function(e) {
                var r = "";
                if (e.indexOf(" ") != -1) {
                    var i = e.split(/\s+/);
                    e = i.pop(), i.forEach(function(e) {
                        var t = this.parseKeys(e), n = o[t.hashId] + t.key;
                        r += (r ? " " : "") + n, this._addCommandToBinding(r, "chainKeys");
                    }, this), r += " ";
                }
                var s = this.parseKeys(e), u = o[s.hashId] + s.key;
                this._addCommandToBinding(r + u, t, n);
            }, this);
        }, e.prototype._addCommandToBinding = function(e, t, n) {
            var r = this.commandKeyBinding, i;
            if (!t) delete r[e];
            else if (!r[e] || this.$singleCommand) r[e] = t;
            else {
                Array.isArray(r[e]) ? (i = r[e].indexOf(t)) != -1 && r[e].splice(i, 1) : r[e] = [
                    r[e]
                ], typeof n != "number" && (n = a(t));
                var s = r[e];
                for(i = 0; i < s.length; i++){
                    var o = s[i], u = a(o);
                    if (u > n) break;
                }
                s.splice(i, 0, t);
            }
        }, e.prototype.addCommands = function(e) {
            e && Object.keys(e).forEach(function(t) {
                var n = e[t];
                if (!n) return;
                if (typeof n == "string") return this.bindKey(n, t);
                typeof n == "function" && (n = {
                    exec: n
                });
                if (typeof n != "object") return;
                n.name || (n.name = t), this.addCommand(n);
            }, this);
        }, e.prototype.removeCommands = function(e) {
            Object.keys(e).forEach(function(t) {
                this.removeCommand(e[t]);
            }, this);
        }, e.prototype.bindKeys = function(e) {
            Object.keys(e).forEach(function(t) {
                this.bindKey(t, e[t]);
            }, this);
        }, e.prototype._buildKeyHash = function(e) {
            this.bindKey(e.bindKey, e);
        }, e.prototype.parseKeys = function(e) {
            var t = e.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(e) {
                return e;
            }), n = t.pop(), r = i[n];
            if (i.FUNCTION_KEYS[r]) n = i.FUNCTION_KEYS[r].toLowerCase();
            else {
                if (!t.length) return {
                    key: n,
                    hashId: -1
                };
                if (t.length == 1 && t[0] == "shift") return {
                    key: n.toUpperCase(),
                    hashId: -1
                };
            }
            var s = 0;
            for(var o = t.length; o--;){
                var u = i.KEY_MODS[t[o]];
                if (u == null) return typeof console != "undefined" && console.error("invalid modifier " + t[o] + " in " + e), !1;
                s |= u;
            }
            return {
                key: n,
                hashId: s
            };
        }, e.prototype.findKeyCommand = function(e, t) {
            var n = o[e] + t;
            return this.commandKeyBinding[n];
        }, e.prototype.handleKeyboard = function(e, t, n, r) {
            if (r < 0) return;
            var i = o[t] + n, s = this.commandKeyBinding[i];
            e.$keyChain && (e.$keyChain += " " + i, s = this.commandKeyBinding[e.$keyChain] || s);
            if (s) {
                if (s == "chainKeys" || s[s.length - 1] == "chainKeys") return e.$keyChain = e.$keyChain || i, {
                    command: "null"
                };
            }
            if (e.$keyChain) {
                if (!!t && t != 4 || n.length != 1) {
                    if (t == -1 || r > 0) e.$keyChain = "";
                } else e.$keyChain = e.$keyChain.slice(0, -i.length - 1);
            }
            return {
                command: s
            };
        }, e.prototype.getStatusText = function(e, t) {
            return t.$keyChain || "";
        }, e;
    }(), f = function(e) {
        function t(t, n) {
            var r = e.call(this, t, n) || this;
            return r.$singleCommand = !0, r;
        }
        return r(t, e), t;
    }(u);
    f.call = function(e, t, n) {
        u.prototype.$init.call(e, t, n, !0);
    }, u.call = function(e, t, n) {
        u.prototype.$init.call(e, t, n, !1);
    }, t.HashHandler = f, t.MultiHashHandler = u;
}), ace.define("ace/commands/command_manager", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/keyboard/hash_handler",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = e("../lib/oop"), s = e("../keyboard/hash_handler").MultiHashHandler, o = e("../lib/event_emitter").EventEmitter, u = function(e) {
        function t(t, n) {
            var r = e.call(this, n, t) || this;
            return r.byName = r.commands, r.setDefaultHandler("exec", function(e) {
                return e.args ? e.command.exec(e.editor, e.args, e.event, !1) : e.command.exec(e.editor, {}, e.event, !0);
            }), r;
        }
        return r(t, e), t.prototype.exec = function(e, t, n) {
            if (Array.isArray(e)) {
                for(var r = e.length; r--;)if (this.exec(e[r], t, n)) return !0;
                return !1;
            }
            typeof e == "string" && (e = this.commands[e]);
            var i = {
                editor: t,
                command: e,
                args: n
            };
            return this.canExecute(e, t) ? (i.returnValue = this._emit("exec", i), this._signal("afterExec", i), i.returnValue === !1 ? !1 : !0) : (this._signal("commandUnavailable", i), !1);
        }, t.prototype.canExecute = function(e, t) {
            return typeof e == "string" && (e = this.commands[e]), e ? t && t.$readOnly && !e.readOnly ? !1 : this.$checkCommandState != 0 && e.isAvailable && !e.isAvailable(t) ? !1 : !0 : !1;
        }, t.prototype.toggleRecording = function(e) {
            if (this.$inReplay) return;
            return e && e._emit("changeStatus"), this.recording ? (this.macro.pop(), this.off("exec", this.$addCommandToMacro), this.macro.length || (this.macro = this.oldMacro), this.recording = !1) : (this.$addCommandToMacro || (this.$addCommandToMacro = (function(e) {
                this.macro.push([
                    e.command,
                    e.args
                ]);
            }).bind(this)), this.oldMacro = this.macro, this.macro = [], this.on("exec", this.$addCommandToMacro), this.recording = !0);
        }, t.prototype.replay = function(e) {
            if (this.$inReplay || !this.macro) return;
            if (this.recording) return this.toggleRecording(e);
            try {
                this.$inReplay = !0, this.macro.forEach(function(t) {
                    typeof t == "string" ? this.exec(t, e) : this.exec(t[0], e, t[1]);
                }, this);
            } finally{
                this.$inReplay = !1;
            }
        }, t.prototype.trimMacro = function(e) {
            return e.map(function(e) {
                return typeof e[0] != "string" && (e[0] = e[0].name), e[1] || (e = e[0]), e;
            });
        }, t;
    }(s);
    i.implement(u.prototype, o), t.CommandManager = u;
}), ace.define("ace/commands/default_commands", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/config",
    "ace/range"
], function(e, t, n) {
    "use strict";
    function o(e, t) {
        return {
            win: e,
            mac: t
        };
    }
    var r = e("../lib/lang"), i = e("../config"), s = e("../range").Range;
    t.commands = [
        {
            name: "showSettingsMenu",
            description: "Show settings menu",
            bindKey: o("Ctrl-,", "Command-,"),
            exec: function(e) {
                i.loadModule("ace/ext/settings_menu", function(t) {
                    t.init(e), e.showSettingsMenu();
                });
            },
            readOnly: !0
        },
        {
            name: "goToNextError",
            description: "Go to next error",
            bindKey: o("Alt-E", "F4"),
            exec: function(e) {
                i.loadModule("ace/ext/error_marker", function(t) {
                    t.showErrorMarker(e, 1);
                });
            },
            scrollIntoView: "animate",
            readOnly: !0
        },
        {
            name: "goToPreviousError",
            description: "Go to previous error",
            bindKey: o("Alt-Shift-E", "Shift-F4"),
            exec: function(e) {
                i.loadModule("ace/ext/error_marker", function(t) {
                    t.showErrorMarker(e, -1);
                });
            },
            scrollIntoView: "animate",
            readOnly: !0
        },
        {
            name: "selectall",
            description: "Select all",
            bindKey: o("Ctrl-A", "Command-A"),
            exec: function(e) {
                e.selectAll();
            },
            readOnly: !0
        },
        {
            name: "centerselection",
            description: "Center selection",
            bindKey: o(null, "Ctrl-L"),
            exec: function(e) {
                e.centerSelection();
            },
            readOnly: !0
        },
        {
            name: "gotoline",
            description: "Go to line...",
            bindKey: o("Ctrl-L", "Command-L"),
            exec: function(e, t) {
                typeof t == "number" && !isNaN(t) && e.gotoLine(t), e.prompt({
                    $type: "gotoLine"
                });
            },
            readOnly: !0
        },
        {
            name: "fold",
            bindKey: o("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
            exec: function(e) {
                e.session.toggleFold(!1);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "unfold",
            bindKey: o("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
            exec: function(e) {
                e.session.toggleFold(!0);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "toggleFoldWidget",
            description: "Toggle fold widget",
            bindKey: o("F2", "F2"),
            exec: function(e) {
                e.session.toggleFoldWidget();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "toggleParentFoldWidget",
            description: "Toggle parent fold widget",
            bindKey: o("Alt-F2", "Alt-F2"),
            exec: function(e) {
                e.session.toggleFoldWidget(!0);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "foldall",
            description: "Fold all",
            bindKey: o(null, "Ctrl-Command-Option-0"),
            exec: function(e) {
                e.session.foldAll();
            },
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "foldAllComments",
            description: "Fold all comments",
            bindKey: o(null, "Ctrl-Command-Option-0"),
            exec: function(e) {
                e.session.foldAllComments();
            },
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "foldOther",
            description: "Fold other",
            bindKey: o("Alt-0", "Command-Option-0"),
            exec: function(e) {
                e.session.foldAll(), e.session.unfold(e.selection.getAllRanges());
            },
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "unfoldall",
            description: "Unfold all",
            bindKey: o("Alt-Shift-0", "Command-Option-Shift-0"),
            exec: function(e) {
                e.session.unfold();
            },
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "findnext",
            description: "Find next",
            bindKey: o("Ctrl-K", "Command-G"),
            exec: function(e) {
                e.findNext();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "findprevious",
            description: "Find previous",
            bindKey: o("Ctrl-Shift-K", "Command-Shift-G"),
            exec: function(e) {
                e.findPrevious();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: !0
        },
        {
            name: "selectOrFindNext",
            description: "Select or find next",
            bindKey: o("Alt-K", "Ctrl-G"),
            exec: function(e) {
                e.selection.isEmpty() ? e.selection.selectWord() : e.findNext();
            },
            readOnly: !0
        },
        {
            name: "selectOrFindPrevious",
            description: "Select or find previous",
            bindKey: o("Alt-Shift-K", "Ctrl-Shift-G"),
            exec: function(e) {
                e.selection.isEmpty() ? e.selection.selectWord() : e.findPrevious();
            },
            readOnly: !0
        },
        {
            name: "find",
            description: "Find",
            bindKey: o("Ctrl-F", "Command-F"),
            exec: function(e) {
                i.loadModule("ace/ext/searchbox", function(t) {
                    t.Search(e);
                });
            },
            readOnly: !0
        },
        {
            name: "overwrite",
            description: "Overwrite",
            bindKey: "Insert",
            exec: function(e) {
                e.toggleOverwrite();
            },
            readOnly: !0
        },
        {
            name: "selecttostart",
            description: "Select to start",
            bindKey: o("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
            exec: function(e) {
                e.getSelection().selectFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: !0,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "gotostart",
            description: "Go to start",
            bindKey: o("Ctrl-Home", "Command-Home|Command-Up"),
            exec: function(e) {
                e.navigateFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: !0,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "selectup",
            description: "Select up",
            bindKey: o("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
            exec: function(e) {
                e.getSelection().selectUp();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "golineup",
            description: "Go line up",
            bindKey: o("Up", "Up|Ctrl-P"),
            exec: function(e, t) {
                e.navigateUp(t.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selecttoend",
            description: "Select to end",
            bindKey: o("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
            exec: function(e) {
                e.getSelection().selectFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: !0,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "gotoend",
            description: "Go to end",
            bindKey: o("Ctrl-End", "Command-End|Command-Down"),
            exec: function(e) {
                e.navigateFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: !0,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "selectdown",
            description: "Select down",
            bindKey: o("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
            exec: function(e) {
                e.getSelection().selectDown();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "golinedown",
            description: "Go line down",
            bindKey: o("Down", "Down|Ctrl-N"),
            exec: function(e, t) {
                e.navigateDown(t.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectwordleft",
            description: "Select word left",
            bindKey: o("Ctrl-Shift-Left", "Option-Shift-Left"),
            exec: function(e) {
                e.getSelection().selectWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotowordleft",
            description: "Go to word left",
            bindKey: o("Ctrl-Left", "Option-Left"),
            exec: function(e) {
                e.navigateWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selecttolinestart",
            description: "Select to line start",
            bindKey: o("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
            exec: function(e) {
                e.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotolinestart",
            description: "Go to line start",
            bindKey: o("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
            exec: function(e) {
                e.navigateLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectleft",
            description: "Select left",
            bindKey: o("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
            exec: function(e) {
                e.getSelection().selectLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotoleft",
            description: "Go to left",
            bindKey: o("Left", "Left|Ctrl-B"),
            exec: function(e, t) {
                e.navigateLeft(t.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectwordright",
            description: "Select word right",
            bindKey: o("Ctrl-Shift-Right", "Option-Shift-Right"),
            exec: function(e) {
                e.getSelection().selectWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotowordright",
            description: "Go to word right",
            bindKey: o("Ctrl-Right", "Option-Right"),
            exec: function(e) {
                e.navigateWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selecttolineend",
            description: "Select to line end",
            bindKey: o("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
            exec: function(e) {
                e.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotolineend",
            description: "Go to line end",
            bindKey: o("Alt-Right|End", "Command-Right|End|Ctrl-E"),
            exec: function(e) {
                e.navigateLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectright",
            description: "Select right",
            bindKey: o("Shift-Right", "Shift-Right"),
            exec: function(e) {
                e.getSelection().selectRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "gotoright",
            description: "Go to right",
            bindKey: o("Right", "Right|Ctrl-F"),
            exec: function(e, t) {
                e.navigateRight(t.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectpagedown",
            description: "Select page down",
            bindKey: "Shift-PageDown",
            exec: function(e) {
                e.selectPageDown();
            },
            readOnly: !0
        },
        {
            name: "pagedown",
            description: "Page down",
            bindKey: o(null, "Option-PageDown"),
            exec: function(e) {
                e.scrollPageDown();
            },
            readOnly: !0
        },
        {
            name: "gotopagedown",
            description: "Go to page down",
            bindKey: o("PageDown", "PageDown|Ctrl-V"),
            exec: function(e) {
                e.gotoPageDown();
            },
            readOnly: !0
        },
        {
            name: "selectpageup",
            description: "Select page up",
            bindKey: "Shift-PageUp",
            exec: function(e) {
                e.selectPageUp();
            },
            readOnly: !0
        },
        {
            name: "pageup",
            description: "Page up",
            bindKey: o(null, "Option-PageUp"),
            exec: function(e) {
                e.scrollPageUp();
            },
            readOnly: !0
        },
        {
            name: "gotopageup",
            description: "Go to page up",
            bindKey: "PageUp",
            exec: function(e) {
                e.gotoPageUp();
            },
            readOnly: !0
        },
        {
            name: "scrollup",
            description: "Scroll up",
            bindKey: o("Ctrl-Up", null),
            exec: function(e) {
                e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: !0
        },
        {
            name: "scrolldown",
            description: "Scroll down",
            bindKey: o("Ctrl-Down", null),
            exec: function(e) {
                e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: !0
        },
        {
            name: "selectlinestart",
            description: "Select line start",
            bindKey: "Shift-Home",
            exec: function(e) {
                e.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectlineend",
            description: "Select line end",
            bindKey: "Shift-End",
            exec: function(e) {
                e.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "togglerecording",
            description: "Toggle recording",
            bindKey: o("Ctrl-Alt-E", "Command-Option-E"),
            exec: function(e) {
                e.commands.toggleRecording(e);
            },
            readOnly: !0
        },
        {
            name: "replaymacro",
            description: "Replay macro",
            bindKey: o("Ctrl-Shift-E", "Command-Shift-E"),
            exec: function(e) {
                e.commands.replay(e);
            },
            readOnly: !0
        },
        {
            name: "jumptomatching",
            description: "Jump to matching",
            bindKey: o("Ctrl-\\|Ctrl-P", "Command-\\"),
            exec: function(e) {
                e.jumpToMatching();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: !0
        },
        {
            name: "selecttomatching",
            description: "Select to matching",
            bindKey: o("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
            exec: function(e) {
                e.jumpToMatching(!0);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: !0
        },
        {
            name: "expandToMatching",
            description: "Expand to matching",
            bindKey: o("Ctrl-Shift-M", "Ctrl-Shift-M"),
            exec: function(e) {
                e.jumpToMatching(!0, !0);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: !0
        },
        {
            name: "passKeysToBrowser",
            description: "Pass keys to browser",
            bindKey: o(null, null),
            exec: function() {},
            passEvent: !0,
            readOnly: !0
        },
        {
            name: "copy",
            description: "Copy",
            exec: function(e) {},
            readOnly: !0
        },
        {
            name: "cut",
            description: "Cut",
            exec: function(e) {
                var t = e.$copyWithEmptySelection && e.selection.isEmpty(), n = t ? e.selection.getLineRange() : e.selection.getRange();
                e._emit("cut", n), n.isEmpty() || e.session.remove(n), e.clearSelection();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "paste",
            description: "Paste",
            exec: function(e, t) {
                e.$handlePaste(t);
            },
            scrollIntoView: "cursor"
        },
        {
            name: "removeline",
            description: "Remove line",
            bindKey: o("Ctrl-D", "Command-D"),
            exec: function(e) {
                e.removeLines();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEachLine"
        },
        {
            name: "duplicateSelection",
            description: "Duplicate selection",
            bindKey: o("Ctrl-Shift-D", "Command-Shift-D"),
            exec: function(e) {
                e.duplicateSelection();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "sortlines",
            description: "Sort lines",
            bindKey: o("Ctrl-Alt-S", "Command-Alt-S"),
            exec: function(e) {
                e.sortLines();
            },
            scrollIntoView: "selection",
            multiSelectAction: "forEachLine"
        },
        {
            name: "togglecomment",
            description: "Toggle comment",
            bindKey: o("Ctrl-/", "Command-/"),
            exec: function(e) {
                e.toggleCommentLines();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "toggleBlockComment",
            description: "Toggle block comment",
            bindKey: o("Ctrl-Shift-/", "Command-Shift-/"),
            exec: function(e) {
                e.toggleBlockComment();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "modifyNumberUp",
            description: "Modify number up",
            bindKey: o("Ctrl-Shift-Up", "Alt-Shift-Up"),
            exec: function(e) {
                e.modifyNumber(1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "modifyNumberDown",
            description: "Modify number down",
            bindKey: o("Ctrl-Shift-Down", "Alt-Shift-Down"),
            exec: function(e) {
                e.modifyNumber(-1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "replace",
            description: "Replace",
            bindKey: o("Ctrl-H", "Command-Option-F"),
            exec: function(e) {
                i.loadModule("ace/ext/searchbox", function(t) {
                    t.Search(e, !0);
                });
            }
        },
        {
            name: "undo",
            description: "Undo",
            bindKey: o("Ctrl-Z", "Command-Z"),
            exec: function(e) {
                e.undo();
            }
        },
        {
            name: "redo",
            description: "Redo",
            bindKey: o("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
            exec: function(e) {
                e.redo();
            }
        },
        {
            name: "copylinesup",
            description: "Copy lines up",
            bindKey: o("Alt-Shift-Up", "Command-Option-Up"),
            exec: function(e) {
                e.copyLinesUp();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "movelinesup",
            description: "Move lines up",
            bindKey: o("Alt-Up", "Option-Up"),
            exec: function(e) {
                e.moveLinesUp();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "copylinesdown",
            description: "Copy lines down",
            bindKey: o("Alt-Shift-Down", "Command-Option-Down"),
            exec: function(e) {
                e.copyLinesDown();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "movelinesdown",
            description: "Move lines down",
            bindKey: o("Alt-Down", "Option-Down"),
            exec: function(e) {
                e.moveLinesDown();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "del",
            description: "Delete",
            bindKey: o("Delete", "Delete|Ctrl-D|Shift-Delete"),
            exec: function(e) {
                e.remove("right");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "backspace",
            description: "Backspace",
            bindKey: o("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
            exec: function(e) {
                e.remove("left");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "cut_or_delete",
            description: "Cut or delete",
            bindKey: o("Shift-Delete", null),
            exec: function(e) {
                if (!e.selection.isEmpty()) return !1;
                e.remove("left");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolinestart",
            description: "Remove to line start",
            bindKey: o("Alt-Backspace", "Command-Backspace"),
            exec: function(e) {
                e.removeToLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolineend",
            description: "Remove to line end",
            bindKey: o("Alt-Delete", "Ctrl-K|Command-Delete"),
            exec: function(e) {
                e.removeToLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolinestarthard",
            description: "Remove to line start hard",
            bindKey: o("Ctrl-Shift-Backspace", null),
            exec: function(e) {
                var t = e.selection.getRange();
                t.start.column = 0, e.session.remove(t);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolineendhard",
            description: "Remove to line end hard",
            bindKey: o("Ctrl-Shift-Delete", null),
            exec: function(e) {
                var t = e.selection.getRange();
                t.end.column = Number.MAX_VALUE, e.session.remove(t);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removewordleft",
            description: "Remove word left",
            bindKey: o("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
            exec: function(e) {
                e.removeWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removewordright",
            description: "Remove word right",
            bindKey: o("Ctrl-Delete", "Alt-Delete"),
            exec: function(e) {
                e.removeWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "outdent",
            description: "Outdent",
            bindKey: o("Shift-Tab", "Shift-Tab"),
            exec: function(e) {
                e.blockOutdent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "indent",
            description: "Indent",
            bindKey: o("Tab", "Tab"),
            exec: function(e) {
                e.indent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "blockoutdent",
            description: "Block outdent",
            bindKey: o("Ctrl-[", "Ctrl-["),
            exec: function(e) {
                e.blockOutdent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "blockindent",
            description: "Block indent",
            bindKey: o("Ctrl-]", "Ctrl-]"),
            exec: function(e) {
                e.blockIndent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "insertstring",
            description: "Insert string",
            exec: function(e, t) {
                e.insert(t);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "inserttext",
            description: "Insert text",
            exec: function(e, t) {
                e.insert(r.stringRepeat(t.text || "", t.times || 1));
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "splitline",
            description: "Split line",
            bindKey: o(null, "Ctrl-O"),
            exec: function(e) {
                e.splitLine();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "transposeletters",
            description: "Transpose letters",
            bindKey: o("Alt-Shift-X", "Ctrl-T"),
            exec: function(e) {
                e.transposeLetters();
            },
            multiSelectAction: function(e) {
                e.transposeSelections(1);
            },
            scrollIntoView: "cursor"
        },
        {
            name: "touppercase",
            description: "To uppercase",
            bindKey: o("Ctrl-U", "Ctrl-U"),
            exec: function(e) {
                e.toUpperCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "tolowercase",
            description: "To lowercase",
            bindKey: o("Ctrl-Shift-U", "Ctrl-Shift-U"),
            exec: function(e) {
                e.toLowerCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "autoindent",
            description: "Auto Indent",
            bindKey: o(null, null),
            exec: function(e) {
                e.autoIndent();
            },
            scrollIntoView: "animate"
        },
        {
            name: "expandtoline",
            description: "Expand to line",
            bindKey: o("Ctrl-Shift-L", "Command-Shift-L"),
            exec: function(e) {
                var t = e.selection.getRange();
                t.start.column = t.end.column = 0, t.end.row++, e.selection.setRange(t, !1);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "openlink",
            bindKey: o("Ctrl+F3", "F3"),
            exec: function(e) {
                e.openLink();
            }
        },
        {
            name: "joinlines",
            description: "Join lines",
            bindKey: o(null, null),
            exec: function(e) {
                var t = e.selection.isBackwards(), n = t ? e.selection.getSelectionLead() : e.selection.getSelectionAnchor(), i = t ? e.selection.getSelectionAnchor() : e.selection.getSelectionLead(), o = e.session.doc.getLine(n.row).length, u = e.session.doc.getTextRange(e.selection.getRange()), a = u.replace(/\n\s*/, " ").length, f = e.session.doc.getLine(n.row);
                for(var l = n.row + 1; l <= i.row + 1; l++){
                    var c = r.stringTrimLeft(r.stringTrimRight(e.session.doc.getLine(l)));
                    c.length !== 0 && (c = " " + c), f += c;
                }
                i.row + 1 < e.session.doc.getLength() - 1 && (f += e.session.doc.getNewLineCharacter()), e.clearSelection(), e.session.doc.replace(new s(n.row, 0, i.row + 2, 0), f), a > 0 ? (e.selection.moveCursorTo(n.row, n.column), e.selection.selectTo(n.row, n.column + a)) : (o = e.session.doc.getLine(n.row).length > o ? o + 1 : o, e.selection.moveCursorTo(n.row, o));
            },
            multiSelectAction: "forEach",
            readOnly: !0
        },
        {
            name: "invertSelection",
            description: "Invert selection",
            bindKey: o(null, null),
            exec: function(e) {
                var t = e.session.doc.getLength() - 1, n = e.session.doc.getLine(t).length, r = e.selection.rangeList.ranges, i = [];
                r.length < 1 && (r = [
                    e.selection.getRange()
                ]);
                for(var o = 0; o < r.length; o++)o == r.length - 1 && (r[o].end.row !== t || r[o].end.column !== n) && i.push(new s(r[o].end.row, r[o].end.column, t, n)), o === 0 ? (r[o].start.row !== 0 || r[o].start.column !== 0) && i.push(new s(0, 0, r[o].start.row, r[o].start.column)) : i.push(new s(r[o - 1].end.row, r[o - 1].end.column, r[o].start.row, r[o].start.column));
                e.exitMultiSelectMode(), e.clearSelection();
                for(var o = 0; o < i.length; o++)e.selection.addRange(i[o], !1);
            },
            readOnly: !0,
            scrollIntoView: "none"
        },
        {
            name: "addLineAfter",
            description: "Add new line after the current line",
            exec: function(e) {
                e.selection.clearSelection(), e.navigateLineEnd(), e.insert("\n");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "addLineBefore",
            description: "Add new line before the current line",
            exec: function(e) {
                e.selection.clearSelection();
                var t = e.getCursorPosition();
                e.selection.moveTo(t.row - 1, Number.MAX_VALUE), e.insert("\n"), t.row === 0 && e.navigateUp();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "openCommandPallete",
            exec: function(e) {
                console.warn("This is an obsolete command. Please use `openCommandPalette` instead."), e.prompt({
                    $type: "commands"
                });
            },
            readOnly: !0
        },
        {
            name: "openCommandPalette",
            description: "Open command palette",
            bindKey: o("F1", "F1"),
            exec: function(e) {
                e.prompt({
                    $type: "commands"
                });
            },
            readOnly: !0
        },
        {
            name: "modeSelect",
            description: "Change language mode...",
            bindKey: o(null, null),
            exec: function(e) {
                e.prompt({
                    $type: "modes"
                });
            },
            readOnly: !0
        }
    ];
    for(var u = 1; u < 9; u++)t.commands.push({
        name: "foldToLevel" + u,
        description: "Fold To Level " + u,
        level: u,
        exec: function(e) {
            e.session.foldToLevel(this.level);
        },
        scrollIntoView: "center",
        readOnly: !0
    });
}), ace.define("ace/keyboard/gutter_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/mouse/default_gutter_handler"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/keys"), i = e("../mouse/default_gutter_handler").GutterTooltip, s = function() {
        function e(e) {
            this.editor = e, this.gutterLayer = e.renderer.$gutterLayer, this.element = e.renderer.$gutter, this.lines = e.renderer.$gutterLayer.$lines, this.activeRowIndex = null, this.activeLane = null, this.annotationTooltip = new i(this.editor);
        }
        return e.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this)), this.element.addEventListener("focusout", this.$blurGutter.bind(this)), this.editor.on("mousewheel", this.$blurGutter.bind(this));
        }, e.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this)), this.element.removeEventListener("focusout", this.$blurGutter.bind(this)), this.editor.off("mousewheel", this.$blurGutter.bind(this));
        }, e.prototype.$onGutterKeyDown = function(e) {
            if (this.annotationTooltip.isOpen) {
                e.preventDefault(), e.keyCode === r.escape && this.annotationTooltip.hideTooltip();
                return;
            }
            if (e.target === this.element) {
                if (e.keyCode != r["enter"]) return;
                e.preventDefault();
                var t = this.editor.getCursorPosition().row;
                this.editor.isRowVisible(t) || this.editor.scrollToLine(t, !0, !0), setTimeout((function() {
                    var e = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row), t = this.$findNearestFoldLaneWidget(e), n = this.$findNearestAnnotation(e);
                    if (t === null && n === null) return;
                    var r = this.$findClosestNumber(t, n, e);
                    if (r === t) {
                        this.activeLane = "fold", this.activeRowIndex = t;
                        if (this.$isCustomWidgetVisible(t)) {
                            this.$focusCustomWidget(this.activeRowIndex);
                            return;
                        }
                        this.$focusFoldWidget(this.activeRowIndex);
                        return;
                    }
                    this.activeRowIndex = n, this.activeLane = "annotation", this.$focusAnnotation(this.activeRowIndex);
                    return;
                }).bind(this), 10);
                return;
            }
            this.$handleGutterKeyboardInteraction(e), setTimeout((function() {
                this.editor._signal("gutterkeydown", new o(e, this));
            }).bind(this), 10);
        }, e.prototype.$handleGutterKeyboardInteraction = function(e) {
            if (e.keyCode === r.tab) {
                e.preventDefault();
                return;
            }
            if (e.keyCode === r.escape) {
                e.preventDefault(), this.$blurGutter(), this.element.focus(), this.lane = null;
                return;
            }
            if (e.keyCode === r.up) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        this.$moveFoldWidgetUp();
                        break;
                    case "annotation":
                        this.$moveAnnotationUp();
                }
                return;
            }
            if (e.keyCode === r.down) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        this.$moveFoldWidgetDown();
                        break;
                    case "annotation":
                        this.$moveAnnotationDown();
                }
                return;
            }
            if (e.keyCode === r.left) {
                e.preventDefault(), this.$switchLane("annotation");
                return;
            }
            if (e.keyCode === r.right) {
                e.preventDefault(), this.$switchLane("fold");
                return;
            }
            if (e.keyCode === r.enter || e.keyCode === r.space) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        var t = this.$rowIndexToRow(this.activeRowIndex), n = this.editor.session.$gutterCustomWidgets[t];
                        if (n) n.callbacks && n.callbacks.onClick && n.callbacks.onClick(e, t);
                        else {
                            if (this.gutterLayer.session.foldWidgets[t] === "start") {
                                this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e), setTimeout((function() {
                                    this.$rowIndexToRow(this.activeRowIndex) !== t && (this.$blurFoldWidget(this.activeRowIndex), this.activeRowIndex = this.$rowToRowIndex(t), this.$focusFoldWidget(this.activeRowIndex));
                                }).bind(this), 10);
                                break;
                            }
                            if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") break;
                        }
                        return;
                    case "annotation":
                        var i = this.lines.cells[this.activeRowIndex].element.childNodes[2], s = i.getBoundingClientRect(), o = this.annotationTooltip.getElement().style;
                        o.left = s.right + "px", o.top = s.bottom + "px", this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                }
                return;
            }
        }, e.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) switch(this.activeLane){
                case "fold":
                    this.$blurFoldWidget(this.activeRowIndex), this.$blurCustomWidget(this.activeRowIndex);
                    break;
                case "annotation":
                    this.$blurAnnotation(this.activeRowIndex);
            }
            this.annotationTooltip.isOpen && this.annotationTooltip.hideTooltip();
            return;
        }, e.prototype.$isFoldWidgetVisible = function(e) {
            var t = this.editor.isRowFullyVisible(this.$rowIndexToRow(e)), n = this.$getFoldWidget(e).style.display !== "none";
            return t && n;
        }, e.prototype.$isCustomWidgetVisible = function(e) {
            var t = this.editor.isRowFullyVisible(this.$rowIndexToRow(e)), n = !!this.$getCustomWidget(e);
            return t && n;
        }, e.prototype.$isAnnotationVisible = function(e) {
            var t = this.editor.isRowFullyVisible(this.$rowIndexToRow(e)), n = this.$getAnnotation(e).style.display !== "none";
            return t && n;
        }, e.prototype.$getFoldWidget = function(e) {
            var t = this.lines.get(e), n = t.element;
            return n.childNodes[1];
        }, e.prototype.$getCustomWidget = function(e) {
            var t = this.lines.get(e), n = t.element;
            return n.childNodes[3];
        }, e.prototype.$getAnnotation = function(e) {
            var t = this.lines.get(e), n = t.element;
            return n.childNodes[2];
        }, e.prototype.$findNearestFoldLaneWidget = function(e) {
            if (this.$isCustomWidgetVisible(e)) return e;
            if (this.$isFoldWidgetVisible(e)) return e;
            var t = 0;
            while(e - t > 0 || e + t < this.lines.getLength() - 1){
                t++;
                if (e - t >= 0 && this.$isCustomWidgetVisible(e - t)) return e - t;
                if (e + t <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(e + t)) return e + t;
                if (e - t >= 0 && this.$isFoldWidgetVisible(e - t)) return e - t;
                if (e + t <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(e + t)) return e + t;
            }
            return null;
        }, e.prototype.$findNearestAnnotation = function(e) {
            if (this.$isAnnotationVisible(e)) return e;
            var t = 0;
            while(e - t > 0 || e + t < this.lines.getLength() - 1){
                t++;
                if (e - t >= 0 && this.$isAnnotationVisible(e - t)) return e - t;
                if (e + t <= this.lines.getLength() - 1 && this.$isAnnotationVisible(e + t)) return e + t;
            }
            return null;
        }, e.prototype.$focusFoldWidget = function(e) {
            if (e == null) return;
            var t = this.$getFoldWidget(e);
            t.classList.add(this.editor.renderer.keyboardFocusClassName), t.focus();
        }, e.prototype.$focusCustomWidget = function(e) {
            if (e == null) return;
            var t = this.$getCustomWidget(e);
            t && (t.classList.add(this.editor.renderer.keyboardFocusClassName), t.focus());
        }, e.prototype.$focusAnnotation = function(e) {
            if (e == null) return;
            var t = this.$getAnnotation(e);
            t.classList.add(this.editor.renderer.keyboardFocusClassName), t.focus();
        }, e.prototype.$blurFoldWidget = function(e) {
            var t = this.$getFoldWidget(e);
            t.classList.remove(this.editor.renderer.keyboardFocusClassName), t.blur();
        }, e.prototype.$blurCustomWidget = function(e) {
            var t = this.$getCustomWidget(e);
            t && (t.classList.remove(this.editor.renderer.keyboardFocusClassName), t.blur());
        }, e.prototype.$blurAnnotation = function(e) {
            var t = this.$getAnnotation(e);
            t.classList.remove(this.editor.renderer.keyboardFocusClassName), t.blur();
        }, e.prototype.$moveFoldWidgetUp = function() {
            var e = this.activeRowIndex;
            while(e > 0){
                e--;
                if (this.$isFoldWidgetVisible(e) || this.$isCustomWidgetVisible(e)) {
                    this.$blurFoldWidget(this.activeRowIndex), this.$blurCustomWidget(this.activeRowIndex), this.activeRowIndex = e, this.$isFoldWidgetVisible(e) ? this.$focusFoldWidget(this.activeRowIndex) : this.$focusCustomWidget(this.activeRowIndex);
                    return;
                }
            }
            return;
        }, e.prototype.$moveFoldWidgetDown = function() {
            var e = this.activeRowIndex;
            while(e < this.lines.getLength() - 1){
                e++;
                if (this.$isFoldWidgetVisible(e) || this.$isCustomWidgetVisible(e)) {
                    this.$blurFoldWidget(this.activeRowIndex), this.$blurCustomWidget(this.activeRowIndex), this.activeRowIndex = e, this.$isFoldWidgetVisible(e) ? this.$focusFoldWidget(this.activeRowIndex) : this.$focusCustomWidget(this.activeRowIndex);
                    return;
                }
            }
            return;
        }, e.prototype.$moveAnnotationUp = function() {
            var e = this.activeRowIndex;
            while(e > 0){
                e--;
                if (this.$isAnnotationVisible(e)) {
                    this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = e, this.$focusAnnotation(this.activeRowIndex);
                    return;
                }
            }
            return;
        }, e.prototype.$moveAnnotationDown = function() {
            var e = this.activeRowIndex;
            while(e < this.lines.getLength() - 1){
                e++;
                if (this.$isAnnotationVisible(e)) {
                    this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = e, this.$focusAnnotation(this.activeRowIndex);
                    return;
                }
            }
            return;
        }, e.prototype.$findClosestNumber = function(e, t, n) {
            return e === null ? t : t === null ? e : Math.abs(n - e) <= Math.abs(n - t) ? e : t;
        }, e.prototype.$switchLane = function(e) {
            switch(e){
                case "annotation":
                    if (this.activeLane === "annotation") break;
                    var t = this.$findNearestAnnotation(this.activeRowIndex);
                    if (t == null) break;
                    this.activeLane = "annotation", this.$blurFoldWidget(this.activeRowIndex), this.$blurCustomWidget(this.activeRowIndex), this.activeRowIndex = t, this.$focusAnnotation(this.activeRowIndex);
                    break;
                case "fold":
                    if (this.activeLane === "fold") break;
                    var n = this.$findNearestFoldLaneWidget(this.activeRowIndex);
                    if (n === null) break;
                    this.activeLane = "fold", this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = n, this.$isCustomWidgetVisible(n) ? this.$focusCustomWidget(this.activeRowIndex) : this.$focusFoldWidget(this.activeRowIndex);
            }
            return;
        }, e.prototype.$rowIndexToRow = function(e) {
            var t = this.lines.get(e);
            return t ? t.row : null;
        }, e.prototype.$rowToRowIndex = function(e) {
            for(var t = 0; t < this.lines.getLength(); t++){
                var n = this.lines.get(t);
                if (n.row == e) return t;
            }
            return null;
        }, e;
    }();
    t.GutterKeyboardHandler = s;
    var o = function() {
        function e(e, t) {
            this.gutterKeyboardHandler = t, this.domEvent = e;
        }
        return e.prototype.getKey = function() {
            return r.keyCodeToString(this.domEvent.keyCode);
        }, e.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
        }, e.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
        }, e.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
        }, e;
    }();
    t.GutterKeyboardEvent = o;
}), ace.define("ace/editor", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/lib/useragent",
    "ace/keyboard/textinput",
    "ace/mouse/mouse_handler",
    "ace/mouse/fold_handler",
    "ace/keyboard/keybinding",
    "ace/edit_session",
    "ace/search",
    "ace/range",
    "ace/lib/event_emitter",
    "ace/commands/command_manager",
    "ace/commands/default_commands",
    "ace/config",
    "ace/token_iterator",
    "ace/keyboard/gutter_handler",
    "ace/config",
    "ace/clipboard",
    "ace/lib/keys",
    "ace/lib/event",
    "ace/tooltip"
], function(e, t, n) {
    "use strict";
    var r = this && this.__values || function(e) {
        var t = typeof Symbol == "function" && Symbol.iterator, n = t && e[t], r = 0;
        if (n) return n.call(e);
        if (e && typeof e.length == "number") return {
            next: function() {
                return e && r >= e.length && (e = void 0), {
                    value: e && e[r++],
                    done: !e
                };
            }
        };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, i = e("./lib/oop"), s = e("./lib/dom"), o = e("./lib/lang"), u = e("./lib/useragent"), a = e("./keyboard/textinput").TextInput, f = e("./mouse/mouse_handler").MouseHandler, l = e("./mouse/fold_handler").FoldHandler, c = e("./keyboard/keybinding").KeyBinding, h = e("./edit_session").EditSession, p = e("./search").Search, d = e("./range").Range, v = e("./lib/event_emitter").EventEmitter, m = e("./commands/command_manager").CommandManager, g = e("./commands/default_commands").commands, y = e("./config"), b = e("./token_iterator").TokenIterator, w = e("./keyboard/gutter_handler").GutterKeyboardHandler, E = e("./config").nls, S = e("./clipboard"), x = e("./lib/keys"), T = e("./lib/event"), N = e("./tooltip").HoverTooltip, C = function() {
        function e(t, n, r) {
            this.id = "editor" + ++e.$uid, this.session, this.$toDestroy = [];
            var i = t.getContainerElement();
            this.container = i, this.renderer = t, this.commands = new m(u.isMac ? "mac" : "win", g), typeof document == "object" && (this.textInput = new a(t.getTextAreaContainer(), this), this.renderer.textarea = this.textInput.getElement(), this.$mouseHandler = new f(this), new l(this)), this.keyBinding = new c(this), this.$search = (new p).set({
                wrap: !0
            }), this.$historyTracker = this.$historyTracker.bind(this), this.commands.on("exec", this.$historyTracker), this.$initOperationListeners(), this._$emitInputEvent = o.delayedCall((function() {
                this._signal("input", {}), this.session && !this.session.destroyed && this.session.bgTokenizer.scheduleStart();
            }).bind(this)), this.on("change", function(e, t) {
                t._$emitInputEvent.schedule(31);
            }), this.setSession(n || r && r.session || new h("")), y.resetOptions(this), r && this.setOptions(r), y._signal("editor", this);
        }
        return e.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), !0), this.commands.on("afterExec", this.endOperation.bind(this), !0);
        }, e.prototype.startOperation = function(e) {
            this.session.startOperation(e);
        }, e.prototype.endOperation = function(e) {
            this.session.endOperation(e);
        }, e.prototype.onStartOperation = function(e) {
            this.curOp = this.session.curOp, this.curOp.scrollTop = this.renderer.scrollTop, this.prevOp = this.session.prevOp, e || (this.previousCommand = null);
        }, e.prototype.onEndOperation = function(e) {
            if (this.curOp && this.session) {
                if (e && e.returnValue === !1) {
                    this.curOp = null;
                    return;
                }
                this._signal("beforeEndOperation");
                if (!this.curOp) return;
                var t = this.curOp.command, n = t && t.scrollIntoView;
                if (n) {
                    switch(n){
                        case "center-animate":
                            n = "animate";
                        case "center":
                            this.renderer.scrollCursorIntoView(null, .5);
                            break;
                        case "animate":
                        case "cursor":
                            this.renderer.scrollCursorIntoView();
                            break;
                        case "selectionPart":
                            var r = this.selection.getRange(), i = this.renderer.layerConfig;
                            (r.start.row >= i.lastRow || r.end.row <= i.firstRow) && this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                            break;
                        default:
                    }
                    n == "animate" && this.renderer.animateScrolling(this.curOp.scrollTop);
                }
                this.$lastSel = this.session.selection.toJSON(), this.prevOp = this.curOp, this.curOp = null;
            }
        }, e.prototype.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas) return;
            var t = this.prevOp, n = this.$mergeableCommands, r = t.command && e.command.name == t.command.name;
            if (e.command.name == "insertstring") {
                var i = e.args;
                this.mergeNextCommand === undefined && (this.mergeNextCommand = !0), r = r && this.mergeNextCommand && (!/\s/.test(i) || /\s/.test(t.args)), this.mergeNextCommand = !0;
            } else r = r && n.indexOf(e.command.name) !== -1;
            this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3 && (r = !1), r ? this.session.mergeUndoDeltas = !0 : n.indexOf(e.command.name) !== -1 && (this.sequenceStartTime = Date.now());
        }, e.prototype.setKeyboardHandler = function(e, t) {
            if (e && typeof e == "string" && e != "ace") {
                this.$keybindingId = e;
                var n = this;
                y.loadModule([
                    "keybinding",
                    e
                ], function(r) {
                    n.$keybindingId == e && n.keyBinding.setKeyboardHandler(r && r.handler), t && t();
                });
            } else this.$keybindingId = null, this.keyBinding.setKeyboardHandler(e), t && t();
        }, e.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
        }, e.prototype.setSession = function(e) {
            if (this.session == e) return;
            this.curOp && this.endOperation(), this.curOp = {};
            var t = this.session;
            if (t) {
                this.session.off("change", this.$onDocumentChange), this.session.off("changeMode", this.$onChangeMode), this.session.off("tokenizerUpdate", this.$onTokenizerUpdate), this.session.off("changeTabSize", this.$onChangeTabSize), this.session.off("changeWrapLimit", this.$onChangeWrapLimit), this.session.off("changeWrapMode", this.$onChangeWrapMode), this.session.off("changeFold", this.$onChangeFold), this.session.off("changeFrontMarker", this.$onChangeFrontMarker), this.session.off("changeBackMarker", this.$onChangeBackMarker), this.session.off("changeBreakpoint", this.$onChangeBreakpoint), this.session.off("changeAnnotation", this.$onChangeAnnotation), this.session.off("changeOverwrite", this.$onCursorChange), this.session.off("changeScrollTop", this.$onScrollTopChange), this.session.off("changeScrollLeft", this.$onScrollLeftChange), this.session.off("startOperation", this.$onStartOperation), this.session.off("endOperation", this.$onEndOperation);
                var n = this.session.getSelection();
                n.off("changeCursor", this.$onCursorChange), n.off("changeSelection", this.$onSelectionChange);
            }
            this.session = e, e ? (this.$onDocumentChange = this.onDocumentChange.bind(this), e.on("change", this.$onDocumentChange), this.renderer.setSession(e), this.$onChangeMode = this.onChangeMode.bind(this), e.on("changeMode", this.$onChangeMode), this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this), e.on("tokenizerUpdate", this.$onTokenizerUpdate), this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer), e.on("changeTabSize", this.$onChangeTabSize), this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this), e.on("changeWrapLimit", this.$onChangeWrapLimit), this.$onChangeWrapMode = this.onChangeWrapMode.bind(this), e.on("changeWrapMode", this.$onChangeWrapMode), this.$onChangeFold = this.onChangeFold.bind(this), e.on("changeFold", this.$onChangeFold), this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this), this.session.on("changeFrontMarker", this.$onChangeFrontMarker), this.$onChangeBackMarker = this.onChangeBackMarker.bind(this), this.session.on("changeBackMarker", this.$onChangeBackMarker), this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this), this.session.on("changeBreakpoint", this.$onChangeBreakpoint), this.$onChangeAnnotation = this.onChangeAnnotation.bind(this), this.session.on("changeAnnotation", this.$onChangeAnnotation), this.$onCursorChange = this.onCursorChange.bind(this), this.session.on("changeOverwrite", this.$onCursorChange), this.$onScrollTopChange = this.onScrollTopChange.bind(this), this.session.on("changeScrollTop", this.$onScrollTopChange), this.$onScrollLeftChange = this.onScrollLeftChange.bind(this), this.session.on("changeScrollLeft", this.$onScrollLeftChange), this.selection = e.getSelection(), this.selection.on("changeCursor", this.$onCursorChange), this.$onSelectionChange = this.onSelectionChange.bind(this), this.selection.on("changeSelection", this.$onSelectionChange), this.$onStartOperation = this.onStartOperation.bind(this), this.session.on("startOperation", this.$onStartOperation), this.$onEndOperation = this.onEndOperation.bind(this), this.session.on("endOperation", this.$onEndOperation), this.onChangeMode(), this.onCursorChange(), this.onScrollTopChange(), this.onScrollLeftChange(), this.onSelectionChange(), this.onChangeFrontMarker(), this.onChangeBackMarker(), this.onChangeBreakpoint(), this.onChangeAnnotation(), this.session.getUseWrapMode() && this.renderer.adjustWrapLimit(), this.renderer.updateFull()) : (this.selection = null, this.renderer.setSession(e)), this._signal("changeSession", {
                session: e,
                oldSession: t
            }), this.curOp = null, t && t._signal("changeEditor", {
                oldEditor: this
            }), t && (t.$editor = null), e && e._signal("changeEditor", {
                editor: this
            }), e && (e.$editor = this), e && !e.destroyed && e.bgTokenizer.scheduleStart();
        }, e.prototype.getSession = function() {
            return this.session;
        }, e.prototype.setValue = function(e, t) {
            return this.session.doc.setValue(e), t ? t == 1 ? this.navigateFileEnd() : t == -1 && this.navigateFileStart() : this.selectAll(), e;
        }, e.prototype.getValue = function() {
            return this.session.getValue();
        }, e.prototype.getSelection = function() {
            return this.selection;
        }, e.prototype.resize = function(e) {
            this.renderer.onResize(e);
        }, e.prototype.setTheme = function(e, t) {
            this.renderer.setTheme(e, t);
        }, e.prototype.getTheme = function() {
            return this.renderer.getTheme();
        }, e.prototype.setStyle = function(e, t) {
            this.renderer.setStyle(e, t);
        }, e.prototype.unsetStyle = function(e) {
            this.renderer.unsetStyle(e);
        }, e.prototype.getFontSize = function() {
            return this.getOption("fontSize") || s.computedStyle(this.container).fontSize;
        }, e.prototype.setFontSize = function(e) {
            this.setOption("fontSize", e);
        }, e.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) return;
            var e = this;
            this.$highlightPending = !0, setTimeout(function() {
                e.$highlightPending = !1;
                var t = e.session;
                if (!t || t.destroyed) return;
                t.$bracketHighlight && (t.$bracketHighlight.markerIds.forEach(function(e) {
                    t.removeMarker(e);
                }), t.$bracketHighlight = null);
                var n = e.getCursorPosition(), r = e.getKeyboardHandler(), i = r && r.$getDirectionForHighlight && r.$getDirectionForHighlight(e), s = t.getMatchingBracketRanges(n, i);
                if (!s) {
                    var o = new b(t, n.row, n.column), u = o.getCurrentToken();
                    if (u && /\b(?:tag-open|tag-name)/.test(u.type)) {
                        var a = t.getMatchingTags(n);
                        a && (s = [
                            a.openTagName.isEmpty() ? a.openTag : a.openTagName,
                            a.closeTagName.isEmpty() ? a.closeTag : a.closeTagName
                        ]);
                    }
                }
                !s && t.$mode.getMatching && (s = t.$mode.getMatching(e.session));
                if (!s) {
                    e.getHighlightIndentGuides() && e.renderer.$textLayer.$highlightIndentGuide();
                    return;
                }
                var f = "ace_bracket";
                Array.isArray(s) ? s.length == 1 && (f = "ace_error_bracket") : s = [
                    s
                ], s.length == 2 && (d.comparePoints(s[0].end, s[1].start) == 0 ? s = [
                    d.fromPoints(s[0].start, s[1].end)
                ] : d.comparePoints(s[0].start, s[1].end) == 0 && (s = [
                    d.fromPoints(s[1].start, s[0].end)
                ])), t.$bracketHighlight = {
                    ranges: s,
                    markerIds: s.map(function(e) {
                        return t.addMarker(e, f, "text");
                    })
                }, e.getHighlightIndentGuides() && e.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
        }, e.prototype.focus = function() {
            this.textInput.focus();
        }, e.prototype.isFocused = function() {
            return this.textInput.isFocused();
        }, e.prototype.blur = function() {
            this.textInput.blur();
        }, e.prototype.onFocus = function(e) {
            if (this.$isFocused) return;
            this.$isFocused = !0, this.renderer.showCursor(), this.renderer.visualizeFocus(), this._emit("focus", e);
        }, e.prototype.onBlur = function(e) {
            if (!this.$isFocused) return;
            this.$isFocused = !1, this.renderer.hideCursor(), this.renderer.visualizeBlur(), this._emit("blur", e);
        }, e.prototype.$cursorChange = function() {
            this.renderer.updateCursor(), this.$highlightBrackets(), this.$updateHighlightActiveLine();
        }, e.prototype.onDocumentChange = function(e) {
            var t = this.session.$useWrapMode, n = e.start.row == e.end.row ? e.end.row : Infinity;
            this.renderer.updateLines(e.start.row, n, t), this._signal("change", e), this.$cursorChange();
        }, e.prototype.onTokenizerUpdate = function(e) {
            var t = e.data;
            this.renderer.updateLines(t.first, t.last);
        }, e.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
        }, e.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
        }, e.prototype.onCursorChange = function() {
            this.$cursorChange(), this._signal("changeSelection");
        }, e.prototype.$updateHighlightActiveLine = function() {
            var e = this.getSession(), t;
            if (this.$highlightActiveLine) {
                if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) t = this.getCursorPosition();
                this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty() && (t = !1), this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1) && (t = !1);
            }
            if (e.$highlightLineMarker && !t) e.removeMarker(e.$highlightLineMarker.id), e.$highlightLineMarker = null;
            else if (!e.$highlightLineMarker && t) {
                var n = new d(t.row, t.column, t.row, Infinity);
                n.id = e.addMarker(n, "ace_active-line", "screenLine"), e.$highlightLineMarker = n;
            } else t && (e.$highlightLineMarker.start.row = t.row, e.$highlightLineMarker.end.row = t.row, e.$highlightLineMarker.start.column = t.column, e._signal("changeBackMarker"));
        }, e.prototype.onSelectionChange = function(e) {
            var t = this.session;
            t.$selectionMarker && t.removeMarker(t.$selectionMarker), t.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
                var n = this.selection.getRange(), r = this.getSelectionStyle();
                t.$selectionMarker = t.addMarker(n, "ace_selection", r);
            } else this.$updateHighlightActiveLine();
            var i = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(i), this._signal("changeSelection");
        }, e.prototype.$getSelectionHighLightRegexp = function() {
            var e = this.session, t = this.getSelectionRange();
            if (t.isEmpty() || t.isMultiLine()) return;
            var n = t.start.column, r = t.end.column, i = e.getLine(t.start.row), s = i.substring(n, r);
            if (s.length > 5e3 || !/[\w\d]/.test(s)) return;
            var o = this.$search.$assembleRegExp({
                wholeWord: !0,
                caseSensitive: !0,
                needle: s
            }), u = i.substring(n - 1, r + 1);
            if (!o.test(u)) return;
            return o;
        }, e.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
        }, e.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
        }, e.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
        }, e.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
        }, e.prototype.onChangeMode = function(e) {
            this.renderer.updateText(), this._emit("changeMode", e);
        }, e.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
        }, e.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(!0);
        }, e.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine(), this.renderer.updateFull();
        }, e.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
        }, e.prototype.getCopyText = function() {
            var e = this.getSelectedText(), t = this.session.doc.getNewLineCharacter(), n = !1;
            if (!e && this.$copyWithEmptySelection) {
                n = !0;
                var r = this.selection.getAllRanges();
                for(var i = 0; i < r.length; i++){
                    var s = r[i];
                    if (i && r[i - 1].start.row == s.start.row) continue;
                    e += this.session.getLine(s.start.row) + t;
                }
            }
            var o = {
                text: e
            };
            return this._signal("copy", o), S.lineMode = n ? o.text : !1, o.text;
        }, e.prototype.onCopy = function() {
            this.commands.exec("copy", this);
        }, e.prototype.onCut = function() {
            this.commands.exec("cut", this);
        }, e.prototype.onPaste = function(e, t) {
            var n = {
                text: e,
                event: t
            };
            this.commands.exec("paste", this, n);
        }, e.prototype.$handlePaste = function(e) {
            typeof e == "string" && (e = {
                text: e
            }), this._signal("paste", e);
            var t = e.text, n = t === S.lineMode, r = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) n ? r.insert({
                row: this.selection.lead.row,
                column: 0
            }, t) : this.insert(t);
            else if (n) this.selection.rangeList.ranges.forEach(function(e) {
                r.insert({
                    row: e.start.row,
                    column: 0
                }, t);
            });
            else {
                var i = t.split(/\r\n|\r|\n/), s = this.selection.rangeList.ranges, o = i.length == 2 && (!i[0] || !i[1]);
                if (i.length != s.length || o) return this.commands.exec("insertstring", this, t);
                for(var u = s.length; u--;){
                    var a = s[u];
                    a.isEmpty() || r.remove(a), r.insert(a.start, i[u]);
                }
            }
        }, e.prototype.execCommand = function(e, t) {
            return this.commands.exec(e, this, t);
        }, e.prototype.insert = function(e, t) {
            var n = this.session, r = n.getMode(), i = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !t) {
                var s = r.transformAction(n.getState(i.row), "insertion", this, n, e);
                s && (e !== s.text && (this.inVirtualSelectionMode || (this.session.mergeUndoDeltas = !1, this.mergeNextCommand = !1)), e = s.text);
            }
            e == "	" && (e = this.session.getTabString());
            if (!this.selection.isEmpty()) {
                var o = this.getSelectionRange();
                i = this.session.remove(o), this.clearSelection();
            } else if (this.session.getOverwrite() && e.indexOf("\n") == -1) {
                var o = d.fromPoints(i, i);
                o.end.column += e.length, this.session.remove(o);
            }
            if (e == "\n" || e == "\r\n") {
                var u = n.getLine(i.row);
                if (i.column > u.search(/\S|$/)) {
                    var a = u.substr(i.column).search(/\S|$/);
                    n.doc.removeInLine(i.row, i.column, i.column + a);
                }
            }
            this.clearSelection();
            var f = i.column, l = n.getState(i.row), u = n.getLine(i.row), c = r.checkOutdent(l, u, e);
            n.insert(i, e), s && s.selection && (s.selection.length == 2 ? this.selection.setSelectionRange(new d(i.row, f + s.selection[0], i.row, f + s.selection[1])) : this.selection.setSelectionRange(new d(i.row + s.selection[0], s.selection[1], i.row + s.selection[2], s.selection[3])));
            if (this.$enableAutoIndent) {
                if (n.getDocument().isNewLine(e)) {
                    var h = r.getNextLineIndent(l, u.slice(0, i.column), n.getTabString());
                    n.insert({
                        row: i.row + 1,
                        column: 0
                    }, h);
                }
                c && r.autoOutdent(l, n, i.row);
            }
        }, e.prototype.autoIndent = function() {
            var e = this.session, t = e.getMode(), n = this.selection.isEmpty() ? [
                new d(0, 0, e.doc.getLength() - 1, 0)
            ] : this.selection.getAllRanges(), r = "", i = "", s = "", o = e.getTabString();
            for(var u = 0; u < n.length; u++){
                var a = n[u].start.row, f = n[u].end.row;
                for(var l = a; l <= f; l++){
                    l > 0 && (r = e.getState(l - 1), i = e.getLine(l - 1), s = t.getNextLineIndent(r, i, o));
                    var c = e.getLine(l), h = t.$getIndent(c);
                    if (s !== h) {
                        if (h.length > 0) {
                            var p = new d(l, 0, l, h.length);
                            e.remove(p);
                        }
                        s.length > 0 && e.insert({
                            row: l,
                            column: 0
                        }, s);
                    }
                    t.autoOutdent(r, e, l);
                }
            }
        }, e.prototype.onTextInput = function(e, t) {
            if (!t) return this.keyBinding.onTextInput(e);
            this.startOperation({
                command: {
                    name: "insertstring"
                }
            });
            var n = this.applyComposition.bind(this, e, t);
            this.selection.rangeCount ? this.forEachSelection(n) : n(), this.endOperation();
        }, e.prototype.applyComposition = function(e, t) {
            if (t.extendLeft || t.extendRight) {
                var n = this.selection.getRange();
                n.start.column -= t.extendLeft, n.end.column += t.extendRight, n.start.column < 0 && (n.start.row--, n.start.column += this.session.getLine(n.start.row).length + 1), this.selection.setRange(n), !e && !n.isEmpty() && this.remove();
            }
            (e || !this.selection.isEmpty()) && this.insert(e, !0);
            if (t.restoreStart || t.restoreEnd) {
                var n = this.selection.getRange();
                n.start.column -= t.restoreStart, n.end.column -= t.restoreEnd, this.selection.setRange(n);
            }
        }, e.prototype.onCommandKey = function(e, t, n) {
            return this.keyBinding.onCommandKey(e, t, n);
        }, e.prototype.setOverwrite = function(e) {
            this.session.setOverwrite(e);
        }, e.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
        }, e.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
        }, e.prototype.setScrollSpeed = function(e) {
            this.setOption("scrollSpeed", e);
        }, e.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
        }, e.prototype.setDragDelay = function(e) {
            this.setOption("dragDelay", e);
        }, e.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
        }, e.prototype.setSelectionStyle = function(e) {
            this.setOption("selectionStyle", e);
        }, e.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
        }, e.prototype.setHighlightActiveLine = function(e) {
            this.setOption("highlightActiveLine", e);
        }, e.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
        }, e.prototype.setHighlightGutterLine = function(e) {
            this.setOption("highlightGutterLine", e);
        }, e.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        }, e.prototype.setHighlightSelectedWord = function(e) {
            this.setOption("highlightSelectedWord", e);
        }, e.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
        }, e.prototype.setAnimatedScroll = function(e) {
            this.renderer.setAnimatedScroll(e);
        }, e.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
        }, e.prototype.setShowInvisibles = function(e) {
            this.renderer.setShowInvisibles(e);
        }, e.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
        }, e.prototype.setDisplayIndentGuides = function(e) {
            this.renderer.setDisplayIndentGuides(e);
        }, e.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
        }, e.prototype.setHighlightIndentGuides = function(e) {
            this.renderer.setHighlightIndentGuides(e);
        }, e.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
        }, e.prototype.setShowPrintMargin = function(e) {
            this.renderer.setShowPrintMargin(e);
        }, e.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
        }, e.prototype.setPrintMarginColumn = function(e) {
            this.renderer.setPrintMarginColumn(e);
        }, e.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
        }, e.prototype.setReadOnly = function(e) {
            this.setOption("readOnly", e);
        }, e.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
        }, e.prototype.setBehavioursEnabled = function(e) {
            this.setOption("behavioursEnabled", e);
        }, e.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
        }, e.prototype.setWrapBehavioursEnabled = function(e) {
            this.setOption("wrapBehavioursEnabled", e);
        }, e.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
        }, e.prototype.setShowFoldWidgets = function(e) {
            this.setOption("showFoldWidgets", e);
        }, e.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
        }, e.prototype.setFadeFoldWidgets = function(e) {
            this.setOption("fadeFoldWidgets", e);
        }, e.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        }, e.prototype.remove = function(e) {
            this.selection.isEmpty() && (e == "left" ? this.selection.selectLeft() : this.selection.selectRight());
            var t = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
                var n = this.session, r = n.getState(t.start.row), i = n.getMode().transformAction(r, "deletion", this, n, t);
                if (t.end.column === 0) {
                    var s = n.getTextRange(t);
                    if (s[s.length - 1] == "\n") {
                        var o = n.getLine(t.end.row);
                        /^\s+$/.test(o) && (t.end.column = o.length);
                    }
                }
                i && (t = i);
            }
            this.session.remove(t), this.clearSelection();
        }, e.prototype.removeWordRight = function() {
            this.selection.isEmpty() && this.selection.selectWordRight(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, e.prototype.removeWordLeft = function() {
            this.selection.isEmpty() && this.selection.selectWordLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, e.prototype.removeToLineStart = function() {
            this.selection.isEmpty() && this.selection.selectLineStart(), this.selection.isEmpty() && this.selection.selectLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, e.prototype.removeToLineEnd = function() {
            this.selection.isEmpty() && this.selection.selectLineEnd();
            var e = this.getSelectionRange();
            e.start.column == e.end.column && e.start.row == e.end.row && (e.end.column = 0, e.end.row++), this.session.remove(e), this.clearSelection();
        }, e.prototype.splitLine = function() {
            this.selection.isEmpty() || (this.session.remove(this.getSelectionRange()), this.clearSelection());
            var e = this.getCursorPosition();
            this.insert("\n"), this.moveCursorToPosition(e);
        }, e.prototype.setGhostText = function(e, t) {
            this.renderer.setGhostText(e, t);
        }, e.prototype.removeGhostText = function() {
            this.renderer.removeGhostText();
        }, e.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) return;
            var e = this.getCursorPosition(), t = e.column;
            if (t === 0) return;
            var n = this.session.getLine(e.row), r, i;
            t < n.length ? (r = n.charAt(t) + n.charAt(t - 1), i = new d(e.row, t - 1, e.row, t + 1)) : (r = n.charAt(t - 1) + n.charAt(t - 2), i = new d(e.row, t - 2, e.row, t)), this.session.replace(i, r), this.session.selection.moveToPosition(i.end);
        }, e.prototype.toLowerCase = function() {
            var e = this.getSelectionRange();
            this.selection.isEmpty() && this.selection.selectWord();
            var t = this.getSelectionRange(), n = this.session.getTextRange(t);
            this.session.replace(t, n.toLowerCase()), this.selection.setSelectionRange(e);
        }, e.prototype.toUpperCase = function() {
            var e = this.getSelectionRange();
            this.selection.isEmpty() && this.selection.selectWord();
            var t = this.getSelectionRange(), n = this.session.getTextRange(t);
            this.session.replace(t, n.toUpperCase()), this.selection.setSelectionRange(e);
        }, e.prototype.indent = function() {
            var e = this.session, t = this.getSelectionRange();
            if (t.start.row < t.end.row) {
                var n = this.$getSelectedRows();
                e.indentRows(n.first, n.last, "	");
                return;
            }
            if (t.start.column < t.end.column) {
                var r = e.getTextRange(t);
                if (!/^\s+$/.test(r)) {
                    var n = this.$getSelectedRows();
                    e.indentRows(n.first, n.last, "	");
                    return;
                }
            }
            var i = e.getLine(t.start.row), s = t.start, u = e.getTabSize(), a = e.documentToScreenColumn(s.row, s.column);
            if (this.session.getUseSoftTabs()) var f = u - a % u, l = o.stringRepeat(" ", f);
            else {
                var f = a % u;
                while(i[t.start.column - 1] == " " && f)t.start.column--, f--;
                this.selection.setSelectionRange(t), l = "	";
            }
            return this.insert(l);
        }, e.prototype.blockIndent = function() {
            var e = this.$getSelectedRows();
            this.session.indentRows(e.first, e.last, "	");
        }, e.prototype.blockOutdent = function() {
            var e = this.session.getSelection();
            this.session.outdentRows(e.getRange());
        }, e.prototype.sortLines = function() {
            var e = this.$getSelectedRows(), t = this.session, n = [];
            for(var r = e.first; r <= e.last; r++)n.push(t.getLine(r));
            n.sort(function(e, t) {
                return e.toLowerCase() < t.toLowerCase() ? -1 : e.toLowerCase() > t.toLowerCase() ? 1 : 0;
            });
            var i = new d(0, 0, 0, 0);
            for(var r = e.first; r <= e.last; r++){
                var s = t.getLine(r);
                i.start.row = r, i.end.row = r, i.end.column = s.length, t.replace(i, n[r - e.first]);
            }
        }, e.prototype.toggleCommentLines = function() {
            var e = this.session.getState(this.getCursorPosition().row), t = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(e, this.session, t.first, t.last);
        }, e.prototype.toggleBlockComment = function() {
            var e = this.getCursorPosition(), t = this.session.getState(e.row), n = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(t, this.session, n, e);
        }, e.prototype.getNumberAt = function(e, t) {
            var n = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            n.lastIndex = 0;
            var r = this.session.getLine(e);
            while(n.lastIndex < t){
                var i = n.exec(r);
                if (i.index <= t && i.index + i[0].length >= t) {
                    var s = {
                        value: i[0],
                        start: i.index,
                        end: i.index + i[0].length
                    };
                    return s;
                }
            }
            return null;
        }, e.prototype.modifyNumber = function(e) {
            var t = this.selection.getCursor().row, n = this.selection.getCursor().column, r = new d(t, n - 1, t, n), i = this.session.getTextRange(r);
            if (!isNaN(parseFloat(i)) && isFinite(i)) {
                var s = this.getNumberAt(t, n);
                if (s) {
                    var o = s.value.indexOf(".") >= 0 ? s.start + s.value.indexOf(".") + 1 : s.end, u = s.start + s.value.length - o, a = parseFloat(s.value);
                    a *= Math.pow(10, u), o !== s.end && n < o ? e *= Math.pow(10, s.end - n - 1) : e *= Math.pow(10, s.end - n), a += e, a /= Math.pow(10, u);
                    var f = a.toFixed(u), l = new d(t, s.start, t, s.end);
                    this.session.replace(l, f), this.moveCursorTo(t, Math.max(s.start + 1, n + f.length - s.value.length));
                }
            } else this.toggleWord();
        }, e.prototype.toggleWord = function() {
            var e = this.selection.getCursor().row, t = this.selection.getCursor().column;
            this.selection.selectWord();
            var n = this.getSelectedText(), r = this.selection.getWordRange().start.column, i = n.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/), s = t - r - 1;
            s < 0 && (s = 0);
            var u = 0, a = 0, f = this;
            n.match(/[A-Za-z0-9_]+/) && i.forEach(function(t, i) {
                a = u + t.length, s >= u && s <= a && (n = t, f.selection.clearSelection(), f.moveCursorTo(e, u + r), f.selection.selectTo(e, a + r)), u = a;
            });
            var l = this.$toggleWordPairs, c;
            for(var h = 0; h < l.length; h++){
                var p = l[h];
                for(var d = 0; d <= 1; d++){
                    var v = +!d, m = n.match(new RegExp("^\\s?_?(" + o.escapeRegExp(p[d]) + ")\\s?$", "i"));
                    if (m) {
                        var g = n.match(new RegExp("([_]|^|\\s)(" + o.escapeRegExp(m[1]) + ")($|\\s)", "g"));
                        g && (c = n.replace(new RegExp(o.escapeRegExp(p[d]), "i"), function(e) {
                            var t = p[v];
                            return e.toUpperCase() == e ? t = t.toUpperCase() : e.charAt(0).toUpperCase() == e.charAt(0) && (t = t.substr(0, 0) + p[v].charAt(0).toUpperCase() + t.substr(1)), t;
                        }), this.insert(c), c = "");
                    }
                }
            }
        }, e.prototype.findLinkAt = function(e, t) {
            var n, i, s = this.session.getLine(e), o = s.split(/((?:https?|ftp):\/\/[\S]+)/), u = t;
            u < 0 && (u = 0);
            var a = 0, f = 0, l;
            try {
                for(var c = r(o), h = c.next(); !h.done; h = c.next()){
                    var p = h.value;
                    f = a + p.length;
                    if (u >= a && u <= f && p.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                        l = p.replace(/[\s:.,'";}\]]+$/, "");
                        break;
                    }
                    a = f;
                }
            } catch (d) {
                n = {
                    error: d
                };
            } finally{
                try {
                    h && !h.done && (i = c.return) && i.call(c);
                } finally{
                    if (n) throw n.error;
                }
            }
            return l;
        }, e.prototype.openLink = function() {
            var e = this.selection.getCursor(), t = this.findLinkAt(e.row, e.column);
            return t && window.open(t, "_blank"), t != null;
        }, e.prototype.removeLines = function() {
            var e = this.$getSelectedRows();
            this.session.removeFullLines(e.first, e.last), this.clearSelection();
        }, e.prototype.duplicateSelection = function() {
            var e = this.selection, t = this.session, n = e.getRange(), r = e.isBackwards();
            if (n.isEmpty()) {
                var i = n.start.row;
                t.duplicateLines(i, i);
            } else {
                var s = r ? n.start : n.end, o = t.insert(s, t.getTextRange(n));
                n.start = s, n.end = o, e.setSelectionRange(n, r);
            }
        }, e.prototype.moveLinesDown = function() {
            this.$moveLines(1, !1);
        }, e.prototype.moveLinesUp = function() {
            this.$moveLines(-1, !1);
        }, e.prototype.moveText = function(e, t, n) {
            return this.session.moveText(e, t, n);
        }, e.prototype.copyLinesUp = function() {
            this.$moveLines(-1, !0);
        }, e.prototype.copyLinesDown = function() {
            this.$moveLines(1, !0);
        }, e.prototype.$moveLines = function(e, t) {
            var n, r, i = this.selection;
            if (!i.inMultiSelectMode || this.inVirtualSelectionMode) {
                var s = i.toOrientedRange();
                n = this.$getSelectedRows(s), r = this.session.$moveLines(n.first, n.last, t ? 0 : e), t && e == -1 && (r = 0), s.moveBy(r, 0), i.fromOrientedRange(s);
            } else {
                var o = i.rangeList.ranges;
                i.rangeList.detach(this.session), this.inVirtualSelectionMode = !0;
                var u = 0, a = 0, f = o.length;
                for(var l = 0; l < f; l++){
                    var c = l;
                    o[l].moveBy(u, 0), n = this.$getSelectedRows(o[l]);
                    var h = n.first, p = n.last;
                    while(++l < f){
                        a && o[l].moveBy(a, 0);
                        var d = this.$getSelectedRows(o[l]);
                        if (t && d.first != p) break;
                        if (!t && d.first > p + 1) break;
                        p = d.last;
                    }
                    l--, u = this.session.$moveLines(h, p, t ? 0 : e), t && e == -1 && (c = l + 1);
                    while(c <= l)o[c].moveBy(u, 0), c++;
                    t || (u = 0), a += u;
                }
                i.fromOrientedRange(i.ranges[0]), i.rangeList.attach(this.session), this.inVirtualSelectionMode = !1;
            }
        }, e.prototype.$getSelectedRows = function(e) {
            return e = (e || this.getSelectionRange()).collapseRows(), {
                first: this.session.getRowFoldStart(e.start.row),
                last: this.session.getRowFoldEnd(e.end.row)
            };
        }, e.prototype.onCompositionStart = function(e) {
            this.renderer.showComposition(e);
        }, e.prototype.onCompositionUpdate = function(e) {
            this.renderer.setCompositionText(e);
        }, e.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
        }, e.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
        }, e.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
        }, e.prototype.isRowVisible = function(e) {
            return e >= this.getFirstVisibleRow() && e <= this.getLastVisibleRow();
        }, e.prototype.isRowFullyVisible = function(e) {
            return e >= this.renderer.getFirstFullyVisibleRow() && e <= this.renderer.getLastFullyVisibleRow();
        }, e.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        }, e.prototype.$moveByPage = function(e, t) {
            var n = this.renderer, r = this.renderer.layerConfig, i = e * Math.floor(r.height / r.lineHeight);
            t === !0 ? this.selection.$moveSelection(function() {
                this.moveCursorBy(i, 0);
            }) : t === !1 && (this.selection.moveCursorBy(i, 0), this.selection.clearSelection());
            var s = n.scrollTop;
            n.scrollBy(0, i * r.lineHeight), t != null && n.scrollCursorIntoView(null, .5), n.animateScrolling(s);
        }, e.prototype.selectPageDown = function() {
            this.$moveByPage(1, !0);
        }, e.prototype.selectPageUp = function() {
            this.$moveByPage(-1, !0);
        }, e.prototype.gotoPageDown = function() {
            this.$moveByPage(1, !1);
        }, e.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, !1);
        }, e.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
        }, e.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
        }, e.prototype.scrollToRow = function(e) {
            this.renderer.scrollToRow(e);
        }, e.prototype.scrollToLine = function(e, t, n, r) {
            this.renderer.scrollToLine(e, t, n, r);
        }, e.prototype.centerSelection = function() {
            var e = this.getSelectionRange(), t = {
                row: Math.floor(e.start.row + (e.end.row - e.start.row) / 2),
                column: Math.floor(e.start.column + (e.end.column - e.start.column) / 2)
            };
            this.renderer.alignCursor(t, .5);
        }, e.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
        }, e.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
        }, e.prototype.getSelectionRange = function() {
            return this.selection.getRange();
        }, e.prototype.selectAll = function() {
            this.selection.selectAll();
        }, e.prototype.clearSelection = function() {
            this.selection.clearSelection();
        }, e.prototype.moveCursorTo = function(e, t) {
            this.selection.moveCursorTo(e, t);
        }, e.prototype.moveCursorToPosition = function(e) {
            this.selection.moveCursorToPosition(e);
        }, e.prototype.jumpToMatching = function(e, t) {
            var n = this.getCursorPosition(), r = new b(this.session, n.row, n.column), i = r.getCurrentToken(), s = 0;
            i && i.type.indexOf("tag-name") !== -1 && (i = r.stepBackward());
            var o = i || r.stepForward();
            if (!o) return;
            var u, a = !1, f = {}, l = n.column - o.start, c, h = {
                ")": "(",
                "(": "(",
                "]": "[",
                "[": "[",
                "{": "{",
                "}": "{"
            };
            do {
                if (o.value.match(/[{}()\[\]]/g)) for(; l < o.value.length && !a; l++){
                    if (!h[o.value[l]]) continue;
                    c = h[o.value[l]] + "." + o.type.replace("rparen", "lparen"), isNaN(f[c]) && (f[c] = 0);
                    switch(o.value[l]){
                        case "(":
                        case "[":
                        case "{":
                            f[c]++;
                            break;
                        case ")":
                        case "]":
                        case "}":
                            f[c]--, f[c] === -1 && (u = "bracket", a = !0);
                    }
                }
                else o.type.indexOf("tag-name") !== -1 && (isNaN(f[o.value]) && (f[o.value] = 0), i.value === "<" && s > 1 ? f[o.value]++ : i.value === "</" && f[o.value]--, f[o.value] === -1 && (u = "tag", a = !0));
                a || (i = o, s++, o = r.stepForward(), l = 0);
            }while (o && !a);
            if (!u) return;
            var p, v;
            if (u === "bracket") {
                p = this.session.getBracketRange(n);
                if (!p) {
                    p = new d(r.getCurrentTokenRow(), r.getCurrentTokenColumn() + l - 1, r.getCurrentTokenRow(), r.getCurrentTokenColumn() + l - 1), v = p.start;
                    if (t || v.row === n.row && Math.abs(v.column - n.column) < 2) p = this.session.getBracketRange(v);
                }
            } else if (u === "tag") {
                if (!o || o.type.indexOf("tag-name") === -1) return;
                p = new d(r.getCurrentTokenRow(), r.getCurrentTokenColumn() - 2, r.getCurrentTokenRow(), r.getCurrentTokenColumn() - 2);
                if (p.compare(n.row, n.column) === 0) {
                    var m = this.session.getMatchingTags(n);
                    m && (m.openTag.contains(n.row, n.column) ? (p = m.closeTag, v = p.start) : (p = m.openTag, m.closeTag.start.row === n.row && m.closeTag.start.column === n.column ? v = p.end : v = p.start));
                }
                v = v || p.start;
            }
            v = p && p.cursor || v, v && (e ? p && t ? this.selection.setRange(p) : p && p.isEqual(this.getSelectionRange()) ? this.clearSelection() : this.selection.selectTo(v.row, v.column) : this.selection.moveTo(v.row, v.column));
        }, e.prototype.gotoLine = function(e, t, n) {
            this.selection.clearSelection(), this.session.unfold({
                row: e - 1,
                column: t || 0
            }), this.exitMultiSelectMode && this.exitMultiSelectMode(), this.moveCursorTo(e - 1, t || 0), this.isRowFullyVisible(e - 1) || this.scrollToLine(e - 1, !0, n);
        }, e.prototype.navigateTo = function(e, t) {
            this.selection.moveTo(e, t);
        }, e.prototype.navigateUp = function(e) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                var t = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(t);
            }
            this.selection.clearSelection(), this.selection.moveCursorBy(-e || -1, 0);
        }, e.prototype.navigateDown = function(e) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                var t = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(t);
            }
            this.selection.clearSelection(), this.selection.moveCursorBy(e || 1, 0);
        }, e.prototype.navigateLeft = function(e) {
            if (!this.selection.isEmpty()) {
                var t = this.getSelectionRange().start;
                this.moveCursorToPosition(t);
            } else {
                e = e || 1;
                while(e--)this.selection.moveCursorLeft();
            }
            this.clearSelection();
        }, e.prototype.navigateRight = function(e) {
            if (!this.selection.isEmpty()) {
                var t = this.getSelectionRange().end;
                this.moveCursorToPosition(t);
            } else {
                e = e || 1;
                while(e--)this.selection.moveCursorRight();
            }
            this.clearSelection();
        }, e.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart(), this.clearSelection();
        }, e.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd(), this.clearSelection();
        }, e.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd(), this.clearSelection();
        }, e.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart(), this.clearSelection();
        }, e.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight(), this.clearSelection();
        }, e.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft(), this.clearSelection();
        }, e.prototype.replace = function(e, t) {
            t && this.$search.set(t);
            var n = this.$search.find(this.session), r = 0;
            return n ? (this.$tryReplace(n, e) && (r = 1), this.selection.setSelectionRange(n), this.renderer.scrollSelectionIntoView(n.start, n.end), r) : r;
        }, e.prototype.replaceAll = function(e, t) {
            t && this.$search.set(t);
            var n = this.$search.findAll(this.session), r = 0;
            if (!n.length) return r;
            var i = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for(var s = n.length - 1; s >= 0; --s)this.$tryReplace(n[s], e) && r++;
            return this.selection.setSelectionRange(i), r;
        }, e.prototype.$tryReplace = function(e, t) {
            var n = this.session.getTextRange(e);
            return t = this.$search.replace(n, t), t !== null ? (e.end = this.session.replace(e, t), e) : null;
        }, e.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
        }, e.prototype.find = function(e, t, n) {
            t || (t = {}), typeof e == "string" || e instanceof RegExp ? t.needle = e : typeof e == "object" && i.mixin(t, e);
            var r = this.selection.getRange();
            t.needle == null && (e = this.session.getTextRange(r) || this.$search.$options.needle, e || (r = this.session.getWordRange(r.start.row, r.start.column), e = this.session.getTextRange(r)), this.$search.set({
                needle: e
            })), this.$search.set(t), t.start || this.$search.set({
                start: r
            });
            var s = this.$search.find(this.session);
            if (t.preventScroll) return s;
            if (s) return this.revealRange(s, n), s;
            t.backwards ? r.start = r.end : r.end = r.start, this.selection.setRange(r);
        }, e.prototype.findNext = function(e, t) {
            this.find({
                skipCurrent: !0,
                backwards: !1
            }, e, t);
        }, e.prototype.findPrevious = function(e, t) {
            this.find(e, {
                skipCurrent: !0,
                backwards: !0
            }, t);
        }, e.prototype.revealRange = function(e, t) {
            this.session.unfold(e), this.selection.setSelectionRange(e);
            var n = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(e.start, e.end, .5), t !== !1 && this.renderer.animateScrolling(n);
        }, e.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session), this.renderer.scrollCursorIntoView(null, .5);
        }, e.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session), this.renderer.scrollCursorIntoView(null, .5);
        }, e.prototype.destroy = function() {
            this.$toDestroy && (this.$toDestroy.forEach(function(e) {
                e.destroy();
            }), this.$toDestroy = null), this.$mouseHandler && this.$mouseHandler.destroy(), this.renderer.destroy(), this._signal("destroy", this), this.session && this.session.destroy(), this._$emitInputEvent && this._$emitInputEvent.cancel(), this.removeAllListeners();
        }, e.prototype.setAutoScrollEditorIntoView = function(e) {
            if (!e) return;
            var t, n = this, r = !1;
            this.$scrollAnchor || (this.$scrollAnchor = document.createElement("div"));
            var i = this.$scrollAnchor;
            i.style.cssText = "position:absolute", this.container.insertBefore(i, this.container.firstChild);
            var s = this.on("changeSelection", function() {
                r = !0;
            }), o = this.renderer.on("beforeRender", function() {
                r && (t = n.renderer.container.getBoundingClientRect());
            }), u = this.renderer.on("afterRender", function() {
                if (r && t && (n.isFocused() || n.searchBox && n.searchBox.isFocused())) {
                    var e = n.renderer, s = e.$cursorLayer.$pixelPos, o = e.layerConfig, u = s.top - o.offset;
                    s.top >= 0 && u + t.top < 0 ? r = !0 : s.top < o.height && s.top + t.top + o.lineHeight > window.innerHeight ? r = !1 : r = null, r != null && (i.style.top = u + "px", i.style.left = s.left + "px", i.style.height = o.lineHeight + "px", i.scrollIntoView(r)), r = t = null;
                }
            });
            this.setAutoScrollEditorIntoView = function(e) {
                if (e) return;
                delete this.setAutoScrollEditorIntoView, this.off("changeSelection", s), this.renderer.off("afterRender", u), this.renderer.off("beforeRender", o);
            };
        }, e.prototype.$resetCursorStyle = function() {
            var e = this.$cursorStyle || "ace", t = this.renderer.$cursorLayer;
            if (!t) return;
            t.setSmoothBlinking(/smooth/.test(e)), t.isBlinking = !this.$readOnly && e != "wide", s.setCssClass(t.element, "ace_slim-cursors", /slim/.test(e));
        }, e.prototype.prompt = function(e, t, n) {
            var r = this;
            y.loadModule("ace/ext/prompt", function(i) {
                i.prompt(r, e, t, n);
            });
        }, e;
    }();
    C.$uid = 0, C.prototype.curOp = null, C.prototype.prevOp = {}, C.prototype.$mergeableCommands = [
        "backspace",
        "del",
        "insertstring"
    ], C.prototype.$toggleWordPairs = [
        [
            "first",
            "last"
        ],
        [
            "true",
            "false"
        ],
        [
            "yes",
            "no"
        ],
        [
            "width",
            "height"
        ],
        [
            "top",
            "bottom"
        ],
        [
            "right",
            "left"
        ],
        [
            "on",
            "off"
        ],
        [
            "x",
            "y"
        ],
        [
            "get",
            "set"
        ],
        [
            "max",
            "min"
        ],
        [
            "horizontal",
            "vertical"
        ],
        [
            "show",
            "hide"
        ],
        [
            "add",
            "remove"
        ],
        [
            "up",
            "down"
        ],
        [
            "before",
            "after"
        ],
        [
            "even",
            "odd"
        ],
        [
            "in",
            "out"
        ],
        [
            "inside",
            "outside"
        ],
        [
            "next",
            "previous"
        ],
        [
            "increase",
            "decrease"
        ],
        [
            "attach",
            "detach"
        ],
        [
            "&&",
            "||"
        ],
        [
            "==",
            "!="
        ]
    ], i.implement(C.prototype, v), y.defineOptions(C.prototype, "editor", {
        selectionStyle: {
            set: function(e) {
                this.onSelectionChange(), this._signal("changeSelectionStyle", {
                    data: e
                });
            },
            initialValue: "line"
        },
        highlightActiveLine: {
            set: function() {
                this.$updateHighlightActiveLine();
            },
            initialValue: !0
        },
        highlightSelectedWord: {
            set: function(e) {
                this.$onSelectionChange();
            },
            initialValue: !0
        },
        readOnly: {
            set: function(e) {
                var t = this;
                this.textInput.setReadOnly(e), this.$resetCursorStyle(), this.$readOnlyCallback || (this.$readOnlyCallback = function(e) {
                    var n = !1;
                    if (e && e.type == "keydown") {
                        n = e && e.key && e.key.length == 1 && !e.ctrlKey && !e.metaKey;
                        if (!n) return;
                    } else e && e.type !== "exec" && (n = !0);
                    if (n) {
                        t.hoverTooltip || (t.hoverTooltip = new N);
                        var r = s.createElement("div");
                        r.textContent = E("editor.tooltip.disable-editing", "Editing is disabled"), t.hoverTooltip.isOpen || t.hoverTooltip.showForRange(t, t.getSelectionRange(), r);
                    } else t.hoverTooltip && t.hoverTooltip.isOpen && t.hoverTooltip.hide();
                });
                var n = this.textInput.getElement();
                e ? (T.addListener(n, "keydown", this.$readOnlyCallback, this), this.commands.on("exec", this.$readOnlyCallback), this.commands.on("commandUnavailable", this.$readOnlyCallback)) : (T.removeListener(n, "keydown", this.$readOnlyCallback), this.commands.off("exec", this.$readOnlyCallback), this.commands.off("commandUnavailable", this.$readOnlyCallback), this.hoverTooltip && (this.hoverTooltip.destroy(), this.hoverTooltip = null));
            },
            initialValue: !1
        },
        copyWithEmptySelection: {
            set: function(e) {
                this.textInput.setCopyWithEmptySelection(e);
            },
            initialValue: !1
        },
        cursorStyle: {
            set: function(e) {
                this.$resetCursorStyle();
            },
            values: [
                "ace",
                "slim",
                "smooth",
                "wide"
            ],
            initialValue: "ace"
        },
        mergeUndoDeltas: {
            values: [
                !1,
                !0,
                "always"
            ],
            initialValue: !0
        },
        behavioursEnabled: {
            initialValue: !0
        },
        wrapBehavioursEnabled: {
            initialValue: !0
        },
        enableAutoIndent: {
            initialValue: !0
        },
        autoScrollEditorIntoView: {
            set: function(e) {
                this.setAutoScrollEditorIntoView(e);
            }
        },
        keyboardHandler: {
            set: function(e) {
                this.setKeyboardHandler(e);
            },
            get: function() {
                return this.$keybindingId;
            },
            handlesSet: !0
        },
        value: {
            set: function(e) {
                this.session.setValue(e);
            },
            get: function() {
                return this.getValue();
            },
            handlesSet: !0,
            hidden: !0
        },
        session: {
            set: function(e) {
                this.setSession(e);
            },
            get: function() {
                return this.session;
            },
            handlesSet: !0,
            hidden: !0
        },
        showLineNumbers: {
            set: function(e) {
                this.renderer.$gutterLayer.setShowLineNumbers(e), this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER), e && this.$relativeLineNumbers ? k.attach(this) : k.detach(this);
            },
            initialValue: !0
        },
        relativeLineNumbers: {
            set: function(e) {
                this.$showLineNumbers && e ? k.attach(this) : k.detach(this);
            }
        },
        placeholder: {
            set: function(e) {
                this.$updatePlaceholder || (this.$updatePlaceholder = (function() {
                    var e = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                    if (e && this.renderer.placeholderNode) this.renderer.off("afterRender", this.$updatePlaceholder), s.removeCssClass(this.container, "ace_hasPlaceholder"), this.renderer.placeholderNode.remove(), this.renderer.placeholderNode = null;
                    else if (!e && !this.renderer.placeholderNode) {
                        this.renderer.on("afterRender", this.$updatePlaceholder), s.addCssClass(this.container, "ace_hasPlaceholder");
                        var t = s.createElement("div");
                        t.className = "ace_placeholder", t.textContent = this.$placeholder || "", this.renderer.placeholderNode = t, this.renderer.content.appendChild(this.renderer.placeholderNode);
                    } else !e && this.renderer.placeholderNode && (this.renderer.placeholderNode.textContent = this.$placeholder || "");
                }).bind(this), this.on("input", this.$updatePlaceholder)), this.$updatePlaceholder();
            }
        },
        enableKeyboardAccessibility: {
            set: function(e) {
                var t = {
                    name: "blurTextInput",
                    description: "Set focus to the editor content div to allow tabbing through the page",
                    bindKey: "Esc",
                    exec: function(e) {
                        e.blur(), e.renderer.scroller.focus();
                    },
                    readOnly: !0
                }, n = function(e) {
                    if (e.target == this.renderer.scroller && e.keyCode === x.enter) {
                        e.preventDefault();
                        var t = this.getCursorPosition().row;
                        this.isRowVisible(t) || this.scrollToLine(t, !0, !0), this.focus();
                    }
                }, r;
                e ? (this.renderer.enableKeyboardAccessibility = !0, this.renderer.keyboardFocusClassName = "ace_keyboard-focus", this.textInput.getElement().setAttribute("tabindex", -1), this.textInput.setNumberOfExtraLines(u.isWin ? 3 : 0), this.renderer.scroller.setAttribute("tabindex", 0), this.renderer.scroller.setAttribute("role", "group"), this.renderer.scroller.setAttribute("aria-roledescription", E("editor.scroller.aria-roledescription", "editor")), this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName), this.renderer.scroller.setAttribute("aria-label", E("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit")), this.renderer.scroller.addEventListener("keyup", n.bind(this)), this.commands.addCommand(t), this.renderer.$gutter.setAttribute("tabindex", 0), this.renderer.$gutter.setAttribute("aria-hidden", !1), this.renderer.$gutter.setAttribute("role", "group"), this.renderer.$gutter.setAttribute("aria-roledescription", E("editor.gutter.aria-roledescription", "editor gutter")), this.renderer.$gutter.setAttribute("aria-label", E("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit")), this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName), this.renderer.content.setAttribute("aria-hidden", !0), r || (r = new w(this)), r.addListener(), this.textInput.setAriaOptions({
                    setLabel: !0
                })) : (this.renderer.enableKeyboardAccessibility = !1, this.textInput.getElement().setAttribute("tabindex", 0), this.textInput.setNumberOfExtraLines(0), this.renderer.scroller.setAttribute("tabindex", -1), this.renderer.scroller.removeAttribute("role"), this.renderer.scroller.removeAttribute("aria-roledescription"), this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName), this.renderer.scroller.removeAttribute("aria-label"), this.renderer.scroller.removeEventListener("keyup", n.bind(this)), this.commands.removeCommand(t), this.renderer.content.removeAttribute("aria-hidden"), this.renderer.$gutter.setAttribute("tabindex", -1), this.renderer.$gutter.setAttribute("aria-hidden", !0), this.renderer.$gutter.removeAttribute("role"), this.renderer.$gutter.removeAttribute("aria-roledescription"), this.renderer.$gutter.removeAttribute("aria-label"), this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName), r && r.removeListener());
            },
            initialValue: !1
        },
        textInputAriaLabel: {
            set: function(e) {
                this.$textInputAriaLabel = e;
            },
            initialValue: ""
        },
        enableMobileMenu: {
            set: function(e) {
                this.$enableMobileMenu = e;
            },
            initialValue: !0
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
    });
    var k = {
        getText: function(e, t) {
            return (Math.abs(e.selection.lead.row - t) || t + 1 + (t < 9 ? "\xb7" : "")) + "";
        },
        getWidth: function(e, t, n) {
            return Math.max(t.toString().length, (n.lastRow + 1).toString().length, 2) * n.characterWidth;
        },
        update: function(e, t) {
            t.renderer.$loop.schedule(t.renderer.CHANGE_GUTTER);
        },
        attach: function(e) {
            e.renderer.$gutterLayer.$renderer = this, e.on("changeSelection", this.update), this.update(null, e);
        },
        detach: function(e) {
            e.renderer.$gutterLayer.$renderer == this && (e.renderer.$gutterLayer.$renderer = null), e.off("changeSelection", this.update), this.update(null, e);
        }
    };
    t.Editor = C;
}), ace.define("ace/layer/lines", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/dom"), i = function() {
        function e(e, t) {
            this.element = e, this.canvasHeight = t || 5e5, this.element.style.height = this.canvasHeight * 2 + "px", this.cells = [], this.cellCache = [], this.$offsetCoefficient = 0;
        }
        return e.prototype.moveContainer = function(e) {
            r.translate(this.element, 0, -(e.firstRowScreen * e.lineHeight % this.canvasHeight) - e.offset * this.$offsetCoefficient);
        }, e.prototype.pageChanged = function(e, t) {
            return Math.floor(e.firstRowScreen * e.lineHeight / this.canvasHeight) !== Math.floor(t.firstRowScreen * t.lineHeight / this.canvasHeight);
        }, e.prototype.computeLineTop = function(e, t, n) {
            var r = t.firstRowScreen * t.lineHeight, i = Math.floor(r / this.canvasHeight), s = n.documentToScreenRow(e, 0) * t.lineHeight;
            return s - i * this.canvasHeight;
        }, e.prototype.computeLineHeight = function(e, t, n) {
            return t.lineHeight * n.getRowLineCount(e);
        }, e.prototype.getLength = function() {
            return this.cells.length;
        }, e.prototype.get = function(e) {
            return this.cells[e];
        }, e.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
        }, e.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
        }, e.prototype.push = function(e) {
            if (Array.isArray(e)) {
                this.cells.push.apply(this.cells, e);
                var t = r.createFragment(this.element);
                for(var n = 0; n < e.length; n++)t.appendChild(e[n].element);
                this.element.appendChild(t);
            } else this.cells.push(e), this.element.appendChild(e.element);
        }, e.prototype.unshift = function(e) {
            if (Array.isArray(e)) {
                this.cells.unshift.apply(this.cells, e);
                var t = r.createFragment(this.element);
                for(var n = 0; n < e.length; n++)t.appendChild(e[n].element);
                this.element.firstChild ? this.element.insertBefore(t, this.element.firstChild) : this.element.appendChild(t);
            } else this.cells.unshift(e), this.element.insertAdjacentElement("afterbegin", e.element);
        }, e.prototype.last = function() {
            return this.cells.length ? this.cells[this.cells.length - 1] : null;
        }, e.prototype.$cacheCell = function(e) {
            if (!e) return;
            e.element.remove(), this.cellCache.push(e);
        }, e.prototype.createCell = function(e, t, n, i) {
            var s = this.cellCache.pop();
            if (!s) {
                var o = r.createElement("div");
                i && i(o), this.element.appendChild(o), s = {
                    element: o,
                    text: "",
                    row: e
                };
            }
            return s.row = e, s;
        }, e;
    }();
    t.Lines = i;
}), ace.define("ace/layer/gutter", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/lib/event_emitter",
    "ace/layer/lines",
    "ace/config"
], function(e, t, n) {
    "use strict";
    function l(e) {
        var t = document.createTextNode("");
        e.appendChild(t);
        var n = r.createElement("span");
        e.appendChild(n);
        var i = r.createElement("span");
        e.appendChild(i);
        var s = r.createElement("span");
        return i.appendChild(s), e;
    }
    var r = e("../lib/dom"), i = e("../lib/oop"), s = e("../lib/lang"), o = e("../lib/event_emitter").EventEmitter, u = e("./lines").Lines, a = e("../config").nls, f = function() {
        function e(e) {
            this.element = r.createElement("div"), this.element.className = "ace_layer ace_gutter-layer", e.appendChild(this.element), this.setShowFoldWidgets(this.$showFoldWidgets), this.gutterWidth = 0, this.$annotations = [], this.$updateAnnotations = this.$updateAnnotations.bind(this), this.$lines = new u(this.element), this.$lines.$offsetCoefficient = 1;
        }
        return e.prototype.setSession = function(e) {
            this.session && this.session.off("change", this.$updateAnnotations), this.session = e, e && e.on("change", this.$updateAnnotations);
        }, e.prototype.addGutterDecoration = function(e, t) {
            window.console && console.warn && console.warn("deprecated use session.addGutterDecoration"), this.session.addGutterDecoration(e, t);
        }, e.prototype.removeGutterDecoration = function(e, t) {
            window.console && console.warn && console.warn("deprecated use session.removeGutterDecoration"), this.session.removeGutterDecoration(e, t);
        }, e.prototype.setAnnotations = function(e) {
            this.$annotations = [];
            for(var t = 0; t < e.length; t++){
                var n = e[t], r = n.row, i = this.$annotations[r];
                i || (i = this.$annotations[r] = {
                    text: [],
                    type: [],
                    displayText: []
                });
                var o = n.text, u = n.text, a = n.type;
                o = o ? s.escapeHTML(o) : n.html || "", u = u ? u : n.html || "", i.text.indexOf(o) === -1 && (i.text.push(o), i.type.push(a), i.displayText.push(u));
                var f = n.className;
                f ? i.className = f : a === "error" ? i.className = " ace_error" : a === "security" && !/\bace_error\b/.test(i.className) ? i.className = " ace_security" : a === "warning" && !/\bace_(error|security)\b/.test(i.className) ? i.className = " ace_warning" : a === "info" && !i.className ? i.className = " ace_info" : a === "hint" && !i.className && (i.className = " ace_hint");
            }
        }, e.prototype.$updateAnnotations = function(e) {
            if (!this.$annotations.length) return;
            var t = e.start.row, n = e.end.row - t;
            if (n !== 0) {
                if (e.action == "remove") this.$annotations.splice(t, n + 1, null);
                else {
                    var r = new Array(n + 1);
                    r.unshift(t, 1), this.$annotations.splice.apply(this.$annotations, r);
                }
            }
        }, e.prototype.update = function(e) {
            this.config = e;
            var t = this.session, n = e.firstRow, r = Math.min(e.lastRow + e.gutterOffset, t.getLength() - 1);
            this.oldLastRow = r, this.config = e, this.$lines.moveContainer(e), this.$updateCursorRow();
            var i = t.getNextFoldLine(n), s = i ? i.start.row : Infinity, o = null, u = -1, a = n;
            for(;;){
                a > s && (a = i.end.row + 1, i = t.getNextFoldLine(a, i), s = i ? i.start.row : Infinity);
                if (a > r) {
                    while(this.$lines.getLength() > u + 1)this.$lines.pop();
                    break;
                }
                o = this.$lines.get(++u), o ? o.row = a : (o = this.$lines.createCell(a, e, this.session, l), this.$lines.push(o)), this.$renderCell(o, e, i, a), a++;
            }
            this._signal("afterRender"), this.$updateGutterWidth(e);
        }, e.prototype.$updateGutterWidth = function(e) {
            var t = this.session, n = t.gutterRenderer || this.$renderer, r = t.$firstLineNumber, i = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || t.$useWrapMode) i = t.getLength() + r - 1;
            var s = n ? n.getWidth(t, i, e) : i.toString().length * e.characterWidth, o = this.$padding || this.$computePadding();
            s += o.left + o.right, s !== this.gutterWidth && !isNaN(s) && (this.gutterWidth = s, this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px", this._signal("changeGutterWidth", s));
        }, e.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine) return;
            var e = this.session.selection.getCursor();
            if (this.$cursorRow === e.row) return;
            this.$cursorRow = e.row;
        }, e.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine) return;
            var e = this.session.selection.cursor.row;
            this.$cursorRow = e;
            if (this.$cursorCell && this.$cursorCell.row == e) return;
            this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", ""));
            var t = this.$lines.cells;
            this.$cursorCell = null;
            for(var n = 0; n < t.length; n++){
                var r = t[n];
                if (r.row >= this.$cursorRow) {
                    if (r.row > this.$cursorRow) {
                        var i = this.session.getFoldLine(this.$cursorRow);
                        if (!(n > 0 && i && i.start.row == t[n - 1].row)) break;
                        r = t[n - 1];
                    }
                    r.element.className = "ace_gutter-active-line " + r.element.className, this.$cursorCell = r;
                    break;
                }
            }
        }, e.prototype.scrollLines = function(e) {
            var t = this.config;
            this.config = e, this.$updateCursorRow();
            if (this.$lines.pageChanged(t, e)) return this.update(e);
            this.$lines.moveContainer(e);
            var n = Math.min(e.lastRow + e.gutterOffset, this.session.getLength() - 1), r = this.oldLastRow;
            this.oldLastRow = n;
            if (!t || r < e.firstRow) return this.update(e);
            if (n < t.firstRow) return this.update(e);
            if (t.firstRow < e.firstRow) for(var i = this.session.getFoldedRowCount(t.firstRow, e.firstRow - 1); i > 0; i--)this.$lines.shift();
            if (r > n) for(var i = this.session.getFoldedRowCount(n + 1, r); i > 0; i--)this.$lines.pop();
            e.firstRow < t.firstRow && this.$lines.unshift(this.$renderLines(e, e.firstRow, t.firstRow - 1)), n > r && this.$lines.push(this.$renderLines(e, r + 1, n)), this.updateLineHighlight(), this._signal("afterRender"), this.$updateGutterWidth(e);
        }, e.prototype.$renderLines = function(e, t, n) {
            var r = [], i = t, s = this.session.getNextFoldLine(i), o = s ? s.start.row : Infinity;
            for(;;){
                i > o && (i = s.end.row + 1, s = this.session.getNextFoldLine(i, s), o = s ? s.start.row : Infinity);
                if (i > n) break;
                var u = this.$lines.createCell(i, e, this.session, l);
                this.$renderCell(u, e, s, i), r.push(u), i++;
            }
            return r;
        }, e.prototype.$renderCell = function(e, t, n, i) {
            var s = e.element, o = this.session, u = s.childNodes[0], f = s.childNodes[1], l = s.childNodes[2], c = s.childNodes[3], h = l.firstChild, p = o.$firstLineNumber, d = o.$breakpoints, v = o.$decorations, m = o.gutterRenderer || this.$renderer, g = this.$showFoldWidgets && o.foldWidgets, y = n ? n.start.row : Number.MAX_VALUE, b = t.lineHeight + "px", w = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ", E = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon", S = (m ? m.getText(o, i) : i + p).toString();
            this.$highlightGutterLine && (i == this.$cursorRow || n && i < this.$cursorRow && i >= y && this.$cursorRow <= n.end.row) && (w += "ace_gutter-active-line ", this.$cursorCell != e && (this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "")), this.$cursorCell = e)), d[i] && (w += d[i]), v[i] && (w += v[i]), this.$annotations[i] && i !== y && (w += this.$annotations[i].className);
            if (g) {
                var x = g[i];
                x == null && (x = g[i] = o.getFoldWidget(i));
            }
            if (x) {
                var T = "ace_fold-widget ace_" + x, N = x == "start" && i == y && i < n.end.row;
                if (N) {
                    T += " ace_closed";
                    var C = "", k = !1;
                    for(var L = i + 1; L <= n.end.row; L++){
                        if (!this.$annotations[L]) continue;
                        if (this.$annotations[L].className === " ace_error") {
                            k = !0, C = " ace_error_fold";
                            break;
                        }
                        this.$annotations[L].className === " ace_security" ? (k = !0, C = " ace_security_fold") : this.$annotations[L].className === " ace_warning" && C !== " ace_security_fold" && (k = !0, C = " ace_warning_fold");
                    }
                    w += C;
                } else T += " ace_open";
                f.className != T && (f.className = T), r.setStyle(f.style, "height", b), r.setStyle(f.style, "display", "inline-block"), f.setAttribute("role", "button"), f.setAttribute("tabindex", "-1");
                var A = o.getFoldWidgetRange(i);
                A ? f.setAttribute("aria-label", a("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                    A.start.row + 1,
                    A.end.row + 1
                ])) : n ? f.setAttribute("aria-label", a("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                    n.start.row + 1,
                    n.end.row + 1
                ])) : f.setAttribute("aria-label", a("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [
                    i + 1
                ])), N ? (f.setAttribute("aria-expanded", "false"), f.setAttribute("title", a("gutter.code-folding.closed.title", "Unfold code"))) : (f.setAttribute("aria-expanded", "true"), f.setAttribute("title", a("gutter.code-folding.open.title", "Fold code")));
            } else f && (r.setStyle(f.style, "display", "none"), f.setAttribute("tabindex", "0"), f.removeAttribute("role"), f.removeAttribute("aria-label"));
            var O = this.session.$gutterCustomWidgets[i];
            O ? this.$addCustomWidget(i, O, e) : c && this.$removeCustomWidget(i, e);
            if (k && this.$showFoldedAnnotations) {
                l.className = "ace_gutter_annotation", h.className = E, h.className += C, r.setStyle(h.style, "height", b), r.setStyle(l.style, "display", "block"), r.setStyle(l.style, "height", b);
                var M;
                switch(C){
                    case " ace_error_fold":
                        M = a("gutter.annotation.aria-label.error", "Error, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_security_fold":
                        M = a("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_warning_fold":
                        M = a("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [
                            S
                        ]);
                }
                l.setAttribute("aria-label", M), l.setAttribute("tabindex", "-1"), l.setAttribute("role", "button");
            } else if (this.$annotations[i]) {
                l.className = "ace_gutter_annotation", h.className = E, this.$useSvgGutterIcons ? h.className += this.$annotations[i].className : s.classList.add(this.$annotations[i].className.replace(" ", "")), r.setStyle(h.style, "height", b), r.setStyle(l.style, "display", "block"), r.setStyle(l.style, "height", b);
                var M;
                switch(this.$annotations[i].className){
                    case " ace_error":
                        M = a("gutter.annotation.aria-label.error", "Error, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_security":
                        M = a("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_warning":
                        M = a("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_info":
                        M = a("gutter.annotation.aria-label.info", "Info, read annotations row $0", [
                            S
                        ]);
                        break;
                    case " ace_hint":
                        M = a("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [
                            S
                        ]);
                }
                l.setAttribute("aria-label", M), l.setAttribute("tabindex", "-1"), l.setAttribute("role", "button");
            } else r.setStyle(l.style, "display", "none"), l.removeAttribute("aria-label"), l.removeAttribute("role"), l.setAttribute("tabindex", "0");
            return S !== u.data && (u.data = S), s.className != w && (s.className = w), r.setStyle(e.element.style, "height", this.$lines.computeLineHeight(i, t, o) + "px"), r.setStyle(e.element.style, "top", this.$lines.computeLineTop(i, t, o) + "px"), e.text = S, l.style.display === "none" && f.style.display === "none" && !O ? e.element.setAttribute("aria-hidden", !0) : e.element.setAttribute("aria-hidden", !1), e;
        }, e.prototype.setHighlightGutterLine = function(e) {
            this.$highlightGutterLine = e;
        }, e.prototype.setShowLineNumbers = function(e) {
            this.$renderer = !e && {
                getWidth: function() {
                    return 0;
                },
                getText: function() {
                    return "";
                }
            };
        }, e.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
        }, e.prototype.setShowFoldWidgets = function(e) {
            e ? r.addCssClass(this.element, "ace_folding-enabled") : r.removeCssClass(this.element, "ace_folding-enabled"), this.$showFoldWidgets = e, this.$padding = null;
        }, e.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
        }, e.prototype.$hideFoldWidget = function(e, t) {
            var n = t || this.$getGutterCell(e);
            if (n && n.element) {
                var i = n.element.childNodes[1];
                i && r.setStyle(i.style, "display", "none");
            }
        }, e.prototype.$showFoldWidget = function(e, t) {
            var n = t || this.$getGutterCell(e);
            if (n && n.element) {
                var i = n.element.childNodes[1];
                i && this.session.foldWidgets && this.session.foldWidgets[n.row] && r.setStyle(i.style, "display", "inline-block");
            }
        }, e.prototype.$getGutterCell = function(e) {
            var t = this.$lines.cells, n = this.session.documentToScreenRow(e, 0);
            return t[e - this.config.firstRowScreen - (e - n)];
        }, e.prototype.$addCustomWidget = function(e, t, n) {
            var i = t.className, s = t.label, o = t.title, u = t.callbacks;
            this.session.$gutterCustomWidgets[e] = {
                className: i,
                label: s,
                title: o,
                callbacks: u
            }, this.$hideFoldWidget(e, n);
            var a = n || this.$getGutterCell(e);
            if (a && a.element) {
                var f = a.element.querySelector(".ace_custom-widget");
                f && f.remove(), f = r.createElement("span"), f.className = "ace_custom-widget ".concat(i), f.setAttribute("tabindex", "-1"), f.setAttribute("role", "button"), f.setAttribute("aria-label", s), f.setAttribute("title", o), r.setStyle(f.style, "display", "inline-block"), r.setStyle(f.style, "height", "inherit"), u && u.onClick && f.addEventListener("click", function(t) {
                    u.onClick(t, e), t.stopPropagation();
                }), a.element.appendChild(f);
            }
        }, e.prototype.$removeCustomWidget = function(e, t) {
            delete this.session.$gutterCustomWidgets[e], this.$showFoldWidget(e, t);
            var n = t || this.$getGutterCell(e);
            if (n && n.element) {
                var r = n.element.querySelector(".ace_custom-widget");
                r && n.element.removeChild(r);
            }
        }, e.prototype.$computePadding = function() {
            if (!this.element.firstChild) return {
                left: 0,
                right: 0
            };
            var e = r.computedStyle(this.element.firstChild);
            return this.$padding = {}, this.$padding.left = (parseInt(e.borderLeftWidth) || 0) + (parseInt(e.paddingLeft) || 0) + 1, this.$padding.right = (parseInt(e.borderRightWidth) || 0) + (parseInt(e.paddingRight) || 0), this.$padding;
        }, e.prototype.getRegion = function(e) {
            var t = this.$padding || this.$computePadding(), n = this.element.getBoundingClientRect();
            if (e.x < t.left + n.left) return "markers";
            if (this.$showFoldWidgets && e.x > n.right - t.right) return "foldWidgets";
        }, e;
    }();
    f.prototype.$fixedWidth = !1, f.prototype.$highlightGutterLine = !0, f.prototype.$renderer = "", f.prototype.$showLineNumbers = !0, f.prototype.$showFoldWidgets = !0, i.implement(f.prototype, o), t.Gutter = f;
}), ace.define("ace/layer/marker", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    function o(e, t, n, r) {
        return (e ? 1 : 0) | (t ? 2 : 0) | (n ? 4 : 0) | (r ? 8 : 0);
    }
    var r = e("../range").Range, i = e("../lib/dom"), s = function() {
        function e(e) {
            this.element = i.createElement("div"), this.element.className = "ace_layer ace_marker-layer", e.appendChild(this.element);
        }
        return e.prototype.setPadding = function(e) {
            this.$padding = e;
        }, e.prototype.setSession = function(e) {
            this.session = e;
        }, e.prototype.setMarkers = function(e) {
            this.markers = e;
        }, e.prototype.elt = function(e, t) {
            var n = this.i != -1 && this.element.childNodes[this.i];
            n ? this.i++ : (n = document.createElement("div"), this.element.appendChild(n), this.i = -1), n.style.cssText = t, n.className = e;
        }, e.prototype.update = function(e) {
            if (!e) return;
            this.config = e, this.i = 0;
            var t;
            for(var n in this.markers){
                var r = this.markers[n];
                if (!r.range) {
                    r.update(t, this, this.session, e);
                    continue;
                }
                var i = r.range.clipRows(e.firstRow, e.lastRow);
                if (i.isEmpty()) continue;
                i = i.toScreenRange(this.session);
                if (r.renderer) {
                    var s = this.$getTop(i.start.row, e), o = this.$padding + i.start.column * e.characterWidth;
                    r.renderer(t, i, o, s, e);
                } else r.type == "fullLine" ? this.drawFullLineMarker(t, i, r.clazz, e) : r.type == "screenLine" ? this.drawScreenLineMarker(t, i, r.clazz, e) : i.isMultiLine() ? r.type == "text" ? this.drawTextMarker(t, i, r.clazz, e) : this.drawMultiLineMarker(t, i, r.clazz, e) : this.drawSingleLineMarker(t, i, r.clazz + " ace_start" + " ace_br15", e);
            }
            if (this.i != -1) while(this.i < this.element.childElementCount)this.element.removeChild(this.element.lastChild);
        }, e.prototype.$getTop = function(e, t) {
            return (e - t.firstRowScreen) * t.lineHeight;
        }, e.prototype.drawTextMarker = function(e, t, n, i, s) {
            var u = this.session, a = t.start.row, f = t.end.row, l = a, c = 0, h = 0, p = u.getScreenLastRowColumn(l), d = new r(l, t.start.column, l, h);
            for(; l <= f; l++)d.start.row = d.end.row = l, d.start.column = l == a ? t.start.column : u.getRowWrapIndent(l), d.end.column = p, c = h, h = p, p = l + 1 < f ? u.getScreenLastRowColumn(l + 1) : l == f ? 0 : t.end.column, this.drawSingleLineMarker(e, d, n + (l == a ? " ace_start" : "") + " ace_br" + o(l == a || l == a + 1 && t.start.column, c < h, h > p, l == f), i, l == f ? 0 : 1, s);
        }, e.prototype.drawMultiLineMarker = function(e, t, n, r, i) {
            var s = this.$padding, o = r.lineHeight, u = this.$getTop(t.start.row, r), a = s + t.start.column * r.characterWidth;
            i = i || "";
            if (this.session.$bidiHandler.isBidiRow(t.start.row)) {
                var f = t.clone();
                f.end.row = f.start.row, f.end.column = this.session.getLine(f.start.row).length, this.drawBidiSingleLineMarker(e, f, n + " ace_br1 ace_start", r, null, i);
            } else this.elt(n + " ace_br1 ace_start", "height:" + o + "px;" + "right:" + s + "px;" + "top:" + u + "px;left:" + a + "px;" + (i || ""));
            if (this.session.$bidiHandler.isBidiRow(t.end.row)) {
                var f = t.clone();
                f.start.row = f.end.row, f.start.column = 0, this.drawBidiSingleLineMarker(e, f, n + " ace_br12", r, null, i);
            } else {
                u = this.$getTop(t.end.row, r);
                var l = t.end.column * r.characterWidth;
                this.elt(n + " ace_br12", "height:" + o + "px;" + "width:" + l + "px;" + "top:" + u + "px;" + "left:" + s + "px;" + (i || ""));
            }
            o = (t.end.row - t.start.row - 1) * r.lineHeight;
            if (o <= 0) return;
            u = this.$getTop(t.start.row + 1, r);
            var c = (t.start.column ? 1 : 0) | (t.end.column ? 0 : 8);
            this.elt(n + (c ? " ace_br" + c : ""), "height:" + o + "px;" + "right:" + s + "px;" + "top:" + u + "px;" + "left:" + s + "px;" + (i || ""));
        }, e.prototype.drawSingleLineMarker = function(e, t, n, r, i, s) {
            if (this.session.$bidiHandler.isBidiRow(t.start.row)) return this.drawBidiSingleLineMarker(e, t, n, r, i, s);
            var o = r.lineHeight, u = (t.end.column + (i || 0) - t.start.column) * r.characterWidth, a = this.$getTop(t.start.row, r), f = this.$padding + t.start.column * r.characterWidth;
            this.elt(n, "height:" + o + "px;" + "width:" + u + "px;" + "top:" + a + "px;" + "left:" + f + "px;" + (s || ""));
        }, e.prototype.drawBidiSingleLineMarker = function(e, t, n, r, i, s) {
            var o = r.lineHeight, u = this.$getTop(t.start.row, r), a = this.$padding, f = this.session.$bidiHandler.getSelections(t.start.column, t.end.column);
            f.forEach(function(e) {
                this.elt(n, "height:" + o + "px;" + "width:" + (e.width + (i || 0)) + "px;" + "top:" + u + "px;" + "left:" + (a + e.left) + "px;" + (s || ""));
            }, this);
        }, e.prototype.drawFullLineMarker = function(e, t, n, r, i) {
            var s = this.$getTop(t.start.row, r), o = r.lineHeight;
            t.start.row != t.end.row && (o += this.$getTop(t.end.row, r) - s), this.elt(n, "height:" + o + "px;" + "top:" + s + "px;" + "left:0;right:0;" + (i || ""));
        }, e.prototype.drawScreenLineMarker = function(e, t, n, r, i) {
            var s = this.$getTop(t.start.row, r), o = r.lineHeight;
            this.elt(n, "height:" + o + "px;" + "top:" + s + "px;" + "left:0;right:0;" + (i || ""));
        }, e;
    }();
    s.prototype.$padding = 0, t.Marker = s;
}), ace.define("ace/layer/text_util", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    var r = new Set([
        "text",
        "rparen",
        "lparen"
    ]);
    t.isTextToken = function(e) {
        return r.has(e);
    };
}), ace.define("ace/layer/text", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/layer/lines",
    "ace/lib/event_emitter",
    "ace/config",
    "ace/layer/text_util"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/oop"), i = e("../lib/dom"), s = e("../lib/lang"), o = e("./lines").Lines, u = e("../lib/event_emitter").EventEmitter, a = e("../config").nls, f = e("./text_util").isTextToken, l = function() {
        function e(e) {
            this.dom = i, this.element = this.dom.createElement("div"), this.element.className = "ace_layer ace_text-layer", e.appendChild(this.element), this.$updateEolChar = this.$updateEolChar.bind(this), this.$lines = new o(this.element);
        }
        return e.prototype.$updateEolChar = function() {
            var e = this.session.doc, t = e.getNewLineCharacter() == "\n" && e.getNewLineMode() != "windows", n = t ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != n) return this.EOL_CHAR = n, !0;
        }, e.prototype.setPadding = function(e) {
            this.$padding = e, this.element.style.margin = "0 " + e + "px";
        }, e.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
        }, e.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
        }, e.prototype.$setFontMetrics = function(e) {
            this.$fontMetrics = e, this.$fontMetrics.on("changeCharacterSize", (function(e) {
                this._signal("changeCharacterSize", e);
            }).bind(this)), this.$pollSizeChanges();
        }, e.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
        }, e.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        }, e.prototype.setSession = function(e) {
            this.session = e, e && this.$computeTabString();
        }, e.prototype.setShowInvisibles = function(e) {
            return this.showInvisibles == e ? !1 : (this.showInvisibles = e, typeof e == "string" ? (this.showSpaces = /tab/i.test(e), this.showTabs = /space/i.test(e), this.showEOL = /eol/i.test(e)) : this.showSpaces = this.showTabs = this.showEOL = e, this.$computeTabString(), !0);
        }, e.prototype.setDisplayIndentGuides = function(e) {
            return this.displayIndentGuides == e ? !1 : (this.displayIndentGuides = e, this.$computeTabString(), !0);
        }, e.prototype.setHighlightIndentGuides = function(e) {
            return this.$highlightIndentGuides === e ? !1 : (this.$highlightIndentGuides = e, e);
        }, e.prototype.$computeTabString = function() {
            var e = this.session.getTabSize();
            this.tabSize = e;
            var t = this.$tabStrings = [
                0
            ];
            for(var n = 1; n < e + 1; n++)if (this.showTabs) {
                var r = this.dom.createElement("span");
                r.className = "ace_invisible ace_invisible_tab", r.textContent = s.stringRepeat(this.TAB_CHAR, n), t.push(r);
            } else t.push(this.dom.createTextNode(s.stringRepeat(" ", n), this.element));
            if (this.displayIndentGuides) {
                this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                var i = "ace_indent-guide", o = this.showSpaces ? " ace_invisible ace_invisible_space" : "", u = this.showSpaces ? s.stringRepeat(this.SPACE_CHAR, this.tabSize) : s.stringRepeat(" ", this.tabSize), a = this.showTabs ? " ace_invisible ace_invisible_tab" : "", f = this.showTabs ? s.stringRepeat(this.TAB_CHAR, this.tabSize) : u, r = this.dom.createElement("span");
                r.className = i + o, r.textContent = u, this.$tabStrings[" "] = r;
                var r = this.dom.createElement("span");
                r.className = i + a, r.textContent = f, this.$tabStrings["	"] = r;
            }
        }, e.prototype.updateLines = function(e, t, n) {
            if (this.config.lastRow != e.lastRow || this.config.firstRow != e.firstRow) return this.update(e);
            this.config = e;
            var r = Math.max(t, e.firstRow), i = Math.min(n, e.lastRow), s = this.element.childNodes, o = 0;
            for(var u = e.firstRow; u < r; u++){
                var a = this.session.getFoldLine(u);
                if (a) {
                    if (a.containsRow(r)) {
                        r = a.start.row;
                        break;
                    }
                    u = a.end.row;
                }
                o++;
            }
            var f = !1, u = r, a = this.session.getNextFoldLine(u), l = a ? a.start.row : Infinity;
            for(;;){
                u > l && (u = a.end.row + 1, a = this.session.getNextFoldLine(u, a), l = a ? a.start.row : Infinity);
                if (u > i) break;
                var c = s[o++];
                if (c) {
                    this.dom.removeChildren(c), this.$renderLine(c, u, u == l ? a : !1), f && (c.style.top = this.$lines.computeLineTop(u, e, this.session) + "px");
                    var h = e.lineHeight * this.session.getRowLength(u) + "px";
                    c.style.height != h && (f = !0, c.style.height = h);
                }
                u++;
            }
            if (f) while(o < this.$lines.cells.length){
                var p = this.$lines.cells[o++];
                p.element.style.top = this.$lines.computeLineTop(p.row, e, this.session) + "px";
            }
        }, e.prototype.scrollLines = function(e) {
            var t = this.config;
            this.config = e;
            if (this.$lines.pageChanged(t, e)) return this.update(e);
            this.$lines.moveContainer(e);
            var n = e.lastRow, r = t ? t.lastRow : -1;
            if (!t || r < e.firstRow) return this.update(e);
            if (n < t.firstRow) return this.update(e);
            if (!t || t.lastRow < e.firstRow) return this.update(e);
            if (e.lastRow < t.firstRow) return this.update(e);
            if (t.firstRow < e.firstRow) for(var i = this.session.getFoldedRowCount(t.firstRow, e.firstRow - 1); i > 0; i--)this.$lines.shift();
            if (t.lastRow > e.lastRow) for(var i = this.session.getFoldedRowCount(e.lastRow + 1, t.lastRow); i > 0; i--)this.$lines.pop();
            e.firstRow < t.firstRow && this.$lines.unshift(this.$renderLinesFragment(e, e.firstRow, t.firstRow - 1)), e.lastRow > t.lastRow && this.$lines.push(this.$renderLinesFragment(e, t.lastRow + 1, e.lastRow)), this.$highlightIndentGuide();
        }, e.prototype.$renderLinesFragment = function(e, t, n) {
            var r = [], s = t, o = this.session.getNextFoldLine(s), u = o ? o.start.row : Infinity;
            for(;;){
                s > u && (s = o.end.row + 1, o = this.session.getNextFoldLine(s, o), u = o ? o.start.row : Infinity);
                if (s > n) break;
                var a = this.$lines.createCell(s, e, this.session), f = a.element;
                this.dom.removeChildren(f), i.setStyle(f.style, "height", this.$lines.computeLineHeight(s, e, this.session) + "px"), i.setStyle(f.style, "top", this.$lines.computeLineTop(s, e, this.session) + "px"), this.$renderLine(f, s, s == u ? o : !1), this.$useLineGroups() ? f.className = "ace_line_group" : f.className = "ace_line", r.push(a), s++;
            }
            return r;
        }, e.prototype.update = function(e) {
            this.$lines.moveContainer(e), this.config = e;
            var t = e.firstRow, n = e.lastRow, r = this.$lines;
            while(r.getLength())r.pop();
            r.push(this.$renderLinesFragment(e, t, n));
        }, e.prototype.$renderToken = function(e, t, n, r) {
            var i = this, o = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, u = this.dom.createFragment(this.element), l, c = 0;
            while(l = o.exec(r)){
                var h = l[1], p = l[2], d = l[3], v = l[4], m = l[5];
                if (!i.showSpaces && p) continue;
                var g = c != l.index ? r.slice(c, l.index) : "";
                c = l.index + l[0].length, g && u.appendChild(this.dom.createTextNode(g, this.element));
                if (h) {
                    var y = i.session.getScreenTabSize(t + l.index);
                    u.appendChild(i.$tabStrings[y].cloneNode(!0)), t += y - 1;
                } else if (p) {
                    if (i.showSpaces) {
                        var b = this.dom.createElement("span");
                        b.className = "ace_invisible ace_invisible_space", b.textContent = s.stringRepeat(i.SPACE_CHAR, p.length), u.appendChild(b);
                    } else u.appendChild(this.dom.createTextNode(p, this.element));
                } else if (d) {
                    var b = this.dom.createElement("span");
                    b.className = "ace_invisible ace_invisible_space ace_invalid", b.textContent = s.stringRepeat(i.SPACE_CHAR, d.length), u.appendChild(b);
                } else if (v) {
                    t += 1;
                    var b = this.dom.createElement("span");
                    b.style.width = i.config.characterWidth * 2 + "px", b.className = i.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk", b.textContent = i.showSpaces ? i.SPACE_CHAR : v, u.appendChild(b);
                } else if (m) {
                    t += 1;
                    var b = this.dom.createElement("span");
                    b.style.width = i.config.characterWidth * 2 + "px", b.className = "ace_cjk", b.textContent = m, u.appendChild(b);
                }
            }
            u.appendChild(this.dom.createTextNode(c ? r.slice(c) : r, this.element));
            if (!f(n.type)) {
                var w = "ace_" + n.type.replace(/\./g, " ace_"), b = this.dom.createElement("span");
                n.type == "fold" && (b.style.width = n.value.length * this.config.characterWidth + "px", b.setAttribute("title", a("inline-fold.closed.title", "Unfold code"))), b.className = w, b.appendChild(u), e.appendChild(b);
            } else e.appendChild(u);
            return t + r.length;
        }, e.prototype.renderIndentGuide = function(e, t, n) {
            var r = t.search(this.$indentGuideRe);
            if (r <= 0 || r >= n) return t;
            if (t[0] == " ") {
                r -= r % this.tabSize;
                var i = r / this.tabSize;
                for(var s = 0; s < i; s++)e.appendChild(this.$tabStrings[" "].cloneNode(!0));
                return this.$highlightIndentGuide(), t.substr(r);
            }
            if (t[0] == "	") {
                for(var s = 0; s < r; s++)e.appendChild(this.$tabStrings["	"].cloneNode(!0));
                return this.$highlightIndentGuide(), t.substr(r);
            }
            return this.$highlightIndentGuide(), t;
        }, e.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides) return;
            this.$highlightIndentGuideMarker = {
                indentLevel: undefined,
                start: undefined,
                end: undefined,
                dir: undefined
            };
            var e = this.session.doc.$lines;
            if (!e) return;
            var t = this.session.selection.getCursor(), n = /^\s*/.exec(this.session.doc.getLine(t.row))[0].length, r = Math.floor(n / this.tabSize);
            this.$highlightIndentGuideMarker = {
                indentLevel: r,
                start: t.row
            };
            var i = this.session.$bracketHighlight;
            if (i) {
                var s = this.session.$bracketHighlight.ranges;
                for(var o = 0; o < s.length; o++)if (t.row !== s[o].start.row) {
                    this.$highlightIndentGuideMarker.end = s[o].start.row + 1, t.row > s[o].start.row ? this.$highlightIndentGuideMarker.dir = -1 : this.$highlightIndentGuideMarker.dir = 1;
                    break;
                }
            }
            if (!this.$highlightIndentGuideMarker.end && e[t.row] !== "" && t.column === e[t.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for(var o = t.row + 1; o < e.length; o++){
                    var u = e[o], a = /^\s*/.exec(u)[0].length;
                    if (u !== "") {
                        this.$highlightIndentGuideMarker.end = o;
                        if (a <= n) break;
                    }
                }
            }
            this.$renderHighlightIndentGuide();
        }, e.prototype.$clearActiveIndentGuide = function() {
            var e = this.element.querySelectorAll(".ace_indent-guide-active");
            for(var t = 0; t < e.length; t++)e[t].classList.remove("ace_indent-guide-active");
        }, e.prototype.$setIndentGuideActive = function(e, t) {
            var n = this.session.doc.getLine(e.row);
            if (n !== "") {
                var r = e.element;
                if (e.element.classList && e.element.classList.contains("ace_line_group")) {
                    if (!(e.element.childNodes.length > 0)) return;
                    r = e.element.childNodes[0];
                }
                var i = r.childNodes;
                if (i) {
                    var s = i[t - 1];
                    s && s.classList && s.classList.contains("ace_indent-guide") && s.classList.add("ace_indent-guide-active");
                }
            }
        }, e.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines) return;
            var e = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var t = this.$highlightIndentGuideMarker.indentLevel;
            if (t !== 0) {
                if (this.$highlightIndentGuideMarker.dir === 1) for(var n = 0; n < e.length; n++){
                    var r = e[n];
                    if (this.$highlightIndentGuideMarker.end && r.row >= this.$highlightIndentGuideMarker.start + 1) {
                        if (r.row >= this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(r, t);
                    }
                }
                else for(var n = e.length - 1; n >= 0; n--){
                    var r = e[n];
                    if (this.$highlightIndentGuideMarker.end && r.row < this.$highlightIndentGuideMarker.start) {
                        if (r.row < this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(r, t);
                    }
                }
            }
        }, e.prototype.$createLineElement = function(e) {
            var t = this.dom.createElement("div");
            return t.className = "ace_line", t.style.height = this.config.lineHeight + "px", t;
        }, e.prototype.$renderWrappedLine = function(e, t, n) {
            var r = 0, i = 0, o = n[0], u = 0, a = this.$createLineElement();
            e.appendChild(a);
            for(var f = 0; f < t.length; f++){
                var l = t[f], c = l.value;
                if (f == 0 && this.displayIndentGuides) {
                    r = c.length, c = this.renderIndentGuide(a, c, o);
                    if (!c) continue;
                    r -= c.length;
                }
                if (r + c.length < o) u = this.$renderToken(a, u, l, c), r += c.length;
                else {
                    while(r + c.length >= o)u = this.$renderToken(a, u, l, c.substring(0, o - r)), c = c.substring(o - r), r = o, a = this.$createLineElement(), e.appendChild(a), a.appendChild(this.dom.createTextNode(s.stringRepeat("\xa0", n.indent), this.element)), i++, u = 0, o = n[i] || Number.MAX_VALUE;
                    c.length != 0 && (r += c.length, u = this.$renderToken(a, u, l, c));
                }
            }
            n[n.length - 1] > this.MAX_LINE_LENGTH && this.$renderOverflowMessage(a, u, null, "", !0);
        }, e.prototype.$renderSimpleLine = function(e, t) {
            var n = 0;
            for(var r = 0; r < t.length; r++){
                var i = t[r], s = i.value;
                if (r == 0 && this.displayIndentGuides) {
                    s = this.renderIndentGuide(e, s);
                    if (!s) continue;
                }
                if (n + s.length > this.MAX_LINE_LENGTH) return this.$renderOverflowMessage(e, n, i, s);
                n = this.$renderToken(e, n, i, s);
            }
        }, e.prototype.$renderOverflowMessage = function(e, t, n, r, i) {
            n && this.$renderToken(e, t, n, r.slice(0, this.MAX_LINE_LENGTH - t));
            var s = this.dom.createElement("span");
            s.className = "ace_inline_button ace_keyword ace_toggle_wrap", s.textContent = i ? "<hide>" : "<click to see more...>", e.appendChild(s);
        }, e.prototype.$renderLine = function(e, t, n) {
            !n && n != 0 && (n = this.session.getFoldLine(t));
            if (n) var r = this.$getFoldLineTokens(t, n);
            else var r = this.session.getTokens(t);
            var i = e;
            if (r.length) {
                var s = this.session.getRowSplitData(t);
                if (s && s.length) {
                    this.$renderWrappedLine(e, r, s);
                    var i = e.lastChild;
                } else {
                    var i = e;
                    this.$useLineGroups() && (i = this.$createLineElement(), e.appendChild(i)), this.$renderSimpleLine(i, r);
                }
            } else this.$useLineGroups() && (i = this.$createLineElement(), e.appendChild(i));
            if (this.showEOL && i) {
                n && (t = n.end.row);
                var o = this.dom.createElement("span");
                o.className = "ace_invisible ace_invisible_eol", o.textContent = t == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, i.appendChild(o);
            }
        }, e.prototype.$getFoldLineTokens = function(e, t) {
            function i(e, t, n) {
                var i = 0, s = 0;
                while(s + e[i].value.length < t){
                    s += e[i].value.length, i++;
                    if (i == e.length) return;
                }
                if (s != t) {
                    var o = e[i].value.substring(t - s);
                    o.length > n - t && (o = o.substring(0, n - t)), r.push({
                        type: e[i].type,
                        value: o
                    }), s = t + o.length, i += 1;
                }
                while(s < n && i < e.length){
                    var o = e[i].value;
                    o.length + s > n ? r.push({
                        type: e[i].type,
                        value: o.substring(0, n - s)
                    }) : r.push(e[i]), s += o.length, i += 1;
                }
            }
            var n = this.session, r = [], s = n.getTokens(e);
            return t.walk(function(e, t, o, u, a) {
                e != null ? r.push({
                    type: "fold",
                    value: e
                }) : (a && (s = n.getTokens(t)), s.length && i(s, u, o));
            }, t.end.row, this.session.getLine(t.end.row).length), r;
        }, e.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
        }, e;
    }();
    l.prototype.EOF_CHAR = "\xb6", l.prototype.EOL_CHAR_LF = "\xac", l.prototype.EOL_CHAR_CRLF = "\xa4", l.prototype.EOL_CHAR = l.prototype.EOL_CHAR_LF, l.prototype.TAB_CHAR = "‚Äî", l.prototype.SPACE_CHAR = "\xb7", l.prototype.$padding = 0, l.prototype.MAX_LINE_LENGTH = 1e4, l.prototype.showInvisibles = !1, l.prototype.showSpaces = !1, l.prototype.showTabs = !1, l.prototype.showEOL = !1, l.prototype.displayIndentGuides = !0, l.prototype.$highlightIndentGuides = !0, l.prototype.$tabStrings = [], l.prototype.destroy = {}, l.prototype.onChangeTabSize = l.prototype.$computeTabString, r.implement(l.prototype, u), t.Text = l;
}), ace.define("ace/layer/cursor", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/dom"), i = function() {
        function e(e) {
            this.element = r.createElement("div"), this.element.className = "ace_layer ace_cursor-layer", e.appendChild(this.element), this.isVisible = !1, this.isBlinking = !0, this.blinkInterval = 1e3, this.smoothBlinking = !1, this.cursors = [], this.cursor = this.addCursor(), r.addCssClass(this.element, "ace_hidden-cursors"), this.$updateCursors = this.$updateOpacity.bind(this);
        }
        return e.prototype.$updateOpacity = function(e) {
            var t = this.cursors;
            for(var n = t.length; n--;)r.setStyle(t[n].style, "opacity", e ? "" : "0");
        }, e.prototype.$startCssAnimation = function() {
            var e = this.cursors;
            for(var t = e.length; t--;)e[t].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = !0, setTimeout((function() {
                this.$isAnimating && r.addCssClass(this.element, "ace_animate-blinking");
            }).bind(this));
        }, e.prototype.$stopCssAnimation = function() {
            this.$isAnimating = !1, r.removeCssClass(this.element, "ace_animate-blinking");
        }, e.prototype.setPadding = function(e) {
            this.$padding = e;
        }, e.prototype.setSession = function(e) {
            this.session = e;
        }, e.prototype.setBlinking = function(e) {
            e != this.isBlinking && (this.isBlinking = e, this.restartTimer());
        }, e.prototype.setBlinkInterval = function(e) {
            e != this.blinkInterval && (this.blinkInterval = e, this.restartTimer());
        }, e.prototype.setSmoothBlinking = function(e) {
            e != this.smoothBlinking && (this.smoothBlinking = e, r.setCssClass(this.element, "ace_smooth-blinking", e), this.$updateCursors(!0), this.restartTimer());
        }, e.prototype.addCursor = function() {
            var e = r.createElement("div");
            return e.className = "ace_cursor", this.element.appendChild(e), this.cursors.push(e), e;
        }, e.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
                var e = this.cursors.pop();
                return e.parentNode.removeChild(e), e;
            }
        }, e.prototype.hideCursor = function() {
            this.isVisible = !1, r.addCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
        }, e.prototype.showCursor = function() {
            this.isVisible = !0, r.removeCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
        }, e.prototype.restartTimer = function() {
            var e = this.$updateCursors;
            clearInterval(this.intervalId), clearTimeout(this.timeoutId), this.$stopCssAnimation(), this.smoothBlinking && (this.$isSmoothBlinking = !1, r.removeCssClass(this.element, "ace_smooth-blinking")), e(!0);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
                this.$stopCssAnimation();
                return;
            }
            this.smoothBlinking && (this.$isSmoothBlinking = !0, setTimeout((function() {
                this.$isSmoothBlinking && r.addCssClass(this.element, "ace_smooth-blinking");
            }).bind(this)));
            if (r.HAS_CSS_ANIMATION) this.$startCssAnimation();
            else {
                var t = (function() {
                    this.timeoutId = setTimeout(function() {
                        e(!1);
                    }, .6 * this.blinkInterval);
                }).bind(this);
                this.intervalId = setInterval(function() {
                    e(!0), t();
                }, this.blinkInterval), t();
            }
        }, e.prototype.getPixelPosition = function(e, t) {
            if (!this.config || !this.session) return {
                left: 0,
                top: 0
            };
            e || (e = this.session.selection.getCursor());
            var n = this.session.documentToScreenPosition(e), r = this.$padding + (this.session.$bidiHandler.isBidiRow(n.row, e.row) ? this.session.$bidiHandler.getPosLeft(n.column) : n.column * this.config.characterWidth), i = (n.row - (t ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return {
                left: r,
                top: i
            };
        }, e.prototype.isCursorInView = function(e, t) {
            return e.top >= 0 && e.top < t.maxHeight;
        }, e.prototype.update = function(e) {
            this.config = e;
            var t = this.session.$selectionMarkers, n = 0, i = 0;
            if (t === undefined || t.length === 0) t = [
                {
                    cursor: null
                }
            ];
            for(var n = 0, s = t.length; n < s; n++){
                var o = this.getPixelPosition(t[n].cursor, !0);
                if ((o.top > e.height + e.offset || o.top < 0) && n > 1) continue;
                var u = this.cursors[i++] || this.addCursor(), a = u.style;
                this.drawCursor ? this.drawCursor(u, o, e, t[n], this.session) : this.isCursorInView(o, e) ? (r.setStyle(a, "display", "block"), r.translate(u, o.left, o.top), r.setStyle(a, "width", Math.round(e.characterWidth) + "px"), r.setStyle(a, "height", e.lineHeight + "px")) : r.setStyle(a, "display", "none");
            }
            while(this.cursors.length > i)this.removeCursor();
            var f = this.session.getOverwrite();
            this.$setOverwrite(f), this.$pixelPos = o, this.restartTimer();
        }, e.prototype.$setOverwrite = function(e) {
            e != this.overwrite && (this.overwrite = e, e ? r.addCssClass(this.element, "ace_overwrite-cursors") : r.removeCssClass(this.element, "ace_overwrite-cursors"));
        }, e.prototype.destroy = function() {
            clearInterval(this.intervalId), clearTimeout(this.timeoutId);
        }, e;
    }();
    i.prototype.$padding = 0, i.prototype.drawCursor = null, t.Cursor = i;
}), ace.define("ace/scrollbar", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = e("./lib/oop"), s = e("./lib/dom"), o = e("./lib/event"), u = e("./lib/event_emitter").EventEmitter, a = 32768, f = function() {
        function e(e, t) {
            this.element = s.createElement("div"), this.element.className = "ace_scrollbar ace_scrollbar" + t, this.inner = s.createElement("div"), this.inner.className = "ace_scrollbar-inner", this.inner.textContent = "\xa0", this.element.appendChild(this.inner), e.appendChild(this.element), this.setVisible(!1), this.skipEvent = !1, o.addListener(this.element, "scroll", this.onScroll.bind(this)), o.addListener(this.element, "mousedown", o.preventDefault);
        }
        return e.prototype.setVisible = function(e) {
            this.element.style.display = e ? "" : "none", this.isVisible = e, this.coeff = 1;
        }, e;
    }();
    i.implement(f.prototype, u);
    var l = function(e) {
        function t(t, n) {
            var r = e.call(this, t, "-v") || this;
            return r.scrollTop = 0, r.scrollHeight = 0, n.$scrollbarWidth = r.width = s.scrollbarWidth(t.ownerDocument), r.inner.style.width = r.element.style.width = (r.width || 15) + 5 + "px", r.$minWidth = 0, r;
        }
        return r(t, e), t.prototype.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollTop = this.element.scrollTop;
                if (this.coeff != 1) {
                    var e = this.element.clientHeight / this.scrollHeight;
                    this.scrollTop = this.scrollTop * (1 - e) / (this.coeff - e);
                }
                this._emit("scroll", {
                    data: this.scrollTop
                });
            }
            this.skipEvent = !1;
        }, t.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        }, t.prototype.setHeight = function(e) {
            this.element.style.height = e + "px";
        }, t.prototype.setScrollHeight = function(e) {
            this.scrollHeight = e, e > a ? (this.coeff = a / e, e = a) : this.coeff != 1 && (this.coeff = 1), this.inner.style.height = e + "px";
        }, t.prototype.setScrollTop = function(e) {
            this.scrollTop != e && (this.skipEvent = !0, this.scrollTop = e, this.element.scrollTop = e * this.coeff);
        }, t;
    }(f);
    l.prototype.setInnerHeight = l.prototype.setScrollHeight;
    var c = function(e) {
        function t(t, n) {
            var r = e.call(this, t, "-h") || this;
            return r.scrollLeft = 0, r.height = n.$scrollbarWidth, r.inner.style.height = r.element.style.height = (r.height || 15) + 5 + "px", r;
        }
        return r(t, e), t.prototype.onScroll = function() {
            this.skipEvent || (this.scrollLeft = this.element.scrollLeft, this._emit("scroll", {
                data: this.scrollLeft
            })), this.skipEvent = !1;
        }, t.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
        }, t.prototype.setWidth = function(e) {
            this.element.style.width = e + "px";
        }, t.prototype.setInnerWidth = function(e) {
            this.inner.style.width = e + "px";
        }, t.prototype.setScrollWidth = function(e) {
            this.inner.style.width = e + "px";
        }, t.prototype.setScrollLeft = function(e) {
            this.scrollLeft != e && (this.skipEvent = !0, this.scrollLeft = this.element.scrollLeft = e);
        }, t;
    }(f);
    t.ScrollBar = l, t.ScrollBarV = l, t.ScrollBarH = c, t.VScrollBar = l, t.HScrollBar = c;
}), ace.define("ace/scrollbar_custom", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    var r = this && this.__extends || function() {
        var e = function(t, n) {
            return e = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(e, t) {
                e.__proto__ = t;
            } || function(e, t) {
                for(var n in t)Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
            }, e(t, n);
        };
        return function(t, n) {
            function r() {
                this.constructor = t;
            }
            if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
            e(t, n), t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r);
        };
    }(), i = e("./lib/oop"), s = e("./lib/dom"), o = e("./lib/event"), u = e("./lib/event_emitter").EventEmitter;
    s.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", !1);
    var a = function() {
        function e(e, t) {
            this.element = s.createElement("div"), this.element.className = "ace_sb" + t, this.inner = s.createElement("div"), this.inner.className = "", this.element.appendChild(this.inner), this.VScrollWidth = 12, this.HScrollHeight = 12, e.appendChild(this.element), this.setVisible(!1), this.skipEvent = !1, o.addMultiMouseDownListener(this.element, [
                500,
                300,
                300
            ], this, "onMouseDown");
        }
        return e.prototype.setVisible = function(e) {
            this.element.style.display = e ? "" : "none", this.isVisible = e, this.coeff = 1;
        }, e;
    }();
    i.implement(a.prototype, u);
    var f = function(e) {
        function t(t, n) {
            var r = e.call(this, t, "-v") || this;
            return r.scrollTop = 0, r.scrollHeight = 0, r.parent = t, r.width = r.VScrollWidth, r.renderer = n, r.inner.style.width = r.element.style.width = (r.width || 15) + "px", r.$minWidth = 0, r;
        }
        return r(t, e), t.prototype.onMouseDown = function(e, t) {
            if (e !== "mousedown") return;
            if (o.getButton(t) !== 0 || t.detail === 2) return;
            if (t.target === this.inner) {
                var n = this, r = t.clientY, i = function(e) {
                    r = e.clientY;
                }, s = function() {
                    clearInterval(l);
                }, u = t.clientY, a = this.thumbTop, f = function() {
                    if (r === undefined) return;
                    var e = n.scrollTopFromThumbTop(a + r - u);
                    if (e === n.scrollTop) return;
                    n._emit("scroll", {
                        data: e
                    });
                };
                o.capture(this.inner, i, s);
                var l = setInterval(f, 20);
                return o.preventDefault(t);
            }
            var c = t.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            return this._emit("scroll", {
                data: this.scrollTopFromThumbTop(c)
            }), o.preventDefault(t);
        }, t.prototype.getHeight = function() {
            return this.height;
        }, t.prototype.scrollTopFromThumbTop = function(e) {
            var t = e * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            return t >>= 0, t < 0 ? t = 0 : t > this.pageHeight - this.viewHeight && (t = this.pageHeight - this.viewHeight), t;
        }, t.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        }, t.prototype.setHeight = function(e) {
            this.height = Math.max(0, e), this.slideHeight = this.height, this.viewHeight = this.height, this.setScrollHeight(this.pageHeight, !0);
        }, t.prototype.setScrollHeight = function(e, t) {
            if (this.pageHeight === e && !t) return;
            this.pageHeight = e, this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight, this.thumbHeight > this.slideHeight && (this.thumbHeight = this.slideHeight), this.thumbHeight < 15 && (this.thumbHeight = 15), this.inner.style.height = this.thumbHeight + "px", this.scrollTop > this.pageHeight - this.viewHeight && (this.scrollTop = this.pageHeight - this.viewHeight, this.scrollTop < 0 && (this.scrollTop = 0), this._emit("scroll", {
                data: this.scrollTop
            }));
        }, t.prototype.setScrollTop = function(e) {
            this.scrollTop = e, e < 0 && (e = 0), this.thumbTop = e * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight), this.inner.style.top = this.thumbTop + "px";
        }, t;
    }(a);
    f.prototype.setInnerHeight = f.prototype.setScrollHeight;
    var l = function(e) {
        function t(t, n) {
            var r = e.call(this, t, "-h") || this;
            return r.scrollLeft = 0, r.scrollWidth = 0, r.height = r.HScrollHeight, r.inner.style.height = r.element.style.height = (r.height || 12) + "px", r.renderer = n, r;
        }
        return r(t, e), t.prototype.onMouseDown = function(e, t) {
            if (e !== "mousedown") return;
            if (o.getButton(t) !== 0 || t.detail === 2) return;
            if (t.target === this.inner) {
                var n = this, r = t.clientX, i = function(e) {
                    r = e.clientX;
                }, s = function() {
                    clearInterval(l);
                }, u = t.clientX, a = this.thumbLeft, f = function() {
                    if (r === undefined) return;
                    var e = n.scrollLeftFromThumbLeft(a + r - u);
                    if (e === n.scrollLeft) return;
                    n._emit("scroll", {
                        data: e
                    });
                };
                o.capture(this.inner, i, s);
                var l = setInterval(f, 20);
                return o.preventDefault(t);
            }
            var c = t.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            return this._emit("scroll", {
                data: this.scrollLeftFromThumbLeft(c)
            }), o.preventDefault(t);
        }, t.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
        }, t.prototype.scrollLeftFromThumbLeft = function(e) {
            var t = e * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            return t >>= 0, t < 0 ? t = 0 : t > this.pageWidth - this.viewWidth && (t = this.pageWidth - this.viewWidth), t;
        }, t.prototype.setWidth = function(e) {
            this.width = Math.max(0, e), this.element.style.width = this.width + "px", this.slideWidth = this.width, this.viewWidth = this.width, this.setScrollWidth(this.pageWidth, !0);
        }, t.prototype.setScrollWidth = function(e, t) {
            if (this.pageWidth === e && !t) return;
            this.pageWidth = e, this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth, this.thumbWidth > this.slideWidth && (this.thumbWidth = this.slideWidth), this.thumbWidth < 15 && (this.thumbWidth = 15), this.inner.style.width = this.thumbWidth + "px", this.scrollLeft > this.pageWidth - this.viewWidth && (this.scrollLeft = this.pageWidth - this.viewWidth, this.scrollLeft < 0 && (this.scrollLeft = 0), this._emit("scroll", {
                data: this.scrollLeft
            }));
        }, t.prototype.setScrollLeft = function(e) {
            this.scrollLeft = e, e < 0 && (e = 0), this.thumbLeft = e * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth), this.inner.style.left = this.thumbLeft + "px";
        }, t;
    }(a);
    l.prototype.setInnerWidth = l.prototype.setScrollWidth, t.ScrollBar = f, t.ScrollBarV = f, t.ScrollBarH = l, t.VScrollBar = f, t.HScrollBar = l;
}), ace.define("ace/renderloop", [
    "require",
    "exports",
    "module",
    "ace/lib/event"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/event"), i = function() {
        function e(e, t) {
            this.onRender = e, this.pending = !1, this.changes = 0, this.$recursionLimit = 2, this.window = t || window;
            var n = this;
            this._flush = function(e) {
                n.pending = !1;
                var t = n.changes;
                t && (r.blockIdle(100), n.changes = 0, n.onRender(t));
                if (n.changes) {
                    if (n.$recursionLimit-- < 0) return;
                    n.schedule();
                } else n.$recursionLimit = 2;
            };
        }
        return e.prototype.schedule = function(e) {
            this.changes = this.changes | e, this.changes && !this.pending && (r.nextFrame(this._flush), this.pending = !0);
        }, e.prototype.clear = function(e) {
            var t = this.changes;
            return this.changes = 0, t;
        }, e;
    }();
    t.RenderLoop = i;
}), ace.define("ace/layer/font_metrics", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/lib/event",
    "ace/lib/useragent",
    "ace/lib/event_emitter"
], function(e, t, n) {
    var r = e("../lib/oop"), i = e("../lib/dom"), s = e("../lib/lang"), o = e("../lib/event"), u = e("../lib/useragent"), a = e("../lib/event_emitter").EventEmitter, f = 512, l = typeof ResizeObserver == "function", c = 200, h = function() {
        function e(e) {
            this.el = i.createElement("div"), this.$setMeasureNodeStyles(this.el.style, !0), this.$main = i.createElement("div"), this.$setMeasureNodeStyles(this.$main.style), this.$measureNode = i.createElement("div"), this.$setMeasureNodeStyles(this.$measureNode.style), this.el.appendChild(this.$main), this.el.appendChild(this.$measureNode), e.appendChild(this.el), this.$measureNode.textContent = s.stringRepeat("X", f), this.$characterSize = {
                width: 0,
                height: 0
            }, l ? this.$addObserver() : this.checkForSizeChanges();
        }
        return e.prototype.$setMeasureNodeStyles = function(e, t) {
            e.width = e.height = "auto", e.left = e.top = "0px", e.visibility = "hidden", e.position = "absolute", e.whiteSpace = "pre", u.isIE < 8 ? e["font-family"] = "inherit" : e.font = "inherit", e.overflow = t ? "hidden" : "visible";
        }, e.prototype.checkForSizeChanges = function(e) {
            e === undefined && (e = this.$measureSizes());
            if (e && (this.$characterSize.width !== e.width || this.$characterSize.height !== e.height)) {
                this.$measureNode.style.fontWeight = "bold";
                var t = this.$measureSizes();
                this.$measureNode.style.fontWeight = "", this.$characterSize = e, this.charSizes = Object.create(null), this.allowBoldFonts = t && t.width === e.width && t.height === e.height, this._emit("changeCharacterSize", {
                    data: e
                });
            }
        }, e.prototype.$addObserver = function() {
            var e = this;
            this.$observer = new window.ResizeObserver(function(t) {
                e.checkForSizeChanges();
            }), this.$observer.observe(this.$measureNode);
        }, e.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer) return this.$pollSizeChangesTimer;
            var e = this;
            return this.$pollSizeChangesTimer = o.onIdle(function t() {
                e.checkForSizeChanges(), o.onIdle(t, 500);
            }, 500);
        }, e.prototype.setPolling = function(e) {
            e ? this.$pollSizeChanges() : this.$pollSizeChangesTimer && (clearInterval(this.$pollSizeChangesTimer), this.$pollSizeChangesTimer = 0);
        }, e.prototype.$measureSizes = function(e) {
            var t = {
                height: (e || this.$measureNode).clientHeight,
                width: (e || this.$measureNode).clientWidth / f
            };
            return t.width === 0 || t.height === 0 ? null : t;
        }, e.prototype.$measureCharWidth = function(e) {
            this.$main.textContent = s.stringRepeat(e, f);
            var t = this.$main.getBoundingClientRect();
            return t.width / f;
        }, e.prototype.getCharacterWidth = function(e) {
            var t = this.charSizes[e];
            return t === undefined && (t = this.charSizes[e] = this.$measureCharWidth(e) / this.$characterSize.width), t;
        }, e.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer), this.$observer && this.$observer.disconnect(), this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el);
        }, e.prototype.$getZoom = function(e) {
            return !e || !e.parentElement ? 1 : (Number(window.getComputedStyle(e).zoom) || 1) * this.$getZoom(e.parentElement);
        }, e.prototype.$initTransformMeasureNodes = function() {
            var e = function(e, t) {
                return [
                    "div",
                    {
                        style: "position: absolute;top:" + e + "px;left:" + t + "px;"
                    }
                ];
            };
            this.els = i.buildDom([
                e(0, 0),
                e(c, 0),
                e(0, c),
                e(c, c)
            ], this.el);
        }, e.prototype.transformCoordinates = function(e, t) {
            function r(e, t, n) {
                var r = e[1] * t[0] - e[0] * t[1];
                return [
                    (-t[1] * n[0] + t[0] * n[1]) / r,
                    (+e[1] * n[0] - e[0] * n[1]) / r
                ];
            }
            function i(e, t) {
                return [
                    e[0] - t[0],
                    e[1] - t[1]
                ];
            }
            function s(e, t) {
                return [
                    e[0] + t[0],
                    e[1] + t[1]
                ];
            }
            function o(e, t) {
                return [
                    e * t[0],
                    e * t[1]
                ];
            }
            function u(e) {
                var t = e.getBoundingClientRect();
                return [
                    t.left,
                    t.top
                ];
            }
            if (e) {
                var n = this.$getZoom(this.el);
                e = o(1 / n, e);
            }
            this.els || this.$initTransformMeasureNodes();
            var a = u(this.els[0]), f = u(this.els[1]), l = u(this.els[2]), h = u(this.els[3]), p = r(i(h, f), i(h, l), i(s(f, l), s(h, a))), d = o(1 + p[0], i(f, a)), v = o(1 + p[1], i(l, a));
            if (t) {
                var m = t, g = p[0] * m[0] / c + p[1] * m[1] / c + 1, y = s(o(m[0], d), o(m[1], v));
                return s(o(1 / g / c, y), a);
            }
            var b = i(e, a), w = r(i(d, o(p[0], b)), i(v, o(p[1], b)), b);
            return o(c, w);
        }, e;
    }();
    h.prototype.$characterSize = {
        width: 0,
        height: 0
    }, r.implement(h.prototype, a), t.FontMetrics = h;
}), ace.define("ace/css/editor-css", [
    "require",
    "exports",
    "module"
], function(e, t, n) {
    n.exports = '\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'Source Code Pro\', \'source-code-pro\', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    forced-color-adjust: none;\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n.ace_invisible {\n    font-variant-ligatures: none;\n}\n\n.ace_keyboard-focus:focus {\n    box-shadow: inset 0 0 0 2px #5E9ED6;\n    outline: none;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: \'\';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: "";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell_svg-icons .ace_gutter_annotation {\n    margin-left: -14px;\n    float: left;\n}\n\n.ace_gutter-cell .ace_gutter_annotation {\n    margin-left: -19px;\n    float: left;\n}\n\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");\n}\n\n.ace_icon_svg.ace_error {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: darkorange;\n}\n.ace_icon_svg.ace_info {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: royalblue;\n}\n.ace_icon_svg.ace_hint {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");\n    background-color: silver;\n}\n\n.ace_icon_svg.ace_error_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");\n    background-color: darkorange;\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");\n}\n\n.ace_tooltip {\n    background-color: #f5f5f5;\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n    overflow: auto;\n    max-width: min(33em, 66vw);\n    overscroll-behavior: contain;\n}\n.ace_tooltip pre {\n    white-space: pre-wrap;\n}\n\n.ace_tooltip.ace_dark {\n    background-color: #636363;\n    color: #fff;\n}\n\n.ace_tooltip:focus {\n    outline: 1px solid #5E9ED6;\n}\n\n.ace_icon {\n    display: inline-block;\n    width: 18px;\n    vertical-align: top;\n}\n\n.ace_icon_svg {\n    display: inline-block;\n    width: 12px;\n    vertical-align: top;\n    -webkit-mask-repeat: no-repeat;\n    -webkit-mask-size: 12px;\n    -webkit-mask-position: center;\n}\n\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_fold-widget, .ace_custom-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_custom-widget {\n    background: none;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    position: relative;\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n    z-index: 1;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n}\n\n.ace_ghost_text_container > div {\n    white-space: pre;\n}\n\n.ghost_text_line_wrapped::after {\n    content: "‚Ü©";\n    position: absolute;\n}\n\n.ace_lineWidgetContainer.ace_ghost_text {\n    margin: 0px 4px\n}\n\n.ace_screenreader-only {\n    position:absolute;\n    left:-10000px;\n    top:auto;\n    width:1px;\n    height:1px;\n    overflow:hidden;\n}\n\n.ace_hidden_token {\n    display: none;\n}';
}), ace.define("ace/layer/decorators", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(e, t, n) {
    "use strict";
    var r = e("../lib/dom"), i = e("../lib/oop"), s = e("../lib/event_emitter").EventEmitter, o = function() {
        function e(e, t) {
            this.parentEl = e, this.canvas = r.createElement("canvas"), this.renderer = t, this.pixelRatio = 1, this.maxHeight = t.layerConfig.maxHeight, this.lineHeight = t.layerConfig.lineHeight, this.minDecorationHeight = 2 * this.pixelRatio | 0, this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0, this.canvas.style.top = "0px", this.canvas.style.right = "0px", this.canvas.style.zIndex = "7px", this.canvas.style.position = "absolute", this.colors = {}, this.colors.dark = {
                error: "rgba(255, 18, 18, 1)",
                warning: "rgba(18, 136, 18, 1)",
                info: "rgba(18, 18, 136, 1)"
            }, this.colors.light = {
                error: "rgb(255,51,51)",
                warning: "rgb(32,133,72)",
                info: "rgb(35,68,138)"
            }, this.setDimensions(), e.element.appendChild(this.canvas);
        }
        return e.prototype.$updateDecorators = function(e) {
            function r(e, t) {
                return e.priority < t.priority ? -1 : e.priority > t.priority ? 1 : 0;
            }
            var t = this.renderer.theme.isDark === !0 ? this.colors.dark : this.colors.light;
            this.setDimensions(e);
            var n = this.canvas.getContext("2d"), i = this.renderer.session.$annotations;
            n.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (i) {
                var s = {
                    info: 1,
                    warning: 2,
                    error: 3
                };
                i.forEach(function(e) {
                    e.priority = s[e.type] || null;
                }), i = i.sort(r);
                for(var o = 0; o < i.length; o++){
                    var u = i[o].row, a = this.compensateFoldRows(u), f = Math.round((u - a) * this.lineHeight * this.heightRatio), l = Math.round((u - a) * this.lineHeight * this.heightRatio), c = Math.round(((u - a) * this.lineHeight + this.lineHeight) * this.heightRatio), h = c - l;
                    if (h < this.minDecorationHeight) {
                        var p = (l + c) / 2 | 0;
                        p < this.halfMinDecorationHeight ? p = this.halfMinDecorationHeight : p + this.halfMinDecorationHeight > this.canvasHeight && (p = this.canvasHeight - this.halfMinDecorationHeight), l = Math.round(p - this.halfMinDecorationHeight), c = Math.round(p + this.halfMinDecorationHeight);
                    }
                    n.fillStyle = t[i[o].type] || null, n.fillRect(0, f, this.canvasWidth, c - l);
                }
            }
            var d = this.renderer.session.selection.getCursor();
            if (d) {
                var a = this.compensateFoldRows(d.row), f = Math.round((d.row - a) * this.lineHeight * this.heightRatio);
                n.fillStyle = "rgba(0, 0, 0, 0.5)", n.fillRect(0, f, this.canvasWidth, 2);
            }
        }, e.prototype.compensateFoldRows = function(e) {
            var t = this.renderer.session.$foldData, n = 0;
            if (t && t.length > 0) for(var r = 0; r < t.length; r++)e > t[r].start.row && e < t[r].end.row ? n += e - t[r].start.row : e >= t[r].end.row && (n += t[r].end.row - t[r].start.row);
            return n;
        }, e.prototype.compensateLineWidgets = function(e) {
            var t = this.renderer.session.widgetManager;
            if (t) {
                var n = 0;
                return t.lineWidgets.forEach(function(t, r) {
                    e > r && (n += t.rowCount || 0);
                }), n - 1;
            }
            return 0;
        }, e.prototype.setDimensions = function(e) {
            e ? (this.maxHeight = e.maxHeight, this.lineHeight = e.lineHeight, this.canvasHeight = e.height, this.maxHeight < this.canvasHeight ? this.heightRatio = 1 : this.heightRatio = this.canvasHeight / this.maxHeight) : (this.canvasHeight = this.parentEl.parent.scrollHeight || this.canvasHeight, this.canvasWidth = this.parentEl.width || this.canvasWidth, this.heightRatio = this.canvasHeight / this.maxHeight, this.canvas.width = this.canvasWidth, this.canvas.height = this.canvasHeight);
        }, e;
    }();
    i.implement(o.prototype, s), t.Decorator = o;
}), ace.define("ace/virtual_renderer", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/config",
    "ace/layer/gutter",
    "ace/layer/marker",
    "ace/layer/text",
    "ace/layer/cursor",
    "ace/scrollbar",
    "ace/scrollbar",
    "ace/scrollbar_custom",
    "ace/scrollbar_custom",
    "ace/renderloop",
    "ace/layer/font_metrics",
    "ace/lib/event_emitter",
    "ace/css/editor-css",
    "ace/layer/decorators",
    "ace/lib/useragent",
    "ace/layer/text_util"
], function(e, t, n) {
    "use strict";
    var r = e("./lib/oop"), i = e("./lib/dom"), s = e("./lib/lang"), o = e("./config"), u = e("./layer/gutter").Gutter, a = e("./layer/marker").Marker, f = e("./layer/text").Text, l = e("./layer/cursor").Cursor, c = e("./scrollbar").HScrollBar, h = e("./scrollbar").VScrollBar, p = e("./scrollbar_custom").HScrollBar, d = e("./scrollbar_custom").VScrollBar, v = e("./renderloop").RenderLoop, m = e("./layer/font_metrics").FontMetrics, g = e("./lib/event_emitter").EventEmitter, y = e("./css/editor-css"), b = e("./layer/decorators").Decorator, w = e("./lib/useragent"), E = e("./layer/text_util").isTextToken;
    i.importCssString(y, "ace_editor.css", !1);
    var S = function() {
        function e(e, t) {
            var n = this;
            this.container = e || i.createElement("div"), i.addCssClass(this.container, "ace_editor"), i.HI_DPI && i.addCssClass(this.container, "ace_hidpi"), this.setTheme(t), o.get("useStrictCSP") == null && o.set("useStrictCSP", !1), this.$gutter = i.createElement("div"), this.$gutter.className = "ace_gutter", this.container.appendChild(this.$gutter), this.$gutter.setAttribute("aria-hidden", "true"), this.scroller = i.createElement("div"), this.scroller.className = "ace_scroller", this.container.appendChild(this.scroller), this.content = i.createElement("div"), this.content.className = "ace_content", this.scroller.appendChild(this.content), this.$gutterLayer = new u(this.$gutter), this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this)), this.$markerBack = new a(this.content);
            var r = this.$textLayer = new f(this.content);
            this.canvas = r.element, this.$markerFront = new a(this.content), this.$cursorLayer = new l(this.content), this.$horizScroll = !1, this.$vScroll = !1, this.scrollBar = this.scrollBarV = new h(this.container, this), this.scrollBarH = new c(this.container, this), this.scrollBarV.on("scroll", function(e) {
                n.$scrollAnimation || n.session.setScrollTop(e.data - n.scrollMargin.top);
            }), this.scrollBarH.on("scroll", function(e) {
                n.$scrollAnimation || n.session.setScrollLeft(e.data - n.scrollMargin.left);
            }), this.scrollTop = 0, this.scrollLeft = 0, this.cursorPos = {
                row: 0,
                column: 0
            }, this.$fontMetrics = new m(this.container), this.$textLayer.$setFontMetrics(this.$fontMetrics), this.$textLayer.on("changeCharacterSize", function(e) {
                n.updateCharacterSize(), n.onResize(!0, n.gutterWidth, n.$size.width, n.$size.height), n._signal("changeCharacterSize", e);
            }), this.$size = {
                width: 0,
                height: 0,
                scrollerHeight: 0,
                scrollerWidth: 0,
                $dirty: !0
            }, this.layerConfig = {
                width: 1,
                padding: 0,
                firstRow: 0,
                firstRowScreen: 0,
                lastRow: 0,
                lineHeight: 0,
                characterWidth: 0,
                minHeight: 1,
                maxHeight: 1,
                offset: 0,
                height: 1,
                gutterOffset: 1
            }, this.scrollMargin = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                v: 0,
                h: 0
            }, this.margin = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                v: 0,
                h: 0
            }, this.$keepTextAreaAtCursor = !w.isIOS, this.$loop = new v(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView), this.$loop.schedule(this.CHANGE_FULL), this.updateCharacterSize(), this.setPadding(4), this.$addResizeObserver(), o.resetOptions(this), o._signal("renderer", this);
        }
        return e.prototype.updateCharacterSize = function() {
            this.$textLayer.allowBoldFonts != this.$allowBoldFonts && (this.$allowBoldFonts = this.$textLayer.allowBoldFonts, this.setStyle("ace_nobold", !this.$allowBoldFonts)), this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth(), this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight(), this.$updatePrintMargin(), i.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        }, e.prototype.setSession = function(e) {
            this.session && this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode), this.session = e, e && this.scrollMargin.top && e.getScrollTop() <= 0 && e.setScrollTop(-this.scrollMargin.top), this.$cursorLayer.setSession(e), this.$markerBack.setSession(e), this.$markerFront.setSession(e), this.$gutterLayer.setSession(e), this.$textLayer.setSession(e);
            if (!e) return;
            this.$loop.schedule(this.CHANGE_FULL), this.session.$setFontMetrics(this.$fontMetrics), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null, this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this), this.onChangeNewLineMode(), this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        }, e.prototype.updateLines = function(e, t, n) {
            t === undefined && (t = Infinity), this.$changedLines ? (this.$changedLines.firstRow > e && (this.$changedLines.firstRow = e), this.$changedLines.lastRow < t && (this.$changedLines.lastRow = t)) : this.$changedLines = {
                firstRow: e,
                lastRow: t
            };
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                if (!n) return;
                this.$changedLines.lastRow = this.layerConfig.lastRow;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
            this.$loop.schedule(this.CHANGE_LINES);
        }, e.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT), this.$textLayer.$updateEolChar(), this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        }, e.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER), this.$textLayer.onChangeTabSize();
        }, e.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
        }, e.prototype.updateFull = function(e) {
            e ? this.$renderChanges(this.CHANGE_FULL, !0) : this.$loop.schedule(this.CHANGE_FULL);
        }, e.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
        }, e.prototype.$updateSizeAsync = function() {
            this.$loop.pending ? this.$size.$dirty = !0 : this.onResize();
        }, e.prototype.onResize = function(e, t, n, r) {
            if (this.resizing > 2) return;
            this.resizing > 0 ? this.resizing++ : this.resizing = e ? 1 : 0;
            var i = this.container;
            r || (r = i.clientHeight || i.scrollHeight), !r && this.$maxLines && this.lineHeight > 1 && (!i.style.height || i.style.height == "0px") && (i.style.height = "1px", r = i.clientHeight || i.scrollHeight), n || (n = i.clientWidth || i.scrollWidth);
            var s = this.$updateCachedSize(e, t, n, r);
            this.$resizeTimer && this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !n && !r) return this.resizing = 0;
            e && (this.$gutterLayer.$padding = null), e ? this.$renderChanges(s | this.$changes, !0) : this.$loop.schedule(s | this.$changes), this.resizing && (this.resizing = 0), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null, this.$customScrollbar && this.$updateCustomScrollbar(!0);
        }, e.prototype.$updateCachedSize = function(e, t, n, r) {
            r -= this.$extraHeight || 0;
            var s = 0, o = this.$size, u = {
                width: o.width,
                height: o.height,
                scrollerHeight: o.scrollerHeight,
                scrollerWidth: o.scrollerWidth
            };
            r && (e || o.height != r) && (o.height = r, s |= this.CHANGE_SIZE, o.scrollerHeight = o.height, this.$horizScroll && (o.scrollerHeight -= this.scrollBarH.getHeight()), this.scrollBarV.setHeight(o.scrollerHeight), this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px", s |= this.CHANGE_SCROLL);
            if (n && (e || o.width != n)) {
                s |= this.CHANGE_SIZE, o.width = n, t == null && (t = this.$showGutter ? this.$gutter.offsetWidth : 0), this.gutterWidth = t, i.setStyle(this.scrollBarH.element.style, "left", t + "px"), i.setStyle(this.scroller.style, "left", t + this.margin.left + "px"), o.scrollerWidth = Math.max(0, n - t - this.scrollBarV.getWidth() - this.margin.h), i.setStyle(this.$gutter.style, "left", this.margin.left + "px");
                var a = this.scrollBarV.getWidth() + "px";
                i.setStyle(this.scrollBarH.element.style, "right", a), i.setStyle(this.scroller.style, "right", a), i.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight()), this.scrollBarH.setWidth(o.scrollerWidth);
                if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || e) s |= this.CHANGE_FULL;
            }
            return o.$dirty = !n || !r, s && this._signal("resize", u), s;
        }, e.prototype.onGutterResize = function(e) {
            var t = this.$showGutter ? e : 0;
            t != this.gutterWidth && (this.$changes |= this.$updateCachedSize(!0, t, this.$size.width, this.$size.height)), this.session.getUseWrapMode() && this.adjustWrapLimit() ? this.$loop.schedule(this.CHANGE_FULL) : this.$size.$dirty ? this.$loop.schedule(this.CHANGE_FULL) : this.$computeLayerConfig();
        }, e.prototype.adjustWrapLimit = function() {
            var e = this.$size.scrollerWidth - this.$padding * 2, t = Math.floor(e / this.characterWidth);
            return this.session.adjustWrapLimit(t, this.$showPrintMargin && this.$printMarginColumn);
        }, e.prototype.setAnimatedScroll = function(e) {
            this.setOption("animatedScroll", e);
        }, e.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
        }, e.prototype.setShowInvisibles = function(e) {
            this.setOption("showInvisibles", e), this.session.$bidiHandler.setShowInvisibles(e);
        }, e.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
        }, e.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
        }, e.prototype.setDisplayIndentGuides = function(e) {
            this.setOption("displayIndentGuides", e);
        }, e.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
        }, e.prototype.setHighlightIndentGuides = function(e) {
            this.setOption("highlightIndentGuides", e);
        }, e.prototype.setShowPrintMargin = function(e) {
            this.setOption("showPrintMargin", e);
        }, e.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
        }, e.prototype.setPrintMarginColumn = function(e) {
            this.setOption("printMarginColumn", e);
        }, e.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
        }, e.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
        }, e.prototype.setShowGutter = function(e) {
            return this.setOption("showGutter", e);
        }, e.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        }, e.prototype.setFadeFoldWidgets = function(e) {
            this.setOption("fadeFoldWidgets", e);
        }, e.prototype.setHighlightGutterLine = function(e) {
            this.setOption("highlightGutterLine", e);
        }, e.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        }, e.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl) return;
            if (!this.$printMarginEl) {
                var e = i.createElement("div");
                e.className = "ace_layer ace_print-margin-layer", this.$printMarginEl = i.createElement("div"), this.$printMarginEl.className = "ace_print-margin", e.appendChild(this.$printMarginEl), this.content.insertBefore(e, this.content.firstChild);
            }
            var t = this.$printMarginEl.style;
            t.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px", t.visibility = this.$showPrintMargin ? "visible" : "hidden", this.session && this.session.$wrap == -1 && this.adjustWrapLimit();
        }, e.prototype.getContainerElement = function() {
            return this.container;
        }, e.prototype.getMouseEventTarget = function() {
            return this.scroller;
        }, e.prototype.getTextAreaContainer = function() {
            return this.container;
        }, e.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed) return;
            var e = this.textarea.style, t = this.$composition;
            if (!this.$keepTextAreaAtCursor && !t) {
                i.translate(this.textarea, -100, 0);
                return;
            }
            var n = this.$cursorLayer.$pixelPos;
            if (!n) return;
            t && t.markerRange && (n = this.$cursorLayer.getPixelPosition(t.markerRange.start, !0));
            var r = this.layerConfig, s = n.top, o = n.left;
            s -= r.offset;
            var u = t && t.useTextareaForIME || w.isMobile ? this.lineHeight : 1;
            if (s < 0 || s > r.height - u) {
                i.translate(this.textarea, 0, 0);
                return;
            }
            var a = 1, f = this.$size.height - u;
            if (!t) s += this.lineHeight;
            else if (t.useTextareaForIME) {
                var l = this.textarea.value;
                a = this.characterWidth * this.session.$getStringScreenWidth(l)[0];
            } else s += this.lineHeight + 2;
            o -= this.scrollLeft, o > this.$size.scrollerWidth - a && (o = this.$size.scrollerWidth - a), o += this.gutterWidth + this.margin.left, i.setStyle(e, "height", u + "px"), i.setStyle(e, "width", a + "px"), i.translate(this.textarea, Math.min(o, this.$size.scrollerWidth - a), Math.min(s, f));
        }, e.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
        }, e.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        }, e.prototype.getLastFullyVisibleRow = function() {
            var e = this.layerConfig, t = e.lastRow, n = this.session.documentToScreenRow(t, 0) * e.lineHeight;
            return n - this.session.getScrollTop() > e.height - e.lineHeight ? t - 1 : t;
        }, e.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
        }, e.prototype.setPadding = function(e) {
            this.$padding = e, this.$textLayer.setPadding(e), this.$cursorLayer.setPadding(e), this.$markerFront.setPadding(e), this.$markerBack.setPadding(e), this.$loop.schedule(this.CHANGE_FULL), this.$updatePrintMargin();
        }, e.prototype.setScrollMargin = function(e, t, n, r) {
            var i = this.scrollMargin;
            i.top = e | 0, i.bottom = t | 0, i.right = r | 0, i.left = n | 0, i.v = i.top + i.bottom, i.h = i.left + i.right, i.top && this.scrollTop <= 0 && this.session && this.session.setScrollTop(-i.top), this.updateFull();
        }, e.prototype.setMargin = function(e, t, n, r) {
            var i = this.margin;
            i.top = e | 0, i.bottom = t | 0, i.right = r | 0, i.left = n | 0, i.v = i.top + i.bottom, i.h = i.left + i.right, this.$updateCachedSize(!0, this.gutterWidth, this.$size.width, this.$size.height), this.updateFull();
        }, e.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
        }, e.prototype.setHScrollBarAlwaysVisible = function(e) {
            this.setOption("hScrollBarAlwaysVisible", e);
        }, e.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
        }, e.prototype.setVScrollBarAlwaysVisible = function(e) {
            this.setOption("vScrollBarAlwaysVisible", e);
        }, e.prototype.$updateScrollBarV = function() {
            var e = this.layerConfig.maxHeight, t = this.$size.scrollerHeight;
            !this.$maxLines && this.$scrollPastEnd && (e -= (t - this.lineHeight) * this.$scrollPastEnd, this.scrollTop > e - t && (e = this.scrollTop + t, this.scrollBarV.scrollTop = null)), this.scrollBarV.setScrollHeight(e + this.scrollMargin.v), this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        }, e.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h), this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        }, e.prototype.freeze = function() {
            this.$frozen = !0;
        }, e.prototype.unfreeze = function() {
            this.$frozen = !1;
        }, e.prototype.$renderChanges = function(e, t) {
            this.$changes && (e |= this.$changes, this.$changes = 0);
            if (!this.session || !this.container.offsetWidth || this.$frozen || !e && !t) {
                this.$changes |= e;
                return;
            }
            if (this.$size.$dirty) return this.$changes |= e, this.onResize(!0);
            this.lineHeight || this.$textLayer.checkForSizeChanges(), this._signal("beforeRender", e), this.session && this.session.$bidiHandler && this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var n = this.layerConfig;
            if (e & this.CHANGE_FULL || e & this.CHANGE_SIZE || e & this.CHANGE_TEXT || e & this.CHANGE_LINES || e & this.CHANGE_SCROLL || e & this.CHANGE_H_SCROLL) {
                e |= this.$computeLayerConfig() | this.$loop.clear();
                if (n.firstRow != this.layerConfig.firstRow && n.firstRowScreen == this.layerConfig.firstRowScreen) {
                    var r = this.scrollTop + (n.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                    r > 0 && (this.scrollTop = r, e |= this.CHANGE_SCROLL, e |= this.$computeLayerConfig() | this.$loop.clear());
                }
                n = this.layerConfig, this.$updateScrollBarV(), e & this.CHANGE_H_SCROLL && this.$updateScrollBarH(), i.translate(this.content, -this.scrollLeft, -n.offset);
                var s = n.width + 2 * this.$padding + "px", o = n.minHeight + "px";
                i.setStyle(this.content.style, "width", s), i.setStyle(this.content.style, "height", o);
            }
            e & this.CHANGE_H_SCROLL && (i.translate(this.content, -this.scrollLeft, -n.offset), this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ", this.enableKeyboardAccessibility && (this.scroller.className += this.keyboardFocusClassName));
            if (e & this.CHANGE_FULL) {
                this.$changedLines = null, this.$textLayer.update(n), this.$showGutter && this.$gutterLayer.update(n), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n), this.$markerBack.update(n), this.$markerFront.update(n), this.$cursorLayer.update(n), this.$moveTextAreaToCursor(), this._signal("afterRender", e);
                return;
            }
            if (e & this.CHANGE_SCROLL) {
                this.$changedLines = null, e & this.CHANGE_TEXT || e & this.CHANGE_LINES ? this.$textLayer.update(n) : this.$textLayer.scrollLines(n), this.$showGutter && (e & this.CHANGE_GUTTER || e & this.CHANGE_LINES ? this.$gutterLayer.update(n) : this.$gutterLayer.scrollLines(n)), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n), this.$markerBack.update(n), this.$markerFront.update(n), this.$cursorLayer.update(n), this.$moveTextAreaToCursor(), this._signal("afterRender", e);
                return;
            }
            e & this.CHANGE_TEXT ? (this.$changedLines = null, this.$textLayer.update(n), this.$showGutter && this.$gutterLayer.update(n), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n)) : e & this.CHANGE_LINES ? ((this.$updateLines() || e & this.CHANGE_GUTTER && this.$showGutter) && this.$gutterLayer.update(n), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n)) : e & this.CHANGE_TEXT || e & this.CHANGE_GUTTER ? (this.$showGutter && this.$gutterLayer.update(n), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n)) : e & this.CHANGE_CURSOR && (this.$highlightGutterLine && this.$gutterLayer.updateLineHighlight(n), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(n)), e & this.CHANGE_CURSOR && (this.$cursorLayer.update(n), this.$moveTextAreaToCursor()), e & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT) && this.$markerFront.update(n), e & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK) && this.$markerBack.update(n), this._signal("afterRender", e);
        }, e.prototype.$autosize = function() {
            var e = this.session.getScreenLength() * this.lineHeight, t = this.$maxLines * this.lineHeight, n = Math.min(t, Math.max((this.$minLines || 1) * this.lineHeight, e)) + this.scrollMargin.v + (this.$extraHeight || 0);
            this.$horizScroll && (n += this.scrollBarH.getHeight()), this.$maxPixelHeight && n > this.$maxPixelHeight && (n = this.$maxPixelHeight);
            var r = n <= 2 * this.lineHeight, i = !r && e > t;
            if (n != this.desiredHeight || this.$size.height != this.desiredHeight || i != this.$vScroll) {
                i != this.$vScroll && (this.$vScroll = i, this.scrollBarV.setVisible(i));
                var s = this.container.clientWidth;
                this.container.style.height = n + "px", this.$updateCachedSize(!0, this.$gutterWidth, s, n), this.desiredHeight = n, this._signal("autosize");
            }
        }, e.prototype.$computeLayerConfig = function() {
            var e = this.session, t = this.$size, n = t.height <= 2 * this.lineHeight, r = this.session.getScreenLength(), i = r * this.lineHeight, s = this.$getLongestLine(), o = !n && (this.$hScrollBarAlwaysVisible || t.scrollerWidth - s - 2 * this.$padding < 0), u = this.$horizScroll !== o;
            u && (this.$horizScroll = o, this.scrollBarH.setVisible(o));
            var a = this.$vScroll;
            this.$maxLines && this.lineHeight > 1 && (this.$autosize(), n = t.height <= 2 * this.lineHeight);
            var f = t.scrollerHeight + this.lineHeight, l = !this.$maxLines && this.$scrollPastEnd ? (t.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            i += l;
            var c = this.scrollMargin;
            this.session.setScrollTop(Math.max(-c.top, Math.min(this.scrollTop, i - t.scrollerHeight + c.bottom))), this.session.setScrollLeft(Math.max(-c.left, Math.min(this.scrollLeft, s + 2 * this.$padding - t.scrollerWidth + c.right)));
            var h = !n && (this.$vScrollBarAlwaysVisible || t.scrollerHeight - i + l < 0 || this.scrollTop > c.top), p = a !== h;
            p && (this.$vScroll = h, this.scrollBarV.setVisible(h));
            var d = this.scrollTop % this.lineHeight, v = Math.ceil(f / this.lineHeight) - 1, m = Math.max(0, Math.round((this.scrollTop - d) / this.lineHeight)), g = m + v, y, b, w = this.lineHeight;
            m = e.screenToDocumentRow(m, 0);
            var E = e.getFoldLine(m);
            E && (m = E.start.row), y = e.documentToScreenRow(m, 0), b = e.getRowLength(m) * w, g = Math.min(e.screenToDocumentRow(g, 0), e.getLength() - 1), f = t.scrollerHeight + e.getRowLength(g) * w + b, d = this.scrollTop - y * w, d < 0 && y > 0 && (y = Math.max(0, y + Math.floor(d / w)), d = this.scrollTop - y * w);
            var S = 0;
            if (this.layerConfig.width != s || u) S = this.CHANGE_H_SCROLL;
            if (u || p) S |= this.$updateCachedSize(!0, this.gutterWidth, t.width, t.height), this._signal("scrollbarVisibilityChanged"), p && (s = this.$getLongestLine());
            return this.layerConfig = {
                width: s,
                padding: this.$padding,
                firstRow: m,
                firstRowScreen: y,
                lastRow: g,
                lineHeight: w,
                characterWidth: this.characterWidth,
                minHeight: f,
                maxHeight: i,
                offset: d,
                gutterOffset: w ? Math.max(0, Math.ceil((d + t.height - t.scrollerHeight) / w)) : 0,
                height: this.$size.scrollerHeight
            }, this.session.$bidiHandler && this.session.$bidiHandler.setContentWidth(s - this.$padding), S;
        }, e.prototype.$updateLines = function() {
            if (!this.$changedLines) return;
            var e = this.$changedLines.firstRow, t = this.$changedLines.lastRow;
            this.$changedLines = null;
            var n = this.layerConfig;
            if (e > n.lastRow + 1) return;
            if (t < n.firstRow) return;
            if (t === Infinity) {
                this.$showGutter && this.$gutterLayer.update(n), this.$textLayer.update(n);
                return;
            }
            return this.$textLayer.updateLines(n, e, t), !0;
        }, e.prototype.$getLongestLine = function() {
            var e = this.session.getScreenWidth();
            return this.showInvisibles && !this.session.$useWrapMode && (e += 1), this.$textLayer && e > this.$textLayer.MAX_LINE_LENGTH && (e = this.$textLayer.MAX_LINE_LENGTH + 30), Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(e * this.characterWidth));
        }, e.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(!0)), this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        }, e.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers()), this.$loop.schedule(this.CHANGE_MARKER_BACK);
        }, e.prototype.addGutterDecoration = function(e, t) {
            this.$gutterLayer.addGutterDecoration(e, t);
        }, e.prototype.removeGutterDecoration = function(e, t) {
            this.$gutterLayer.removeGutterDecoration(e, t);
        }, e.prototype.updateBreakpoints = function(e) {
            this._rows = e, this.$loop.schedule(this.CHANGE_GUTTER);
        }, e.prototype.setAnnotations = function(e) {
            this.$gutterLayer.setAnnotations(e), this.$loop.schedule(this.CHANGE_GUTTER);
        }, e.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
        }, e.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
        }, e.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
        }, e.prototype.scrollSelectionIntoView = function(e, t, n) {
            this.scrollCursorIntoView(e, n), this.scrollCursorIntoView(t, n);
        }, e.prototype.scrollCursorIntoView = function(e, t, n) {
            if (this.$size.scrollerHeight === 0) return;
            var r = this.$cursorLayer.getPixelPosition(e), i = r.left, s = r.top, o = n && n.top || 0, u = n && n.bottom || 0;
            this.$scrollAnimation && (this.$stopAnimation = !0);
            var a = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            a + o > s ? (t && a + o > s + this.lineHeight && (s -= t * this.$size.scrollerHeight), s === 0 && (s = -this.scrollMargin.top), this.session.setScrollTop(s)) : a + this.$size.scrollerHeight - u < s + this.lineHeight && (t && a + this.$size.scrollerHeight - u < s - this.lineHeight && (s += t * this.$size.scrollerHeight), this.session.setScrollTop(s + this.lineHeight + u - this.$size.scrollerHeight));
            var f = this.scrollLeft, l = 2 * this.layerConfig.characterWidth;
            i - l < f ? (i -= l, i < this.$padding + l && (i = -this.scrollMargin.left), this.session.setScrollLeft(i)) : (i += l, f + this.$size.scrollerWidth < i + this.characterWidth ? this.session.setScrollLeft(Math.round(i + this.characterWidth - this.$size.scrollerWidth)) : f <= this.$padding && i - f < this.characterWidth && this.session.setScrollLeft(0));
        }, e.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
        }, e.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
        }, e.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
        }, e.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        }, e.prototype.scrollToRow = function(e) {
            this.session.setScrollTop(e * this.lineHeight);
        }, e.prototype.alignCursor = function(e, t) {
            typeof e == "number" && (e = {
                row: e,
                column: 0
            });
            var n = this.$cursorLayer.getPixelPosition(e), r = this.$size.scrollerHeight - this.lineHeight, i = n.top - r * (t || 0);
            return this.session.setScrollTop(i), i;
        }, e.prototype.$calcSteps = function(e, t) {
            var n = 0, r = this.STEPS, i = [], s = function(e, t, n) {
                return n * (Math.pow(e - 1, 3) + 1) + t;
            };
            for(n = 0; n < r; ++n)i.push(s(n / this.STEPS, e, t - e));
            return i;
        }, e.prototype.scrollToLine = function(e, t, n, r) {
            var i = this.$cursorLayer.getPixelPosition({
                row: e,
                column: 0
            }), s = i.top;
            t && (s -= this.$size.scrollerHeight / 2);
            var o = this.scrollTop;
            this.session.setScrollTop(s), n !== !1 && this.animateScrolling(o, r);
        }, e.prototype.animateScrolling = function(e, t) {
            function o() {
                r.$timer = clearInterval(r.$timer), r.$scrollAnimation = null, r.$stopAnimation = !1, t && t();
            }
            var n = this.scrollTop;
            if (!this.$animatedScroll) return;
            var r = this;
            if (e == n) return;
            if (this.$scrollAnimation) {
                var i = this.$scrollAnimation.steps;
                if (i.length) {
                    e = i[0];
                    if (e == n) return;
                }
            }
            var s = r.$calcSteps(e, n);
            this.$scrollAnimation = {
                from: e,
                to: n,
                steps: s
            }, clearInterval(this.$timer), r.session.setScrollTop(s.shift()), r.session.$scrollTop = n, this.$timer = setInterval(function() {
                if (r.$stopAnimation) {
                    o();
                    return;
                }
                if (!r.session) return clearInterval(r.$timer);
                s.length ? (r.session.setScrollTop(s.shift()), r.session.$scrollTop = n) : n != null ? (r.session.$scrollTop = -1, r.session.setScrollTop(n), n = null) : o();
            }, 10);
        }, e.prototype.scrollToY = function(e) {
            this.scrollTop !== e && (this.$loop.schedule(this.CHANGE_SCROLL), this.scrollTop = e);
        }, e.prototype.scrollToX = function(e) {
            this.scrollLeft !== e && (this.scrollLeft = e), this.$loop.schedule(this.CHANGE_H_SCROLL);
        }, e.prototype.scrollTo = function(e, t) {
            this.session.setScrollTop(t), this.session.setScrollLeft(e);
        }, e.prototype.scrollBy = function(e, t) {
            t && this.session.setScrollTop(this.session.getScrollTop() + t), e && this.session.setScrollLeft(this.session.getScrollLeft() + e);
        }, e.prototype.isScrollableBy = function(e, t) {
            if (t < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return !0;
            if (t > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return !0;
            if (e < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return !0;
            if (e > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return !0;
        }, e.prototype.pixelToScreenCoordinates = function(e, t) {
            var n;
            if (this.$hasCssTransforms) {
                n = {
                    top: 0,
                    left: 0
                };
                var r = this.$fontMetrics.transformCoordinates([
                    e,
                    t
                ]);
                e = r[1] - this.gutterWidth - this.margin.left, t = r[0];
            } else n = this.scroller.getBoundingClientRect();
            var i = e + this.scrollLeft - n.left - this.$padding, s = i / this.characterWidth, o = Math.floor((t + this.scrollTop - n.top) / this.lineHeight), u = this.$blockCursor ? Math.floor(s) : Math.round(s);
            return {
                row: o,
                column: u,
                side: s - u > 0 ? 1 : -1,
                offsetX: i
            };
        }, e.prototype.screenToTextCoordinates = function(e, t) {
            var n;
            if (this.$hasCssTransforms) {
                n = {
                    top: 0,
                    left: 0
                };
                var r = this.$fontMetrics.transformCoordinates([
                    e,
                    t
                ]);
                e = r[1] - this.gutterWidth - this.margin.left, t = r[0];
            } else n = this.scroller.getBoundingClientRect();
            var i = e + this.scrollLeft - n.left - this.$padding, s = i / this.characterWidth, o = this.$blockCursor ? Math.floor(s) : Math.round(s), u = Math.floor((t + this.scrollTop - n.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(u, Math.max(o, 0), i);
        }, e.prototype.textToScreenCoordinates = function(e, t) {
            var n = this.scroller.getBoundingClientRect(), r = this.session.documentToScreenPosition(e, t), i = this.$padding + (this.session.$bidiHandler.isBidiRow(r.row, e) ? this.session.$bidiHandler.getPosLeft(r.column) : Math.round(r.column * this.characterWidth)), s = r.row * this.lineHeight;
            return {
                pageX: n.left + i - this.scrollLeft,
                pageY: n.top + s - this.scrollTop
            };
        }, e.prototype.visualizeFocus = function() {
            i.addCssClass(this.container, "ace_focus");
        }, e.prototype.visualizeBlur = function() {
            i.removeCssClass(this.container, "ace_focus");
        }, e.prototype.showComposition = function(e) {
            this.$composition = e, e.cssText || (e.cssText = this.textarea.style.cssText), e.useTextareaForIME == undefined && (e.useTextareaForIME = this.$useTextareaForIME), this.$useTextareaForIME ? (i.addCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = "", this.$moveTextAreaToCursor(), this.$cursorLayer.element.style.display = "none") : e.markerId = this.session.addMarker(e.markerRange, "ace_composition_marker", "text");
        }, e.prototype.setCompositionText = function(e) {
            var t = this.session.selection.cursor;
            this.addToken(e, "composition_placeholder", t.row, t.column), this.$moveTextAreaToCursor();
        }, e.prototype.hideComposition = function() {
            if (!this.$composition) return;
            this.$composition.markerId && this.session.removeMarker(this.$composition.markerId), i.removeCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = this.$composition.cssText;
            var e = this.session.selection.cursor;
            this.removeExtraToken(e.row, e.column), this.$composition = null, this.$cursorLayer.element.style.display = "";
        }, e.prototype.setGhostText = function(e, t) {
            var n = this.session.selection.cursor, r = t || {
                row: n.row,
                column: n.column
            };
            this.removeGhostText();
            var s = this.$calculateWrappedTextChunks(e, r);
            this.addToken(s[0].text, "ghost_text", r.row, r.column), this.$ghostText = {
                text: e,
                position: {
                    row: r.row,
                    column: r.column
                }
            };
            var o = i.createElement("div");
            if (s.length > 1) {
                var u = this.hideTokensAfterPosition(r.row, r.column), a;
                s.slice(1).forEach(function(e) {
                    var t = i.createElement("div"), n = i.createElement("span");
                    n.className = "ace_ghost_text", e.wrapped && (t.className = "ghost_text_line_wrapped"), e.text.length === 0 && (e.text = " "), n.appendChild(i.createTextNode(e.text)), t.appendChild(n), o.appendChild(t), a = t;
                }), u.forEach(function(e) {
                    var t = i.createElement("span");
                    E(e.type) || (t.className = "ace_" + e.type.replace(/\./g, " ace_")), t.appendChild(i.createTextNode(e.value)), a.appendChild(t);
                }), this.$ghostTextWidget = {
                    el: o,
                    row: r.row,
                    column: r.column,
                    className: "ace_ghost_text_container"
                }, this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
                var f = this.$cursorLayer.getPixelPosition(r, !0), l = this.container, c = l.getBoundingClientRect().height, h = s.length * this.lineHeight, p = h < c - f.top;
                if (p) return;
                h < c ? this.scrollBy(0, (s.length - 1) * this.lineHeight) : this.scrollToRow(r.row);
            }
        }, e.prototype.$calculateWrappedTextChunks = function(e, t) {
            var n = this.$size.scrollerWidth - this.$padding * 2, r = Math.floor(n / this.characterWidth) - 2;
            r = r <= 0 ? 60 : r;
            var i = e.split(/\r?\n/), s = [];
            for(var o = 0; o < i.length; o++){
                var u = this.session.$getDisplayTokens(i[o], t.column), a = this.session.$computeWrapSplits(u, r, this.session.$tabSize);
                if (a.length > 0) {
                    var f = 0;
                    a.push(i[o].length);
                    for(var l = 0; l < a.length; l++){
                        var c = i[o].slice(f, a[l]);
                        s.push({
                            text: c,
                            wrapped: !0
                        }), f = a[l];
                    }
                } else s.push({
                    text: i[o],
                    wrapped: !1
                });
            }
            return s;
        }, e.prototype.removeGhostText = function() {
            if (!this.$ghostText) return;
            var e = this.$ghostText.position;
            this.removeExtraToken(e.row, e.column), this.$ghostTextWidget && (this.session.widgetManager.removeLineWidget(this.$ghostTextWidget), this.$ghostTextWidget = null), this.$ghostText = null;
        }, e.prototype.addToken = function(e, t, n, r) {
            var i = this.session;
            i.bgTokenizer.lines[n] = null;
            var s = {
                type: t,
                value: e
            }, o = i.getTokens(n);
            if (r == null || !o.length) o.push(s);
            else {
                var u = 0;
                for(var a = 0; a < o.length; a++){
                    var f = o[a];
                    u += f.value.length;
                    if (r <= u) {
                        var l = f.value.length - (u - r), c = f.value.slice(0, l), h = f.value.slice(l);
                        o.splice(a, 1, {
                            type: f.type,
                            value: c
                        }, s, {
                            type: f.type,
                            value: h
                        });
                        break;
                    }
                }
            }
            this.updateLines(n, n);
        }, e.prototype.hideTokensAfterPosition = function(e, t) {
            var n = this.session.getTokens(e), r = 0, i = !1, s = [];
            for(var o = 0; o < n.length; o++){
                var u = n[o];
                r += u.value.length;
                if (u.type === "ghost_text") continue;
                if (i) {
                    s.push({
                        type: u.type,
                        value: u.value
                    }), u.type = "hidden_token";
                    continue;
                }
                r === t && (i = !0);
            }
            return this.updateLines(e, e), s;
        }, e.prototype.removeExtraToken = function(e, t) {
            this.session.bgTokenizer.lines[e] = null, this.updateLines(e, e);
        }, e.prototype.setTheme = function(e, t) {
            function s(r) {
                if (n.$themeId != e) return t && t();
                if (!r || !r.cssClass) throw new Error("couldn't load module " + e + " or it didn't call define");
                r.$id && (n.$themeId = r.$id), i.importCssString(r.cssText, r.cssClass, n.container), n.theme && i.removeCssClass(n.container, n.theme.cssClass);
                var s = "padding" in r ? r.padding : "padding" in (n.theme || {}) ? 4 : n.$padding;
                n.$padding && s != n.$padding && n.setPadding(s), n.$theme = r.cssClass, n.theme = r, i.addCssClass(n.container, r.cssClass), i.setCssClass(n.container, "ace_dark", r.isDark), n.$size && (n.$size.width = 0, n.$updateSizeAsync()), n._dispatchEvent("themeLoaded", {
                    theme: r
                }), t && t(), w.isSafari && n.scroller && (n.scroller.style.background = "red", n.scroller.style.background = "");
            }
            var n = this;
            this.$themeId = e, n._dispatchEvent("themeChange", {
                theme: e
            });
            if (!e || typeof e == "string") {
                var r = e || this.$options.theme.initialValue;
                o.loadModule([
                    "theme",
                    r
                ], s);
            } else s(e);
        }, e.prototype.getTheme = function() {
            return this.$themeId;
        }, e.prototype.setStyle = function(e, t) {
            i.setCssClass(this.container, e, t !== !1);
        }, e.prototype.unsetStyle = function(e) {
            i.removeCssClass(this.container, e);
        }, e.prototype.setCursorStyle = function(e) {
            i.setStyle(this.scroller.style, "cursor", e);
        }, e.prototype.setMouseCursor = function(e) {
            i.setStyle(this.scroller.style, "cursor", e);
        }, e.prototype.attachToShadowRoot = function() {
            i.importCssString(y, "ace_editor.css", this.container);
        }, e.prototype.destroy = function() {
            this.freeze(), this.$fontMetrics.destroy(), this.$cursorLayer.destroy(), this.removeAllListeners(), this.container.textContent = "", this.setOption("useResizeObserver", !1);
        }, e.prototype.$updateCustomScrollbar = function(e) {
            var t = this;
            this.$horizScroll = this.$vScroll = null, this.scrollBarV.element.remove(), this.scrollBarH.element.remove(), this.$scrollDecorator && delete this.$scrollDecorator, e === !0 ? (this.scrollBarV = new d(this.container, this), this.scrollBarH = new p(this.container, this), this.scrollBarV.setHeight(this.$size.scrollerHeight), this.scrollBarH.setWidth(this.$size.scrollerWidth), this.scrollBarV.addEventListener("scroll", function(e) {
                t.$scrollAnimation || t.session.setScrollTop(e.data - t.scrollMargin.top);
            }), this.scrollBarH.addEventListener("scroll", function(e) {
                t.$scrollAnimation || t.session.setScrollLeft(e.data - t.scrollMargin.left);
            }), this.$scrollDecorator = new b(this.scrollBarV, this), this.$scrollDecorator.$updateDecorators()) : (this.scrollBarV = new h(this.container, this), this.scrollBarH = new c(this.container, this), this.scrollBarV.addEventListener("scroll", function(e) {
                t.$scrollAnimation || t.session.setScrollTop(e.data - t.scrollMargin.top);
            }), this.scrollBarH.addEventListener("scroll", function(e) {
                t.$scrollAnimation || t.session.setScrollLeft(e.data - t.scrollMargin.left);
            }));
        }, e.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver) return;
            var e = this;
            this.$resizeTimer = s.delayedCall(function() {
                e.destroyed || e.onResize();
            }, 50), this.$resizeObserver = new window.ResizeObserver(function(t) {
                var n = t[0].contentRect.width, r = t[0].contentRect.height;
                Math.abs(e.$size.width - n) > 1 || Math.abs(e.$size.height - r) > 1 ? e.$resizeTimer.delay() : e.$resizeTimer.cancel();
            }), this.$resizeObserver.observe(this.container);
        }, e;
    }();
    S.prototype.CHANGE_CURSOR = 1, S.prototype.CHANGE_MARKER = 2, S.prototype.CHANGE_GUTTER = 4, S.prototype.CHANGE_SCROLL = 8, S.prototype.CHANGE_LINES = 16, S.prototype.CHANGE_TEXT = 32, S.prototype.CHANGE_SIZE = 64, S.prototype.CHANGE_MARKER_BACK = 128, S.prototype.CHANGE_MARKER_FRONT = 256, S.prototype.CHANGE_FULL = 512, S.prototype.CHANGE_H_SCROLL = 1024, S.prototype.$changes = 0, S.prototype.$padding = null, S.prototype.$frozen = !1, S.prototype.STEPS = 8, r.implement(S.prototype, g), o.defineOptions(S.prototype, "renderer", {
        useResizeObserver: {
            set: function(e) {
                !e && this.$resizeObserver ? (this.$resizeObserver.disconnect(), this.$resizeTimer.cancel(), this.$resizeTimer = this.$resizeObserver = null) : e && !this.$resizeObserver && this.$addResizeObserver();
            }
        },
        animatedScroll: {
            initialValue: !1
        },
        showInvisibles: {
            set: function(e) {
                this.$textLayer.setShowInvisibles(e) && this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: !1
        },
        showPrintMargin: {
            set: function() {
                this.$updatePrintMargin();
            },
            initialValue: !0
        },
        printMarginColumn: {
            set: function() {
                this.$updatePrintMargin();
            },
            initialValue: 80
        },
        printMargin: {
            set: function(e) {
                typeof e == "number" && (this.$printMarginColumn = e), this.$showPrintMargin = !!e, this.$updatePrintMargin();
            },
            get: function() {
                return this.$showPrintMargin && this.$printMarginColumn;
            }
        },
        showGutter: {
            set: function(e) {
                this.$gutter.style.display = e ? "block" : "none", this.$loop.schedule(this.CHANGE_FULL), this.onGutterResize();
            },
            initialValue: !0
        },
        useSvgGutterIcons: {
            set: function(e) {
                this.$gutterLayer.$useSvgGutterIcons = e;
            },
            initialValue: !1
        },
        showFoldedAnnotations: {
            set: function(e) {
                this.$gutterLayer.$showFoldedAnnotations = e;
            },
            initialValue: !1
        },
        fadeFoldWidgets: {
            set: function(e) {
                i.setCssClass(this.$gutter, "ace_fade-fold-widgets", e);
            },
            initialValue: !1
        },
        showFoldWidgets: {
            set: function(e) {
                this.$gutterLayer.setShowFoldWidgets(e), this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: !0
        },
        displayIndentGuides: {
            set: function(e) {
                this.$textLayer.setDisplayIndentGuides(e) && this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: !0
        },
        highlightIndentGuides: {
            set: function(e) {
                this.$textLayer.setHighlightIndentGuides(e) == 1 ? this.$textLayer.$highlightIndentGuide() : this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            },
            initialValue: !0
        },
        highlightGutterLine: {
            set: function(e) {
                this.$gutterLayer.setHighlightGutterLine(e), this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: !0
        },
        hScrollBarAlwaysVisible: {
            set: function(e) {
                (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: !1
        },
        vScrollBarAlwaysVisible: {
            set: function(e) {
                (!this.$vScrollBarAlwaysVisible || !this.$vScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: !1
        },
        fontSize: {
            set: function(e) {
                typeof e == "number" && (e += "px"), this.container.style.fontSize = e, this.updateFontSize();
            },
            initialValue: 12
        },
        fontFamily: {
            set: function(e) {
                this.container.style.fontFamily = e, this.updateFontSize();
            }
        },
        maxLines: {
            set: function(e) {
                this.updateFull();
            }
        },
        minLines: {
            set: function(e) {
                this.$minLines < 562949953421311 || (this.$minLines = 0), this.updateFull();
            }
        },
        maxPixelHeight: {
            set: function(e) {
                this.updateFull();
            },
            initialValue: 0
        },
        scrollPastEnd: {
            set: function(e) {
                e = +e || 0;
                if (this.$scrollPastEnd == e) return;
                this.$scrollPastEnd = e, this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: 0,
            handlesSet: !0
        },
        fixedWidthGutter: {
            set: function(e) {
                this.$gutterLayer.$fixedWidth = !!e, this.$loop.schedule(this.CHANGE_GUTTER);
            }
        },
        customScrollbar: {
            set: function(e) {
                this.$updateCustomScrollbar(e);
            },
            initialValue: !1
        },
        theme: {
            set: function(e) {
                this.setTheme(e);
            },
            get: function() {
                return this.$themeId || this.theme;
            },
            initialValue: "./theme/textmate",
            handlesSet: !0
        },
        hasCssTransforms: {},
        useTextareaForIME: {
            initialValue: !w.isMobile && !w.isIE
        }
    }), t.VirtualRenderer = S;
}), ace.define("ace/worker/worker_client", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/net",
    "ace/lib/event_emitter",
    "ace/config"
], function(e, t, n) {
    "use strict";
    function u(e) {
        var t = "importScripts('" + i.qualifyURL(e) + "');";
        try {
            return new Blob([
                t
            ], {
                type: "application/javascript"
            });
        } catch (n) {
            var r = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder, s = new r;
            return s.append(t), s.getBlob("application/javascript");
        }
    }
    function a(e) {
        if (typeof Worker == "undefined") return {
            postMessage: function() {},
            terminate: function() {}
        };
        if (o.get("loadWorkerFromBlob")) {
            var t = u(e), n = window.URL || window.webkitURL, r = n.createObjectURL(t);
            return new Worker(r);
        }
        return new Worker(e);
    }
    var r = e("../lib/oop"), i = e("../lib/net"), s = e("../lib/event_emitter").EventEmitter, o = e("../config"), f = function(e) {
        e.postMessage || (e = this.$createWorkerFromOldConfig.apply(this, arguments)), this.$worker = e, this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this), this.changeListener = this.changeListener.bind(this), this.onMessage = this.onMessage.bind(this), this.callbackId = 1, this.callbacks = {}, this.$worker.onmessage = this.onMessage;
    };
    (function() {
        r.implement(this, s), this.$createWorkerFromOldConfig = function(t, n, r, i, s) {
            e.nameToUrl && !e.toUrl && (e.toUrl = e.nameToUrl);
            if (o.get("packaged") || !e.toUrl) i = i || o.moduleUrl(n, "worker");
            else {
                var u = this.$normalizePath;
                i = i || u(e.toUrl("ace/worker/worker.js", null, "_"));
                var f = {};
                t.forEach(function(t) {
                    f[t] = u(e.toUrl(t, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                });
            }
            return this.$worker = a(i), s && this.send("importScripts", s), this.$worker.postMessage({
                init: !0,
                tlns: f,
                module: n,
                classname: r
            }), this.$worker;
        }, this.onMessage = function(e) {
            var t = e.data;
            switch(t.type){
                case "event":
                    this._signal(t.name, {
                        data: t.data
                    });
                    break;
                case "call":
                    var n = this.callbacks[t.id];
                    n && (n(t.data), delete this.callbacks[t.id]);
                    break;
                case "error":
                    this.reportError(t.data);
                    break;
                case "log":
                    window.console && console.log && console.log.apply(console, t.data);
            }
        }, this.reportError = function(e) {
            window.console && console.error && console.error(e);
        }, this.$normalizePath = function(e) {
            return i.qualifyURL(e);
        }, this.terminate = function() {
            this._signal("terminate", {}), this.deltaQueue = null, this.$worker.terminate(), this.$worker.onerror = function(e) {
                e.preventDefault();
            }, this.$worker = null, this.$doc && this.$doc.off("change", this.changeListener), this.$doc = null;
        }, this.send = function(e, t) {
            this.$worker.postMessage({
                command: e,
                args: t
            });
        }, this.call = function(e, t, n) {
            if (n) {
                var r = this.callbackId++;
                this.callbacks[r] = n, t.push(r);
            }
            this.send(e, t);
        }, this.emit = function(e, t) {
            try {
                t.data && t.data.err && (t.data.err = {
                    message: t.data.err.message,
                    stack: t.data.err.stack,
                    code: t.data.err.code
                }), this.$worker && this.$worker.postMessage({
                    event: e,
                    data: {
                        data: t.data
                    }
                });
            } catch (n) {
                console.error(n.stack);
            }
        }, this.attachToDocument = function(e) {
            this.$doc && this.terminate(), this.$doc = e, this.call("setValue", [
                e.getValue()
            ]), e.on("change", this.changeListener, !0);
        }, this.changeListener = function(e) {
            this.deltaQueue || (this.deltaQueue = [], setTimeout(this.$sendDeltaQueue, 0)), e.action == "insert" ? this.deltaQueue.push(e.start, e.lines) : this.deltaQueue.push(e.start, e.end);
        }, this.$sendDeltaQueue = function() {
            var e = this.deltaQueue;
            if (!e) return;
            this.deltaQueue = null, e.length > 50 && e.length > this.$doc.getLength() >> 1 ? this.call("setValue", [
                this.$doc.getValue()
            ]) : this.emit("change", {
                data: e
            });
        };
    }).call(f.prototype);
    var l = function(e, t, n) {
        var r = null, i = !1, u = Object.create(s), a = [], l = new f({
            messageBuffer: a,
            terminate: function() {},
            postMessage: function(e) {
                a.push(e);
                if (!r) return;
                i ? setTimeout(c) : c();
            }
        });
        l.setEmitSync = function(e) {
            i = e;
        };
        var c = function() {
            var e = a.shift();
            e.command ? r[e.command].apply(r, e.args) : e.event && u._signal(e.event, e.data);
        };
        return u.postMessage = function(e) {
            l.onMessage({
                data: e
            });
        }, u.callback = function(e, t) {
            this.postMessage({
                type: "call",
                id: t,
                data: e
            });
        }, u.emit = function(e, t) {
            this.postMessage({
                type: "event",
                name: e,
                data: t
            });
        }, o.loadModule([
            "worker",
            t
        ], function(e) {
            r = new e[n](u);
            while(a.length)c();
        }), l;
    };
    t.UIWorkerClient = l, t.WorkerClient = f, t.createWorker = a;
}), ace.define("ace/placeholder", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/lib/event_emitter",
    "ace/lib/oop"
], function(e, t, n) {
    "use strict";
    var r = e("./range").Range, i = e("./lib/event_emitter").EventEmitter, s = e("./lib/oop"), o = function() {
        function e(e, t, n, r, i, s) {
            var o = this;
            this.length = t, this.session = e, this.doc = e.getDocument(), this.mainClass = i, this.othersClass = s, this.$onUpdate = this.onUpdate.bind(this), this.doc.on("change", this.$onUpdate, !0), this.$others = r, this.$onCursorChange = function() {
                setTimeout(function() {
                    o.onCursorChange();
                });
            }, this.$pos = n;
            var u = e.getUndoManager().$undoStack || e.getUndoManager().$undostack || {
                length: -1
            };
            this.$undoStackDepth = u.length, this.setup(), e.selection.on("changeCursor", this.$onCursorChange);
        }
        return e.prototype.setup = function() {
            var e = this, t = this.doc, n = this.session;
            this.selectionBefore = n.selection.toJSON(), n.selection.inMultiSelectMode && n.selection.toSingleRange(), this.pos = t.createAnchor(this.$pos.row, this.$pos.column);
            var i = this.pos;
            i.$insertRight = !0, i.detach(), i.markerId = n.addMarker(new r(i.row, i.column, i.row, i.column + this.length), this.mainClass, null, !1), this.others = [], this.$others.forEach(function(n) {
                var r = t.createAnchor(n.row, n.column);
                r.$insertRight = !0, r.detach(), e.others.push(r);
            }), n.setUndoSelect(!1);
        }, e.prototype.showOtherMarkers = function() {
            if (this.othersActive) return;
            var e = this.session, t = this;
            this.othersActive = !0, this.others.forEach(function(n) {
                n.markerId = e.addMarker(new r(n.row, n.column, n.row, n.column + t.length), t.othersClass, null, !1);
            });
        }, e.prototype.hideOtherMarkers = function() {
            if (!this.othersActive) return;
            this.othersActive = !1;
            for(var e = 0; e < this.others.length; e++)this.session.removeMarker(this.others[e].markerId);
        }, e.prototype.onUpdate = function(e) {
            if (this.$updating) return this.updateAnchors(e);
            var t = e;
            if (t.start.row !== t.end.row) return;
            if (t.start.row !== this.pos.row) return;
            this.$updating = !0;
            var n = e.action === "insert" ? t.end.column - t.start.column : t.start.column - t.end.column, i = t.start.column >= this.pos.column && t.start.column <= this.pos.column + this.length + 1, s = t.start.column - this.pos.column;
            this.updateAnchors(e), i && (this.length += n);
            if (i && !this.session.$fromUndo) {
                if (e.action === "insert") for(var o = this.others.length - 1; o >= 0; o--){
                    var u = this.others[o], a = {
                        row: u.row,
                        column: u.column + s
                    };
                    this.doc.insertMergedLines(a, e.lines);
                }
                else if (e.action === "remove") for(var o = this.others.length - 1; o >= 0; o--){
                    var u = this.others[o], a = {
                        row: u.row,
                        column: u.column + s
                    };
                    this.doc.remove(new r(a.row, a.column, a.row, a.column - n));
                }
            }
            this.$updating = !1, this.updateMarkers();
        }, e.prototype.updateAnchors = function(e) {
            this.pos.onChange(e);
            for(var t = this.others.length; t--;)this.others[t].onChange(e);
            this.updateMarkers();
        }, e.prototype.updateMarkers = function() {
            if (this.$updating) return;
            var e = this, t = this.session, n = function(n, i) {
                t.removeMarker(n.markerId), n.markerId = t.addMarker(new r(n.row, n.column, n.row, n.column + e.length), i, null, !1);
            };
            n(this.pos, this.mainClass);
            for(var i = this.others.length; i--;)n(this.others[i], this.othersClass);
        }, e.prototype.onCursorChange = function(e) {
            if (this.$updating || !this.session) return;
            var t = this.session.selection.getCursor();
            t.row === this.pos.row && t.column >= this.pos.column && t.column <= this.pos.column + this.length ? (this.showOtherMarkers(), this._emit("cursorEnter", e)) : (this.hideOtherMarkers(), this._emit("cursorLeave", e));
        }, e.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId), this.hideOtherMarkers(), this.doc.off("change", this.$onUpdate), this.session.selection.off("changeCursor", this.$onCursorChange), this.session.setUndoSelect(!0), this.session = null;
        }, e.prototype.cancel = function() {
            if (this.$undoStackDepth === -1) return;
            var e = this.session.getUndoManager(), t = (e.$undoStack || e.$undostack).length - this.$undoStackDepth;
            for(var n = 0; n < t; n++)e.undo(this.session, !0);
            this.selectionBefore && this.session.selection.fromJSON(this.selectionBefore);
        }, e;
    }();
    s.implement(o.prototype, i), t.PlaceHolder = o;
}), ace.define("ace/mouse/multi_select_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent"
], function(e, t, n) {
    function s(e, t) {
        return e.row == t.row && e.column == t.column;
    }
    function o(e) {
        var t = e.domEvent, n = t.altKey, o = t.shiftKey, u = t.ctrlKey, a = e.getAccelKey(), f = e.getButton();
        u && i.isMac && (f = t.button);
        if (e.editor.inMultiSelectMode && f == 2) {
            e.editor.textInput.onContextMenu(e.domEvent);
            return;
        }
        if (!u && !n && !a) {
            f === 0 && e.editor.inMultiSelectMode && e.editor.exitMultiSelectMode();
            return;
        }
        if (f !== 0) return;
        var l = e.editor, c = l.selection, h = l.inMultiSelectMode, p = e.getDocumentPosition(), d = c.getCursor(), v = e.inSelection() || c.isEmpty() && s(p, d), m = e.x, g = e.y, y = function(e) {
            m = e.clientX, g = e.clientY;
        }, b = l.session, w = l.renderer.pixelToScreenCoordinates(m, g), E = w, S;
        if (l.$mouseHandler.$enableJumpToDef) u && n || a && n ? S = o ? "block" : "add" : n && l.$blockSelectEnabled && (S = "block");
        else if (a && !n) {
            S = "add";
            if (!h && o) return;
        } else n && l.$blockSelectEnabled && (S = "block");
        S && i.isMac && t.ctrlKey && l.$mouseHandler.cancelContextMenu();
        if (S == "add") {
            if (!h && v) return;
            if (!h) {
                var x = c.toOrientedRange();
                l.addSelectionMarker(x);
            }
            var T = c.rangeList.rangeAtPoint(p);
            l.inVirtualSelectionMode = !0, o && (T = null, x = c.ranges[0] || x, l.removeSelectionMarker(x)), l.once("mouseup", function() {
                var e = c.toOrientedRange();
                T && e.isEmpty() && s(T.cursor, e.cursor) ? c.substractPoint(e.cursor) : (o ? c.substractPoint(x.cursor) : x && (l.removeSelectionMarker(x), c.addRange(x)), c.addRange(e)), l.inVirtualSelectionMode = !1;
            });
        } else if (S == "block") {
            e.stop(), l.inVirtualSelectionMode = !0;
            var N, C = [], k = function() {
                var e = l.renderer.pixelToScreenCoordinates(m, g), t = b.screenToDocumentPosition(e.row, e.column, e.offsetX);
                if (s(E, e) && s(t, c.lead)) return;
                E = e, l.selection.moveToPosition(t), l.renderer.scrollCursorIntoView(), l.removeSelectionMarkers(C), C = c.rectangularRangeBlock(E, w), l.$mouseHandler.$clickSelection && C.length == 1 && C[0].isEmpty() && (C[0] = l.$mouseHandler.$clickSelection.clone()), C.forEach(l.addSelectionMarker, l), l.updateSelectionMarkers();
            };
            h && !a ? c.toSingleRange() : !h && a && (N = c.toOrientedRange(), l.addSelectionMarker(N)), o ? w = b.documentToScreenPosition(c.lead) : c.moveToPosition(p), E = {
                row: -1,
                column: -1
            };
            var L = function(e) {
                k(), clearInterval(O), l.removeSelectionMarkers(C), C.length || (C = [
                    c.toOrientedRange()
                ]), N && (l.removeSelectionMarker(N), c.toSingleRange(N));
                for(var t = 0; t < C.length; t++)c.addRange(C[t]);
                l.inVirtualSelectionMode = !1, l.$mouseHandler.$clickSelection = null;
            }, A = k;
            r.capture(l.container, y, L);
            var O = setInterval(function() {
                A();
            }, 20);
            return e.preventDefault();
        }
    }
    var r = e("../lib/event"), i = e("../lib/useragent");
    t.onMouseDown = o;
}), ace.define("ace/commands/multi_select_commands", [
    "require",
    "exports",
    "module",
    "ace/keyboard/hash_handler"
], function(e, t, n) {
    t.defaultCommands = [
        {
            name: "addCursorAbove",
            description: "Add cursor above",
            exec: function(e) {
                e.selectMoreLines(-1);
            },
            bindKey: {
                win: "Ctrl-Alt-Up",
                mac: "Ctrl-Alt-Up"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "addCursorBelow",
            description: "Add cursor below",
            exec: function(e) {
                e.selectMoreLines(1);
            },
            bindKey: {
                win: "Ctrl-Alt-Down",
                mac: "Ctrl-Alt-Down"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "addCursorAboveSkipCurrent",
            description: "Add cursor above (skip current)",
            exec: function(e) {
                e.selectMoreLines(-1, !0);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Up",
                mac: "Ctrl-Alt-Shift-Up"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "addCursorBelowSkipCurrent",
            description: "Add cursor below (skip current)",
            exec: function(e) {
                e.selectMoreLines(1, !0);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Down",
                mac: "Ctrl-Alt-Shift-Down"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectMoreBefore",
            description: "Select more before",
            exec: function(e) {
                e.selectMore(-1);
            },
            bindKey: {
                win: "Ctrl-Alt-Left",
                mac: "Ctrl-Alt-Left"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectMoreAfter",
            description: "Select more after",
            exec: function(e) {
                e.selectMore(1);
            },
            bindKey: {
                win: "Ctrl-Alt-Right",
                mac: "Ctrl-Alt-Right"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectNextBefore",
            description: "Select next before",
            exec: function(e) {
                e.selectMore(-1, !0);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Left",
                mac: "Ctrl-Alt-Shift-Left"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "selectNextAfter",
            description: "Select next after",
            exec: function(e) {
                e.selectMore(1, !0);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Right",
                mac: "Ctrl-Alt-Shift-Right"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        },
        {
            name: "toggleSplitSelectionIntoLines",
            description: "Split selection into lines",
            exec: function(e) {
                e.multiSelect.rangeCount > 1 ? e.multiSelect.joinSelections() : e.multiSelect.splitIntoLines();
            },
            bindKey: {
                win: "Ctrl-Alt-L",
                mac: "Ctrl-Alt-L"
            },
            readOnly: !0
        },
        {
            name: "splitSelectionIntoLines",
            description: "Split into lines",
            exec: function(e) {
                e.multiSelect.splitIntoLines();
            },
            readOnly: !0
        },
        {
            name: "alignCursors",
            description: "Align cursors",
            exec: function(e) {
                e.alignCursors();
            },
            bindKey: {
                win: "Ctrl-Alt-A",
                mac: "Ctrl-Alt-A"
            },
            scrollIntoView: "cursor"
        },
        {
            name: "findAll",
            description: "Find all",
            exec: function(e) {
                e.findAll();
            },
            bindKey: {
                win: "Ctrl-Alt-K",
                mac: "Ctrl-Alt-G"
            },
            scrollIntoView: "cursor",
            readOnly: !0
        }
    ], t.multiSelectCommands = [
        {
            name: "singleSelection",
            description: "Single selection",
            bindKey: "esc",
            exec: function(e) {
                e.exitMultiSelectMode();
            },
            scrollIntoView: "cursor",
            readOnly: !0,
            isAvailable: function(e) {
                return e && e.inMultiSelectMode;
            }
        }
    ];
    var r = e("../keyboard/hash_handler").HashHandler;
    t.keyboardHandler = new r(t.multiSelectCommands);
}), ace.define("ace/multi_select", [
    "require",
    "exports",
    "module",
    "ace/range_list",
    "ace/range",
    "ace/selection",
    "ace/mouse/multi_select_handler",
    "ace/lib/event",
    "ace/lib/lang",
    "ace/commands/multi_select_commands",
    "ace/search",
    "ace/edit_session",
    "ace/editor",
    "ace/config"
], function(e, t, n) {
    function h(e, t, n) {
        return c.$options.wrap = !0, c.$options.needle = t, c.$options.backwards = n == -1, c.find(e);
    }
    function v(e, t) {
        return e.row == t.row && e.column == t.column;
    }
    function m(e) {
        if (e.$multiselectOnSessionChange) return;
        e.$onAddRange = e.$onAddRange.bind(e), e.$onRemoveRange = e.$onRemoveRange.bind(e), e.$onMultiSelect = e.$onMultiSelect.bind(e), e.$onSingleSelect = e.$onSingleSelect.bind(e), e.$multiselectOnSessionChange = t.onSessionChange.bind(e), e.$checkMultiselectChange = e.$checkMultiselectChange.bind(e), e.$multiselectOnSessionChange(e), e.on("changeSession", e.$multiselectOnSessionChange), e.on("mousedown", o), e.commands.addCommands(f.defaultCommands), g(e);
    }
    function g(e) {
        function r(t) {
            n && (e.renderer.setMouseCursor(""), n = !1);
        }
        if (!e.textInput) return;
        var t = e.textInput.getElement(), n = !1;
        u.addListener(t, "keydown", function(t) {
            var i = t.keyCode == 18 && !(t.ctrlKey || t.shiftKey || t.metaKey);
            e.$blockSelectEnabled && i ? n || (e.renderer.setMouseCursor("crosshair"), n = !0) : n && r();
        }, e), u.addListener(t, "keyup", r, e), u.addListener(t, "blur", r, e);
    }
    var r = e("./range_list").RangeList, i = e("./range").Range, s = e("./selection").Selection, o = e("./mouse/multi_select_handler").onMouseDown, u = e("./lib/event"), a = e("./lib/lang"), f = e("./commands/multi_select_commands");
    t.commands = f.defaultCommands.concat(f.multiSelectCommands);
    var l = e("./search").Search, c = new l, p = e("./edit_session").EditSession;
    (function() {
        this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
        };
    }).call(p.prototype), (function() {
        this.ranges = null, this.rangeList = null, this.addRange = function(e, t) {
            if (!e) return;
            if (!this.inMultiSelectMode && this.rangeCount === 0) {
                var n = this.toOrientedRange();
                this.rangeList.add(n), this.rangeList.add(e);
                if (this.rangeList.ranges.length != 2) return this.rangeList.removeAll(), t || this.fromOrientedRange(e);
                this.rangeList.removeAll(), this.rangeList.add(n), this.$onAddRange(n);
            }
            e.cursor || (e.cursor = e.end);
            var r = this.rangeList.add(e);
            return this.$onAddRange(e), r.length && this.$onRemoveRange(r), this.rangeCount > 1 && !this.inMultiSelectMode && (this._signal("multiSelect"), this.inMultiSelectMode = !0, this.session.$undoSelect = !1, this.rangeList.attach(this.session)), t || this.fromOrientedRange(e);
        }, this.toSingleRange = function(e) {
            e = e || this.ranges[0];
            var t = this.rangeList.removeAll();
            t.length && this.$onRemoveRange(t), e && this.fromOrientedRange(e);
        }, this.substractPoint = function(e) {
            var t = this.rangeList.substractPoint(e);
            if (t) return this.$onRemoveRange(t), t[0];
        }, this.mergeOverlappingRanges = function() {
            var e = this.rangeList.merge();
            e.length && this.$onRemoveRange(e);
        }, this.$onAddRange = function(e) {
            this.rangeCount = this.rangeList.ranges.length, this.ranges.unshift(e), this._signal("addRange", {
                range: e
            });
        }, this.$onRemoveRange = function(e) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
                var t = this.rangeList.ranges.pop();
                e.push(t), this.rangeCount = 0;
            }
            for(var n = e.length; n--;){
                var r = this.ranges.indexOf(e[n]);
                this.ranges.splice(r, 1);
            }
            this._signal("removeRange", {
                ranges: e
            }), this.rangeCount === 0 && this.inMultiSelectMode && (this.inMultiSelectMode = !1, this._signal("singleSelect"), this.session.$undoSelect = !0, this.rangeList.detach(this.session)), t = t || this.ranges[0], t && !t.isEqual(this.getRange()) && this.fromOrientedRange(t);
        }, this.$initRangeList = function() {
            if (this.rangeList) return;
            this.rangeList = new r, this.ranges = [], this.rangeCount = 0;
        }, this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [
                this.getRange()
            ];
        }, this.splitIntoLines = function() {
            var e = this.ranges.length ? this.ranges : [
                this.getRange()
            ], t = [];
            for(var n = 0; n < e.length; n++){
                var r = e[n], s = r.start.row, o = r.end.row;
                if (s === o) t.push(r.clone());
                else {
                    t.push(new i(s, r.start.column, s, this.session.getLine(s).length));
                    while(++s < o)t.push(this.getLineRange(s, !0));
                    t.push(new i(o, 0, o, r.end.column));
                }
                n == 0 && !this.isBackwards() && (t = t.reverse());
            }
            this.toSingleRange();
            for(var n = t.length; n--;)this.addRange(t[n]);
        }, this.joinSelections = function() {
            var e = this.rangeList.ranges, t = e[e.length - 1], n = i.fromPoints(e[0].start, t.end);
            this.toSingleRange(), this.setSelectionRange(n, t.cursor == t.start);
        }, this.toggleBlockSelection = function() {
            if (this.rangeCount > 1) {
                var e = this.rangeList.ranges, t = e[e.length - 1], n = i.fromPoints(e[0].start, t.end);
                this.toSingleRange(), this.setSelectionRange(n, t.cursor == t.start);
            } else {
                var r = this.session.documentToScreenPosition(this.cursor), s = this.session.documentToScreenPosition(this.anchor), o = this.rectangularRangeBlock(r, s);
                o.forEach(this.addRange, this);
            }
        }, this.rectangularRangeBlock = function(e, t, n) {
            var r = [], s = e.column < t.column;
            if (s) var o = e.column, u = t.column, a = e.offsetX, f = t.offsetX;
            else var o = t.column, u = e.column, a = t.offsetX, f = e.offsetX;
            var l = e.row < t.row;
            if (l) var c = e.row, h = t.row;
            else var c = t.row, h = e.row;
            o < 0 && (o = 0), c < 0 && (c = 0), c == h && (n = !0);
            var p;
            for(var d = c; d <= h; d++){
                var m = i.fromPoints(this.session.screenToDocumentPosition(d, o, a), this.session.screenToDocumentPosition(d, u, f));
                if (m.isEmpty()) {
                    if (p && v(m.end, p)) break;
                    p = m.end;
                }
                m.cursor = s ? m.start : m.end, r.push(m);
            }
            l && r.reverse();
            if (!n) {
                var g = r.length - 1;
                while(r[g].isEmpty() && g > 0)g--;
                if (g > 0) {
                    var y = 0;
                    while(r[y].isEmpty())y++;
                }
                for(var b = g; b >= y; b--)r[b].isEmpty() && r.splice(b, 1);
            }
            return r;
        };
    }).call(s.prototype);
    var d = e("./editor").Editor;
    (function() {
        this.updateSelectionMarkers = function() {
            this.renderer.updateCursor(), this.renderer.updateBackMarkers();
        }, this.addSelectionMarker = function(e) {
            e.cursor || (e.cursor = e.end);
            var t = this.getSelectionStyle();
            return e.marker = this.session.addMarker(e, "ace_selection", t), this.session.$selectionMarkers.push(e), this.session.selectionMarkerCount = this.session.$selectionMarkers.length, e;
        }, this.removeSelectionMarker = function(e) {
            if (!e.marker) return;
            this.session.removeMarker(e.marker);
            var t = this.session.$selectionMarkers.indexOf(e);
            t != -1 && this.session.$selectionMarkers.splice(t, 1), this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        }, this.removeSelectionMarkers = function(e) {
            var t = this.session.$selectionMarkers;
            for(var n = e.length; n--;){
                var r = e[n];
                if (!r.marker) continue;
                this.session.removeMarker(r.marker);
                var i = t.indexOf(r);
                i != -1 && t.splice(i, 1);
            }
            this.session.selectionMarkerCount = t.length;
        }, this.$onAddRange = function(e) {
            this.addSelectionMarker(e.range), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
        }, this.$onRemoveRange = function(e) {
            this.removeSelectionMarkers(e.ranges), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
        }, this.$onMultiSelect = function(e) {
            if (this.inMultiSelectMode) return;
            this.inMultiSelectMode = !0, this.setStyle("ace_multiselect"), this.keyBinding.addKeyboardHandler(f.keyboardHandler), this.commands.setDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
        }, this.$onSingleSelect = function(e) {
            if (this.session.multiSelect.inVirtualMode) return;
            this.inMultiSelectMode = !1, this.unsetStyle("ace_multiselect"), this.keyBinding.removeKeyboardHandler(f.keyboardHandler), this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers(), this._emit("changeSelection");
        }, this.$onMultiSelectExec = function(e) {
            var t = e.command, n = e.editor;
            if (!n.multiSelect) return;
            if (!t.multiSelectAction) {
                var r = t.exec(n, e.args || {});
                n.multiSelect.addRange(n.multiSelect.toOrientedRange()), n.multiSelect.mergeOverlappingRanges();
            } else t.multiSelectAction == "forEach" ? r = n.forEachSelection(t, e.args) : t.multiSelectAction == "forEachLine" ? r = n.forEachSelection(t, e.args, !0) : t.multiSelectAction == "single" ? (n.exitMultiSelectMode(), r = t.exec(n, e.args || {})) : r = t.multiSelectAction(n, e.args || {});
            return r;
        }, this.forEachSelection = function(e, t, n) {
            if (this.inVirtualSelectionMode) return;
            var r = n && n.keepOrder, i = n == 1 || n && n.$byLines, o = this.session, u = this.selection, a = u.rangeList, f = (r ? u : a).ranges, l;
            if (!f.length) return e.exec ? e.exec(this, t || {}) : e(this, t || {});
            var c = u._eventRegistry;
            u._eventRegistry = {};
            var h = new s(o);
            this.inVirtualSelectionMode = !0;
            for(var p = f.length; p--;){
                if (i) while(p > 0 && f[p].start.row == f[p - 1].end.row)p--;
                h.fromOrientedRange(f[p]), h.index = p, this.selection = o.selection = h;
                var d = e.exec ? e.exec(this, t || {}) : e(this, t || {});
                !l && d !== undefined && (l = d), h.toOrientedRange(f[p]);
            }
            h.detach(), this.selection = o.selection = u, this.inVirtualSelectionMode = !1, u._eventRegistry = c, u.mergeOverlappingRanges(), u.ranges[0] && u.fromOrientedRange(u.ranges[0]);
            var v = this.renderer.$scrollAnimation;
            return this.onCursorChange(), this.onSelectionChange(), v && v.from == v.to && this.renderer.animateScrolling(v.from), l;
        }, this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
            this.multiSelect.toSingleRange();
        }, this.getSelectedText = function() {
            var e = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var t = this.multiSelect.rangeList.ranges, n = [];
                for(var r = 0; r < t.length; r++)n.push(this.session.getTextRange(t[r]));
                var i = this.session.getDocument().getNewLineCharacter();
                e = n.join(i), e.length == (n.length - 1) * i.length && (e = "");
            } else this.selection.isEmpty() || (e = this.session.getTextRange(this.getSelectionRange()));
            return e;
        }, this.$checkMultiselectChange = function(e, t) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var n = this.multiSelect.ranges[0];
                if (this.multiSelect.isEmpty() && t == this.multiSelect.anchor) return;
                var r = t == this.multiSelect.anchor ? n.cursor == n.start ? n.end : n.start : n.cursor;
                r.row != t.row || this.session.$clipPositionToDocument(r.row, r.column).column != t.column ? this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange()) : this.multiSelect.mergeOverlappingRanges();
            }
        }, this.findAll = function(e, t, n) {
            t = t || {}, t.needle = e || t.needle;
            if (t.needle == undefined) {
                var r = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                t.needle = this.session.getTextRange(r);
            }
            this.$search.set(t);
            var i = this.$search.findAll(this.session);
            if (!i.length) return 0;
            var s = this.multiSelect;
            n || s.toSingleRange(i[0]);
            for(var o = i.length; o--;)s.addRange(i[o], !0);
            return r && s.rangeList.rangeAtPoint(r.start) && s.addRange(r, !0), i.length;
        }, this.selectMoreLines = function(e, t) {
            var n = this.selection.toOrientedRange(), r = n.cursor == n.end, s = this.session.documentToScreenPosition(n.cursor);
            this.selection.$desiredColumn && (s.column = this.selection.$desiredColumn);
            var o = this.session.screenToDocumentPosition(s.row + e, s.column);
            if (!n.isEmpty()) var u = this.session.documentToScreenPosition(r ? n.end : n.start), a = this.session.screenToDocumentPosition(u.row + e, u.column);
            else var a = o;
            if (r) {
                var f = i.fromPoints(o, a);
                f.cursor = f.start;
            } else {
                var f = i.fromPoints(a, o);
                f.cursor = f.end;
            }
            f.desiredColumn = s.column;
            if (!this.selection.inMultiSelectMode) this.selection.addRange(n);
            else if (t) var l = n.cursor;
            this.selection.addRange(f), l && this.selection.substractPoint(l);
        }, this.transposeSelections = function(e) {
            var t = this.session, n = t.multiSelect, r = n.ranges;
            for(var i = r.length; i--;){
                var s = r[i];
                if (s.isEmpty()) {
                    var o = t.getWordRange(s.start.row, s.start.column);
                    s.start.row = o.start.row, s.start.column = o.start.column, s.end.row = o.end.row, s.end.column = o.end.column;
                }
            }
            n.mergeOverlappingRanges();
            var u = [];
            for(var i = r.length; i--;){
                var s = r[i];
                u.unshift(t.getTextRange(s));
            }
            e < 0 ? u.unshift(u.pop()) : u.push(u.shift());
            for(var i = r.length; i--;){
                var s = r[i], a = s.clone();
                t.replace(s, u[i]), s.start.row = a.start.row, s.start.column = a.start.column;
            }
            n.fromOrientedRange(n.ranges[0]);
        }, this.selectMore = function(e, t, n) {
            var r = this.session, i = r.multiSelect, s = i.toOrientedRange();
            if (s.isEmpty()) {
                s = r.getWordRange(s.start.row, s.start.column), s.cursor = e == -1 ? s.start : s.end, this.multiSelect.addRange(s);
                if (n) return;
            }
            var o = r.getTextRange(s), u = h(r, o, e);
            u && (u.cursor = e == -1 ? u.start : u.end, this.session.unfold(u), this.multiSelect.addRange(u), this.renderer.scrollCursorIntoView(null, .5)), t && this.multiSelect.substractPoint(s.cursor);
        }, this.alignCursors = function() {
            var e = this.session, t = e.multiSelect, n = t.ranges, r = -1, s = n.filter(function(e) {
                if (e.cursor.row == r) return !0;
                r = e.cursor.row;
            });
            if (!n.length || s.length == n.length - 1) {
                var o = this.selection.getRange(), u = o.start.row, f = o.end.row, l = u == f;
                if (l) {
                    var c = this.session.getLength(), h;
                    do h = this.session.getLine(f);
                    while (/[=:]/.test(h) && ++f < c);
                    do h = this.session.getLine(u);
                    while (/[=:]/.test(h) && --u > 0);
                    u < 0 && (u = 0), f >= c && (f = c - 1);
                }
                var p = this.session.removeFullLines(u, f);
                p = this.$reAlignText(p, l), this.session.insert({
                    row: u,
                    column: 0
                }, p.join("\n") + "\n"), l || (o.start.column = 0, o.end.column = p[p.length - 1].length), this.selection.setRange(o);
            } else {
                s.forEach(function(e) {
                    t.substractPoint(e.cursor);
                });
                var d = 0, v = Infinity, m = n.map(function(t) {
                    var n = t.cursor, r = e.getLine(n.row), i = r.substr(n.column).search(/\S/g);
                    return i == -1 && (i = 0), n.column > d && (d = n.column), i < v && (v = i), i;
                });
                n.forEach(function(t, n) {
                    var r = t.cursor, s = d - r.column, o = m[n] - v;
                    s > o ? e.insert(r, a.stringRepeat(" ", s - o)) : e.remove(new i(r.row, r.column, r.row, r.column - s + o)), t.start.column = t.end.column = d, t.start.row = t.end.row = r.row, t.cursor = t.end;
                }), t.fromOrientedRange(n[0]), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
            }
        }, this.$reAlignText = function(e, t) {
            function u(e) {
                return a.stringRepeat(" ", e);
            }
            function f(e) {
                return e[2] ? u(i) + e[2] + u(s - e[2].length + o) + e[4].replace(/^([=:])\s+/, "$1 ") : e[0];
            }
            function l(e) {
                return e[2] ? u(i + s - e[2].length) + e[2] + u(o) + e[4].replace(/^([=:])\s+/, "$1 ") : e[0];
            }
            function c(e) {
                return e[2] ? u(i) + e[2] + u(o) + e[4].replace(/^([=:])\s+/, "$1 ") : e[0];
            }
            var n = !0, r = !0, i, s, o;
            return e.map(function(e) {
                var t = e.match(/(\s*)(.*?)(\s*)([=:].*)/);
                return t ? i == null ? (i = t[1].length, s = t[2].length, o = t[3].length, t) : (i + s + o != t[1].length + t[2].length + t[3].length && (r = !1), i != t[1].length && (n = !1), i > t[1].length && (i = t[1].length), s < t[2].length && (s = t[2].length), o > t[3].length && (o = t[3].length), t) : [
                    e
                ];
            }).map(t ? f : n ? r ? l : f : c);
        };
    }).call(d.prototype), t.onSessionChange = function(e) {
        var t = e.session;
        t && !t.multiSelect && (t.$selectionMarkers = [], t.selection.$initRangeList(), t.multiSelect = t.selection), this.multiSelect = t && t.multiSelect;
        var n = e.oldSession;
        n && (n.multiSelect.off("addRange", this.$onAddRange), n.multiSelect.off("removeRange", this.$onRemoveRange), n.multiSelect.off("multiSelect", this.$onMultiSelect), n.multiSelect.off("singleSelect", this.$onSingleSelect), n.multiSelect.lead.off("change", this.$checkMultiselectChange), n.multiSelect.anchor.off("change", this.$checkMultiselectChange)), t && (t.multiSelect.on("addRange", this.$onAddRange), t.multiSelect.on("removeRange", this.$onRemoveRange), t.multiSelect.on("multiSelect", this.$onMultiSelect), t.multiSelect.on("singleSelect", this.$onSingleSelect), t.multiSelect.lead.on("change", this.$checkMultiselectChange), t.multiSelect.anchor.on("change", this.$checkMultiselectChange)), t && this.inMultiSelectMode != t.selection.inMultiSelectMode && (t.selection.inMultiSelectMode ? this.$onMultiSelect() : this.$onSingleSelect());
    }, t.MultiSelect = m, e("./config").defineOptions(d.prototype, "editor", {
        enableMultiselect: {
            set: function(e) {
                m(this), e ? this.on("mousedown", o) : this.off("mousedown", o);
            },
            value: !0
        },
        enableBlockSelect: {
            set: function(e) {
                this.$blockSelectEnabled = e;
            },
            value: !0
        }
    });
}), ace.define("ace/mode/folding/fold_mode", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(e, t, n) {
    "use strict";
    var r = e("../../range").Range, i = t.FoldMode = function() {};
    (function() {
        this.foldingStartMarker = null, this.foldingStopMarker = null, this.getFoldWidget = function(e, t, n) {
            var r = e.getLine(n);
            return this.foldingStartMarker.test(r) ? "start" : t == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(r) ? "end" : "";
        }, this.getFoldWidgetRange = function(e, t, n) {
            return null;
        }, this.indentationBlock = function(e, t, n) {
            var i = /\S/, s = e.getLine(t), o = s.search(i);
            if (o == -1) return;
            var u = n || s.length, a = e.getLength(), f = t, l = t;
            while(++t < a){
                var c = e.getLine(t).search(i);
                if (c == -1) continue;
                if (c <= o) {
                    var h = e.getTokenAt(t, 0);
                    if (!h || h.type !== "string") break;
                }
                l = t;
            }
            if (l > f) {
                var p = e.getLine(l).length;
                return new r(f, u, l, p);
            }
        }, this.openingBracketBlock = function(e, t, n, i, s) {
            var o = {
                row: n,
                column: i + 1
            }, u = e.$findClosingBracket(t, o, s);
            if (!u) return;
            var a = e.foldWidgets[u.row];
            return a == null && (a = e.getFoldWidget(u.row)), a == "start" && u.row > o.row && (u.row--, u.column = e.getLine(u.row).length), r.fromPoints(o, u);
        }, this.closingBracketBlock = function(e, t, n, i, s) {
            var o = {
                row: n,
                column: i
            }, u = e.$findOpeningBracket(t, o);
            if (!u) return;
            return u.column++, o.column--, r.fromPoints(u, o);
        };
    }).call(i.prototype);
}), ace.define("ace/ext/error_marker", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/range",
    "ace/config"
], function(e, t, n) {
    "use strict";
    function o(e, t, n) {
        var r = 0, i = e.length - 1;
        while(r <= i){
            var s = r + i >> 1, o = n(t, e[s]);
            if (o > 0) r = s + 1;
            else {
                if (!(o < 0)) return s;
                i = s - 1;
            }
        }
        return -(r + 1);
    }
    function u(e, t, n) {
        var r = e.getAnnotations().sort(i.comparePoints);
        if (!r.length) return;
        var s = o(r, {
            row: t,
            column: -1
        }, i.comparePoints);
        s < 0 && (s = -s - 1), s >= r.length ? s = n > 0 ? 0 : r.length - 1 : s === 0 && n < 0 && (s = r.length - 1);
        var u = r[s];
        if (!u || !n) return;
        if (u.row === t) {
            do u = r[s += n];
            while (u && u.row === t);
            if (!u) return r.slice();
        }
        var a = [];
        t = u.row;
        do a[n < 0 ? "unshift" : "push"](u), u = r[s += n];
        while (u && u.row == t);
        return a.length && a;
    }
    var r = e("../lib/dom"), i = e("../range").Range, s = e("../config").nls;
    t.showErrorMarker = function(e, t) {
        var n = e.session, i = e.getCursorPosition(), o = i.row, a = n.widgetManager.getWidgetsAtRow(o).filter(function(e) {
            return e.type == "errorMarker";
        })[0];
        a ? a.destroy() : o -= t;
        var f = u(n, o, t), l;
        if (f) {
            var c = f[0];
            i.column = (c.pos && typeof c.column != "number" ? c.pos.sc : c.column) || 0, i.row = c.row, l = e.renderer.$gutterLayer.$annotations[i.row];
        } else {
            if (a) return;
            l = {
                displayText: [
                    s("error-marker.good-state", "Looks good!")
                ],
                className: "ace_ok"
            };
        }
        e.session.unfold(i.row), e.selection.moveToPosition(i);
        var h = {
            row: i.row,
            fixedWidth: !0,
            coverGutter: !0,
            el: r.createElement("div"),
            type: "errorMarker"
        }, p = h.el.appendChild(r.createElement("div")), d = h.el.appendChild(r.createElement("div"));
        d.className = "error_widget_arrow " + l.className;
        var v = e.renderer.$cursorLayer.getPixelPosition(i).left;
        d.style.left = v + e.renderer.gutterWidth - 5 + "px", h.el.className = "error_widget_wrapper", p.className = "error_widget " + l.className, l.displayText.forEach(function(e, t) {
            p.appendChild(r.createTextNode(e)), t < l.displayText.length - 1 && p.appendChild(r.createElement("br"));
        }), p.appendChild(r.createElement("div"));
        var m = function(e, t, n) {
            if (t === 0 && (n === "esc" || n === "return")) return h.destroy(), {
                command: "null"
            };
        };
        h.destroy = function() {
            if (e.$mouseHandler.isMousePressed) return;
            e.keyBinding.removeKeyboardHandler(m), n.widgetManager.removeLineWidget(h), e.off("changeSelection", h.destroy), e.off("changeSession", h.destroy), e.off("mouseup", h.destroy), e.off("change", h.destroy);
        }, e.keyBinding.addKeyboardHandler(m), e.on("changeSelection", h.destroy), e.on("changeSession", h.destroy), e.on("mouseup", h.destroy), e.on("change", h.destroy), e.session.widgetManager.addLineWidget(h), h.el.onmousedown = e.focus.bind(e), e.renderer.scrollCursorIntoView(null, .5, {
            bottom: h.el.offsetHeight
        });
    }, r.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", !1);
}), ace.define("ace/ace", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/range",
    "ace/editor",
    "ace/edit_session",
    "ace/undomanager",
    "ace/virtual_renderer",
    "ace/worker/worker_client",
    "ace/keyboard/hash_handler",
    "ace/placeholder",
    "ace/multi_select",
    "ace/mode/folding/fold_mode",
    "ace/theme/textmate",
    "ace/ext/error_marker",
    "ace/config",
    "ace/loader_build"
], function(e, t, n) {
    "use strict";
    e("./loader_build")(t);
    var r = e("./lib/dom"), i = e("./range").Range, s = e("./editor").Editor, o = e("./edit_session").EditSession, u = e("./undomanager").UndoManager, a = e("./virtual_renderer").VirtualRenderer;
    e("./worker/worker_client"), e("./keyboard/hash_handler"), e("./placeholder"), e("./multi_select"), e("./mode/folding/fold_mode"), e("./theme/textmate"), e("./ext/error_marker"), t.config = e("./config"), t.edit = function(e, n) {
        if (typeof e == "string") {
            var i = e;
            e = document.getElementById(i);
            if (!e) throw new Error("ace.edit can't find div #" + i);
        }
        if (e && e.env && e.env.editor instanceof s) return e.env.editor;
        var o = "";
        if (e && /input|textarea/i.test(e.tagName)) {
            var u = e;
            o = u.value, e = r.createElement("pre"), u.parentNode.replaceChild(e, u);
        } else e && (o = e.textContent, e.innerHTML = "");
        var f = t.createEditSession(o), l = new s(new a(e), f, n), c = {
            document: f,
            editor: l,
            onResize: l.resize.bind(l, null)
        };
        return u && (c.textarea = u), l.on("destroy", function() {
            c.editor.container.env = null;
        }), l.container.env = l.env = c, l;
    }, t.createEditSession = function(e, t) {
        var n = new o(e, t);
        return n.setUndoManager(new u), n;
    }, t.Range = i, t.Editor = s, t.EditSession = o, t.UndoManager = u, t.VirtualRenderer = a;
    var f = t.config.version;
    t.version = f;
});
(function() {
    ace.require([
        "ace/ace"
    ], function(a) {
        if (a) {
            a.config.init(true);
            a.define = ace.define;
        }
        var global = function() {
            return this;
        }();
        if (!global && typeof window != "undefined") global = window; // can happen in strict mode
        if (!global && typeof self != "undefined") global = self; // can happen in webworker
        if (!global.ace) global.ace = a;
        for(var key in a)if (a.hasOwnProperty(key)) global.ace[key] = a[key];
        global.ace["default"] = global.ace;
        if (module) module.exports = global.ace;
    });
})();

},{}],"dfUSf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getMode", ()=>getMode);
function getMode(name) {
    return "ace/mode/" + (modes[name] || "text");
}
const modes = {
    // !--------------------------------------
    // ! A
    // !--------------------------------------
    abap: "abap",
    "sap-abap": "abap",
    /* ------------------------------------- */ abc: "abc",
    /* ------------------------------------- */ actionscript: "actionscript",
    as: "actionscript",
    /* ------------------------------------- */ ada: "ada",
    adb: "ada",
    alda: "alda",
    /* ------------------------------------- */ apache: "apache_conf",
    apacheconf: "apache_conf",
    apache_conf: "apache_conf",
    htaccess: "apache_conf",
    htgroups: "apache_conf",
    htpasswd: "apache_conf",
    /* ------------------------------------- */ apex: "apex",
    cls: "apex",
    trigger: "apex",
    tgr: "apex",
    /* ------------------------------------- */ applescript: "applescript",
    oascript: "applescript",
    /* ------------------------------------- */ aql: "aql",
    /* ------------------------------------- */ arduino: "c_cpp",
    ino: "cpp",
    /* ------------------------------------- */ armasm: "assembly_arm32",
    arm: "assembly_arm32",
    assembly_arm32: "assembly_arm32",
    arm32: "assembly_arm32",
    /* ------------------------------------- */ asl: "asl",
    dsl: "asl",
    "asl.json": "asl",
    /* ------------------------------------- */ asciidoc: "asciidoc",
    adoc: "asciidoc",
    /* ------------------------------------- */ aspectj: "java",
    /* ------------------------------------- */ astro: "astro",
    /* ------------------------------------- */ autohotkey: "autohotkey",
    ahk: "autohotkey",
    /* ------------------------------------- */ avrasm: "assembly_x86",
    asm: "assembly_x86",
    a: "assembly_x86",
    // !--------------------------------------
    // ! B
    // !--------------------------------------
    bash: "sh",
    sh: "sh",
    /* ------------------------------------- */ basic: "vbscript",
    bibtex: "bibtex",
    bib: "bibtex",
    // !--------------------------------------
    // ! C
    // !--------------------------------------
    c: "c_cpp",
    h: "c_pp",
    /* ------------------------------------- */ c9search: "c9search",
    c9search_results: "c9search",
    /* ------------------------------------- */ cirru: "cirru",
    /* ------------------------------------- */ clojure: "clojure",
    clj: "clojure",
    cljs: "clojure",
    edn: "clojure",
    /* ------------------------------------- */ cmake: "makefile",
    "cmake.in": "makefile",
    /* ------------------------------------- */ cobol: "cobol",
    cbl: "cobol",
    cob: "cobol",
    /* ------------------------------------- */ coffeescript: "coffee",
    coffee: "coffee",
    cakefile: "coffee",
    cf: "coffee",
    cson: "coffee",
    iced: "coffee",
    /* ------------------------------------- */ coldfusion: "coldfusion",
    cfm: "coldfusion",
    /* ------------------------------------- */ cpp: "c_cpp",
    cc: "c_cpp",
    "c++": "c_cpp",
    "h++": "c_cpp",
    hpp: "c_cpp",
    hh: "c_cpp",
    hxx: "c_cpp",
    cxx: "c_cpp",
    /* ------------------------------------- */ clue: "clue",
    /* ------------------------------------- */ crmsh: "sh",
    crm: "sh",
    pcmk: "sh",
    /* ------------------------------------- */ crystal: "crystal",
    cr: "crystal",
    /* ------------------------------------- */ csharp: "csharp",
    cs: "csharp",
    "c#": "csharp",
    /* ------------------------------------- */ csound_document: "csound_document",
    csd: "csound_document",
    csound_orchestra: "csound_orchestra",
    orc: "csound_orchestra",
    csound_score: "csound_score",
    sco: "csound_score",
    /* ------------------------------------- */ csp: "csp",
    /* ------------------------------------- */ css: "css",
    /* ------------------------------------- */ csv: "csv",
    /* ------------------------------------- */ curly: "curly",
    // !--------------------------------------
    // ! D
    // !--------------------------------------
    d: "d",
    di: "d",
    /* ------------------------------------- */ dart: "dart",
    /* ------------------------------------- */ delphi: "pascal",
    dpr: "pascal",
    dfm: "pascal",
    pas: "pascal",
    pascal: "pascal",
    /* ------------------------------------- */ diff: "diff",
    patch: "diff",
    /* ------------------------------------- */ django: "django",
    jinja: "django",
    /* ------------------------------------- */ dockerfile: "dockerfile",
    docker: "dockerfile",
    /* ------------------------------------- */ dos: "batchfile",
    bat: "batchfile",
    cmd: "batchfile",
    batchfile: "batchfile",
    /* ------------------------------------- */ drools: "drools",
    drl: "drools",
    /* ------------------------------------- */ dot: "dot",
    // !--------------------------------------
    // ! E
    // !--------------------------------------
    edifact: "edifact",
    edi: "edifact",
    /* ------------------------------------- */ eiffel: "eiffel",
    e: "eiffel",
    ge: "eiffel",
    /* ------------------------------------- */ ejs: "ejs",
    /* ------------------------------------- */ elixir: "elixir",
    ex: "elixir",
    exs: "elixir",
    /* ------------------------------------- */ elm: "elm",
    /* ------------------------------------- */ erlang: "erlang",
    erl: "erlang",
    hrl: "erlang",
    // !--------------------------------------
    // ! F
    // !--------------------------------------
    forth: "forth",
    frt: "forth",
    ldr: "forth",
    fth: "forth",
    "4th": "forth",
    /* ------------------------------------- */ fortran: "fortran",
    f90: "fortran",
    f95: "fortran",
    f: "fortran",
    /* ------------------------------------- */ flix: "flix",
    /* ------------------------------------- */ fsharp: "fsharp",
    fsi: "fsharp",
    fs: "fsharp",
    mli: "fsharp",
    fsx: "fsharp",
    fsscript: "fsharp",
    "f#": "fsharp",
    /* ------------------------------------- */ fsl: "fsl",
    /* ------------------------------------- */ ftl: "ftl",
    // !--------------------------------------
    // ! G
    // !--------------------------------------
    gcode: "gcode",
    nc: "gcode",
    /* ------------------------------------- */ gherkin: "gherkin",
    feature: "gherkin",
    /* ------------------------------------- */ gitignore: "gitignore",
    /* ------------------------------------- */ glsl: "glsl",
    frag: "glsl",
    vert: "glsl",
    /* ------------------------------------- */ gobstones: "gobstones",
    /* ------------------------------------- */ go: "golang",
    golang: "golang",
    /* ------------------------------------- */ graphqlschema: "graphqlschema",
    gql: "graphqlschema",
    /* ------------------------------------- */ groovy: "groovy",
    // !--------------------------------------
    // ! H
    // !--------------------------------------
    haml: "haml",
    /* ------------------------------------- */ handlebars: "handlebars",
    hbs: "handlebars",
    "html.hbs": "handlebars",
    "html.handlebars": "handlebars",
    htmlbars: "handlebars",
    tpl: "handlebars",
    mustache: "handlebars",
    /* ------------------------------------- */ haskell: "haskell",
    hs: "haskell",
    /* ------------------------------------- */ haskell_cabal: "haskell_cabal",
    cabal: "haskell_cabal",
    /* ------------------------------------- */ haxe: "haxe",
    hx: "haxe",
    /* ------------------------------------- */ hjson: "hjson",
    /* ------------------------------------- */ html_elixir: "html_elixir",
    "html.eex": "html_elixir",
    /* ------------------------------------- */ html_ruby: "html_ruby",
    erb: "html_ruby",
    "html.erb": "html_ruby",
    /* ------------------------------------- */ hy: "lisp",
    hylang: "lisp",
    // !--------------------------------------
    // ! I
    // !--------------------------------------
    ini: "ini",
    conf: "ini",
    cfg: "ini",
    prefs: "ini",
    toml: "toml",
    /* ------------------------------------- */ io: "io",
    ion: "ion",
    // !--------------------------------------
    // ! J
    // !--------------------------------------
    jack: "jack",
    /* ------------------------------------- */ jade: "jade",
    pug: "jade",
    /* ------------------------------------- */ java: "java",
    jsp: "jsp",
    /* ------------------------------------- */ javascript: "javascript",
    js: "javascript",
    jsm: "javascript",
    jsx: "jsx",
    cjs: "javascript",
    mjs: "javascript",
    /* ------------------------------------- */ jexl: "jexl",
    /* ------------------------------------- */ jsdoc: "jsdoc",
    jsdoc_comment: "jsdoc",
    /* ------------------------------------- */ json: "json",
    /* ------------------------------------- */ json5: "json5",
    /* ------------------------------------- */ jsoniq: "jsoniq",
    jq: "jsoniq",
    /* ------------------------------------- */ jssm: "jssm",
    jssm_state: "jssm",
    /* ------------------------------------- */ julia: "julia",
    jl: "julia",
    // !--------------------------------------
    // ! K
    // !--------------------------------------
    kotlin: "kotlin",
    kot: "kotlin",
    kt: "kotlin",
    kts: "kotlin",
    // !--------------------------------------
    // ! L
    // !--------------------------------------
    latex: "latex",
    ltx: "latex",
    tex: "tex",
    /* ------------------------------------- */ latte: "latte",
    /* ------------------------------------- */ less: "less",
    /* ------------------------------------- */ liquid: "liquid",
    /* ------------------------------------- */ lisp: "lisp",
    /* ------------------------------------- */ livescript: "livescript",
    ls: "livescript",
    /* ------------------------------------- */ logiql: "logiql",
    lql: "logiql",
    /* ------------------------------------- */ log: "log",
    /* ------------------------------------- */ logtalk: "logtalk",
    lgt: "logtalk",
    /* ------------------------------------- */ lsl: "lsl",
    /* ------------------------------------- */ lua: "lua",
    /* ------------------------------------- */ luapage: "luapage",
    lp: "luapage",
    /* ------------------------------------- */ lucene: "lucene",
    // !--------------------------------------
    // ! M
    // !--------------------------------------
    makefile: "makefile",
    make: "makefile",
    mak: "makefile",
    mk: "makefile",
    gnumakefile: "makefile",
    ocamlmakefile: "makefile",
    /* ------------------------------------- */ markdown: "markdown",
    md: "markdown",
    mkd: "markdown",
    mkdown: "markdown",
    /* ------------------------------------- */ mask: "mask",
    /* ------------------------------------- */ matlab: "matlab",
    /* ------------------------------------- */ maze: "maze",
    mz: "maze",
    /* ------------------------------------- */ mediawiki: "mediawiki",
    wiki: "mediawiki",
    /* ------------------------------------- */ mel: "mel",
    /* ------------------------------------- */ mipsasm: "mips",
    mips: "mips",
    /* ------------------------------------- */ mixal: "mixal",
    /* ------------------------------------- */ mushcode: "mushcode",
    mc: "mushcode",
    mush: "mushcode",
    /* ------------------------------------- */ mysql: "mysql",
    // !--------------------------------------
    // ! N
    // !--------------------------------------
    nasal: "nasal",
    /* ------------------------------------- */ nginx: "nginx",
    nginxconf: "nginx",
    /* ------------------------------------- */ nim: "nim",
    /* ------------------------------------- */ nix: "nix",
    nixos: "nix",
    /* ------------------------------------- */ nsis: "nsis",
    nsh: "nsis",
    /* ------------------------------------- */ nunjucks: "nunjucks",
    nunjs: "nunjucks",
    nj: "nunjacks",
    njk: "nunjacks",
    // !--------------------------------------
    // ! O
    // !--------------------------------------
    objectivec: "objectivec",
    mm: "objectivec",
    objc: "objectivec",
    "obj-c": "objectivec",
    "obj-c++": "objectivec",
    "objective-c++": "objectivec",
    /* ------------------------------------- */ ocaml: "ocaml",
    ml: "ocaml",
    /* ------------------------------------- */ odin: "odin",
    /* ------------------------------------- */ openscad: "scad",
    scad: "scad",
    // !--------------------------------------
    // ! P
    // !--------------------------------------
    partiql: "partiql",
    pql: "partiql",
    /* ------------------------------------- */ perl: "perl",
    pl: "perl",
    pm: "perl",
    /* ------------------------------------- */ pgsql: "pgsql",
    postgres: "pgsql",
    postgresql: "pgsql",
    /* ------------------------------------- */ php: "php",
    inc: "php",
    phtml: "php",
    shtml: "php",
    php3: "php",
    php4: "php",
    php5: "php",
    phps: "php",
    phpt: "php",
    aw: "php",
    ctp: "php",
    module: "php",
    /* ------------------------------------- */ php_laravel_blade: "php_laravel_blade",
    /* ------------------------------------- */ pig: "pig",
    /* ------------------------------------- */ plain_text: "plain_text",
    text: "text",
    txt: "text",
    /* ------------------------------------- */ plsql: "plsql",
    /* ------------------------------------- */ powershell: "powershell",
    pwsh: "powershell",
    ps: "powershell",
    ps1: "powershell",
    /* ------------------------------------- */ praat: "praat",
    praatscript: "praat",
    psc: "praat",
    proc: "praat",
    /* ------------------------------------- */ prisma: "prisma",
    /* ------------------------------------- */ processing: "c_cpp",
    pde: "c_cpp",
    /* ------------------------------------- */ prolog: "prolog",
    plg: "prolog",
    /* ------------------------------------- */ properties: "properties",
    /* ------------------------------------- */ protobuf: "protobuf",
    /* ------------------------------------- */ puppet: "puppet",
    pp: "puppet",
    /* ------------------------------------- */ purebasic: "vbscript",
    pb: "vbscript",
    pbi: "vbscript",
    /* ------------------------------------- */ python: "python",
    py: "python",
    gyp: "python",
    ipython: "python",
    // !--------------------------------------
    // ! Q
    // !--------------------------------------
    qml: "qml",
    qt: "qml",
    // !--------------------------------------
    // ! R
    // !--------------------------------------
    r: "r",
    /* ------------------------------------- */ raku: "raku",
    /* ------------------------------------- */ razor: "razor",
    /* ------------------------------------- */ rdoc: "rdoc",
    /* ------------------------------------- */ red: "red",
    /* ------------------------------------- */ redshift: "redshift",
    /* ------------------------------------- */ rhtml: "rhtml",
    /* ------------------------------------- */ robot: "robot",
    resource: "robot",
    /* ------------------------------------- */ rst: "rst",
    rest: "rst",
    /* ------------------------------------- */ ruby: "ruby",
    gemspec: "ruby",
    irb: "ruby",
    podspec: "ruby",
    guardfile: "ruby",
    rb: "ruby",
    thor: "ruby",
    /* ------------------------------------- */ rust: "rust",
    rs: "rust",
    // !--------------------------------------
    // ! S
    // !--------------------------------------
    sac: "sac",
    /* ------------------------------------- */ sass: "sass",
    /* ------------------------------------- */ scala: "scala",
    sbt: "scala",
    /* ------------------------------------- */ scheme: "scheme",
    scm: "scheme",
    sm: "scheme",
    rkt: "scheme",
    oak: "scheme",
    /* ------------------------------------- */ scrypt: "scrypt",
    /* ------------------------------------- */ scss: "scss",
    /* ------------------------------------- */ shell: "sh",
    console: "sh",
    shellsession: "sh",
    /* ------------------------------------- */ sjs: "sjs",
    /* ------------------------------------- */ slim: "slim",
    skim: "slim",
    /* ------------------------------------- */ smarty: "smarty",
    /* ------------------------------------- */ smithy: "smithy",
    /* ------------------------------------- */ soy: "soy",
    soy_template: "soy",
    /* ------------------------------------- */ space: "space",
    /* ------------------------------------- */ sparql: "sparql",
    rq: "sparql",
    /* ------------------------------------- */ sql: "sql",
    /* ------------------------------------- */ sqlserver: "sqlserver",
    /* ------------------------------------- */ stylus: "stylus",
    styl: "stylus",
    /* ------------------------------------- */ swift: "swift",
    // !--------------------------------------
    // ! T
    // !--------------------------------------
    tcl: "tcl",
    tk: "tcl",
    /* ------------------------------------- */ terraform: "terraform",
    tf: "terraform",
    tfvars: "terraform",
    terragrunt: "terraform",
    /* ------------------------------------- */ textile: "textile",
    /* ------------------------------------- */ turtle: "turtle",
    ttl: "turtle",
    /* ------------------------------------- */ twig: "twig",
    swig: "twig",
    craftcms: "twig",
    /* ------------------------------------- */ typescript: "typescript",
    ts: "typescript",
    /* ------------------------------------- */ tsv: "tsv",
    /* ------------------------------------- */ tsx: "tsx",
    // !--------------------------------------
    // ! V
    // !--------------------------------------
    vala: "vala",
    /* ------------------------------------- */ vbnet: "vbscript",
    vb: "vbscript",
    /* ------------------------------------- */ vbscript: "vbscript",
    vbs: "vbscript",
    /* ------------------------------------- */ velocity: "velocity",
    vm: "velocity",
    /* ------------------------------------- */ verilog: "verilog",
    sv: "verilog",
    svh: "verilog",
    v: "verilog",
    vh: "verilog",
    /* ------------------------------------- */ vhdl: "vhdl",
    vhd: "vhdl",
    /* ------------------------------------- */ visualforce: "visualforce",
    vfp: "visualforce",
    component: "visualforce",
    page: "visualforce",
    /* ------------------------------------- */ vue: "vue",
    // !--------------------------------------
    // ! W
    // !--------------------------------------
    wollok: "wollok",
    wlk: "wollok",
    wpgm: "wollok",
    wtest: "wollok",
    // !--------------------------------------
    // ! X
    // !--------------------------------------
    x86asm: "assembly_x86",
    /* ------------------------------------- */ xml: "xml",
    atom: "xml",
    html: "html",
    plist: "xml",
    rss: "xml",
    wdsl: "xml",
    svg: "svg",
    wsf: "xml",
    xbl: "xml",
    xhtml: "html",
    xjb: "xml",
    xsd: "xml",
    xsl: "xml",
    htm: "html",
    we: "html",
    wpy: "html",
    mathml: "xml",
    mml: "xml",
    rdf: "xml",
    xaml: "xml",
    xul: "xml",
    /* ------------------------------------- */ xquery: "xquery",
    xpath: "xquery",
    xq: "xquery",
    // !--------------------------------------
    // ! Y
    // !--------------------------------------
    yaml: "yaml",
    yml: "yaml",
    // !--------------------------------------
    // ! Z
    // !--------------------------------------
    zeek: "zeek",
    bro: "zeek",
    zig: "zig"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8GLpd":[function(require,module,exports) {
/*!
 * ¬© 2016-2021 Convergence Labs, Inc.
 * @version 0.6.0
 * @license MIT
 */ (function(global, factory) {
    factory(exports, require("21d851e32bab3278"));
})(this, function(exports1, aceBuilds) {
    "use strict";
    var AceSelectionMarker = /** @class */ function() {
        function AceSelectionMarker(session, selectionId, label, color, ranges) {
            this._session = session;
            this._label = label;
            this._color = color;
            this._ranges = ranges || [];
            this._selectionId = selectionId;
            this._id = null;
            this._markerElement = document.createElement("div");
        }
        AceSelectionMarker.prototype.update = function(_, markerLayer, session, layerConfig) {
            var _this = this;
            while(this._markerElement.hasChildNodes())this._markerElement.removeChild(this._markerElement.lastChild);
            this._ranges.forEach(function(range) {
                _this._renderRange(markerLayer, session, layerConfig, range);
            });
            this._markerElement.remove();
            markerLayer.elt("remote-selection", "");
            var parentNode = markerLayer.element.childNodes[markerLayer.i - 1] || markerLayer.element.lastChild;
            parentNode.appendChild(this._markerElement);
        };
        AceSelectionMarker.prototype.setSelection = function(ranges) {
            if (ranges === undefined || ranges === null) this._ranges = [];
            else if (ranges instanceof Array) this._ranges = ranges;
            else this._ranges = [
                ranges
            ];
            this._forceSessionUpdate();
        };
        AceSelectionMarker.prototype.getLabel = function() {
            return this._label;
        };
        AceSelectionMarker.prototype.selectionId = function() {
            return this._selectionId;
        };
        AceSelectionMarker.prototype.markerId = function() {
            return this._id;
        };
        AceSelectionMarker.prototype._renderLine = function(bounds) {
            var div = document.createElement("div");
            div.className = "ace-multi-selection";
            div.style.backgroundColor = this._color;
            if (typeof bounds.height === "number") div.style.height = bounds.height + "px";
            if (typeof bounds.width === "number") div.style.width = bounds.width + "px";
            if (typeof bounds.top === "number") div.style.top = bounds.top + "px";
            if (typeof bounds.left === "number") div.style.left = bounds.left + "px";
            if (typeof bounds.bottom === "number") div.style.bottom = bounds.bottom + "px";
            if (typeof bounds.right === "number") div.style.right = bounds.right + "px";
            this._markerElement.append(div);
        };
        AceSelectionMarker.prototype._renderRange = function(markerLayer, session, layerConfig, range) {
            var screenRange = range.toScreenRange(session);
            var height = layerConfig.lineHeight;
            var top = markerLayer.$getTop(screenRange.start.row, layerConfig);
            var width = 0;
            var right = 0;
            var left = markerLayer.$padding + screenRange.start.column * layerConfig.characterWidth;
            if (screenRange.isMultiLine()) {
                // Render the start line
                this._renderLine({
                    height: height,
                    right: right,
                    top: top,
                    left: left
                });
                // from start of the last line to the selection end
                top = markerLayer.$getTop(screenRange.end.row, layerConfig);
                width = screenRange.end.column * layerConfig.characterWidth;
                this._renderLine({
                    height: height,
                    width: width,
                    top: top,
                    left: markerLayer.$padding
                });
                // all the complete lines
                height = (screenRange.end.row - screenRange.start.row - 1) * layerConfig.lineHeight;
                if (height < 0) return;
                top = markerLayer.$getTop(screenRange.start.row + 1, layerConfig);
                this._renderLine({
                    height: height,
                    right: right,
                    top: top,
                    left: markerLayer.$padding
                });
            } else {
                width = (range.end.column - range.start.column) * layerConfig.characterWidth;
                this._renderLine({
                    height: height,
                    width: width,
                    top: top,
                    left: left
                });
            }
        };
        AceSelectionMarker.prototype._forceSessionUpdate = function() {
            this._session._signal("changeBackMarker");
        };
        return AceSelectionMarker;
    }();
    /**
     * Implements multiple colored selections in the ace editor.  Each selection is
     * associated with a particular user. Each user is identified by a unique id
     * and has a color associated with them.  The selection manager supports block
     * selection through multiple AceRanges.
     */ var AceMultiSelectionManager = /** @class */ function() {
        /**
         * Constructs a new AceMultiSelectionManager that is bound to a particular
         * Ace EditSession instance.
         *
         * @param session
         *   The Ace EditSession to bind to.
         */ function AceMultiSelectionManager(session) {
            this._selections = {};
            this._session = session;
        }
        /**
         * Adds a new collaborative selection.
         *
         * @param id
         *   The unique system identifier for the user associated with this selection.
         * @param label
         *   A human readable / meaningful label / title that identifies the user.
         * @param color
         *   A valid css color string.
         * @param ranges
         *   An array of ace ranges that specify the initial selection.
         */ AceMultiSelectionManager.prototype.addSelection = function(id, label, color, ranges) {
            if (this._selections[id] !== undefined) throw new Error("Selection with id already defined: " + id);
            var marker = new AceSelectionMarker(this._session, id, label, color, ranges);
            this._selections[id] = marker;
            this._session.addDynamicMarker(marker, false);
        };
        /**
         * Updates the selection for a particular user.
         *
         * @param id
         *   The unique identifier for the user.
         * @param ranges
         *   The array of ranges that specify the selection.
         */ AceMultiSelectionManager.prototype.setSelection = function(id, ranges) {
            var selection = this._getSelection(id);
            selection.setSelection(ranges);
        };
        /**
         * Clears the selection (but does not remove it) for the specified user.
         * @param id
         *   The unique identifier for the user.
         */ AceMultiSelectionManager.prototype.clearSelection = function(id) {
            var selection = this._getSelection(id);
            selection.setSelection(null);
        };
        /**
         * Removes the selection for the specified user.
         * @param id
         *   The unique identifier for the user.
         */ AceMultiSelectionManager.prototype.removeSelection = function(id) {
            var selection = this._selections[id];
            if (selection === undefined) throw new Error("Selection not found: " + id);
            // note: ace adds the id property to whatever marker you pass in.
            this._session.removeMarker(selection.id);
            delete this._selections[id];
        };
        /**
         * Removes all selections.
         */ AceMultiSelectionManager.prototype.removeAll = function() {
            var _this = this;
            Object.getOwnPropertyNames(this._selections).forEach(function(key) {
                _this.removeSelection(_this._selections[key].selectionId());
            });
        };
        AceMultiSelectionManager.prototype._getSelection = function(id) {
            var selection = this._selections[id];
            if (selection === undefined) throw new Error("Selection not found: " + id);
            return selection;
        };
        return AceMultiSelectionManager;
    }();
    /**
     * Represents a marker of a remote users cursor.
     */ var AceCursorMarker = /** @class */ function() {
        /**
         * Constructs a new AceCursorMarker
         * @param session The Ace Editor Session to bind to.
         * @param cursorId the unique id of this cursor.
         * @param label The label to display over the cursor.
         * @param color The css color of the cursor
         * @param position The row / column coordinate of the cursor marker.
         */ function AceCursorMarker(session, cursorId, label, color, position) {
            this._session = session;
            this._label = label;
            this._color = color;
            this._position = position ? this._convertPosition(position) : null;
            this._cursorId = cursorId;
            this._id = null;
            this._visible = false;
            this._tooltipTimeout = null;
            // Create the HTML elements
            this._markerElement = document.createElement("div");
            this._cursorElement = document.createElement("div");
            this._cursorElement.className = "ace-multi-cursor";
            this._cursorElement.style.background = this._color;
            this._markerElement.append(this._cursorElement);
            this._tooltipElement = document.createElement("div");
            this._tooltipElement.className = "ace-multi-cursor-tooltip";
            this._tooltipElement.style.background = this._color;
            this._tooltipElement.style.opacity = "0";
            this._tooltipElement.innerHTML = label;
            this._markerElement.append(this._tooltipElement);
        }
        /**
         * Called by Ace to update the rendering of the marker.
         *
         * @param _ The html to render, represented by an array of strings.
         * @param markerLayer The marker layer containing the cursor marker.
         * @param __ The ace edit session.
         * @param layerConfig
         */ AceCursorMarker.prototype.update = function(_, markerLayer, __, layerConfig) {
            if (this._position === null) return;
            var screenPosition = this._session.documentToScreenPosition(this._position.row, this._position.column);
            var top = markerLayer.$getTop(screenPosition.row, layerConfig);
            var left = markerLayer.$padding + screenPosition.column * layerConfig.characterWidth;
            var height = layerConfig.lineHeight;
            var cursorTop = top + 2;
            var cursorHeight = height - 3;
            var cursorLeft = left;
            var cursorWidth = 2;
            this._cursorElement.style.height = cursorHeight + "px";
            this._cursorElement.style.width = cursorWidth + "px";
            this._cursorElement.style.top = cursorTop + "px";
            this._cursorElement.style.left = cursorLeft + "px";
            var toolTipTop = cursorTop - height;
            if (toolTipTop < 5) toolTipTop = cursorTop + height - 1;
            var toolTipLeft = cursorLeft;
            this._tooltipElement.style.top = toolTipTop - 2 + "px";
            this._tooltipElement.style.left = toolTipLeft - 2 + "px";
            // Remove the content node from whatever parent it might have now
            // and add it to the new parent node.
            this._markerElement.remove();
            markerLayer.elt("remote-cursor", "");
            var parentNode = markerLayer.element.childNodes[markerLayer.i - 1] || markerLayer.element.lastChild;
            parentNode.appendChild(this._markerElement);
        };
        /**
         * Sets the location of the cursor marker.
         * @param position The position of cursor marker.
         */ AceCursorMarker.prototype.setPosition = function(position) {
            this._position = this._convertPosition(position);
            this._forceSessionUpdate();
            this._tooltipElement.style.opacity = "1";
            this._scheduleTooltipHide();
        };
        /**
         * Sets the marker to visible / invisible.
         *
         * @param visible true if the marker should be displayed, false otherwise.
         */ AceCursorMarker.prototype.setVisible = function(visible) {
            var old = this._visible;
            this._visible = visible;
            if (old !== this._visible) {
                this._markerElement.style.visibility = visible ? "visible" : "hidden";
                this._forceSessionUpdate();
            }
        };
        /**
         * Determines if the marker should be visible.
         *
         * @returns true if the cursor should be visible, false otherwise.
         */ AceCursorMarker.prototype.isVisible = function() {
            return this._visible;
        };
        /**
         * Gets the unique id of this cursor.
         * @returns the unique id of this cursor.
         */ AceCursorMarker.prototype.cursorId = function() {
            return this._cursorId;
        };
        /**
         * Gets the id of the marker.
         * @returns The marker id.
         */ AceCursorMarker.prototype.markerId = function() {
            return this._id;
        };
        /**
         * Gets the label of the marker.
         * @returns The marker"s label.
         */ AceCursorMarker.prototype.getLabel = function() {
            return this._label;
        };
        AceCursorMarker.prototype._forceSessionUpdate = function() {
            this._session._signal("changeFrontMarker");
        };
        AceCursorMarker.prototype._convertPosition = function(position) {
            if (position === null) return null;
            else if (typeof position === "number") return this._session.getDocument().indexToPosition(position, 0);
            else if (typeof position.row === "number" && typeof position.column === "number") return position;
            throw new Error("Invalid position: " + position);
        };
        AceCursorMarker.prototype._scheduleTooltipHide = function() {
            var _this = this;
            if (this._tooltipTimeout !== null) clearTimeout(this._tooltipTimeout);
            this._tooltipTimeout = setTimeout(function() {
                _this._tooltipElement.style.opacity = "0";
                _this._tooltipTimeout = null;
            }, 2000);
        };
        return AceCursorMarker;
    }();
    /**
     * Implements multiple colored cursors in the ace editor.  Each cursor is
     * associated with a particular user. Each user is identified by a unique id
     * and has a color associated with them.  Each cursor has a position in the
     * editor which is specified by a 2-d row and column ({row: 0, column: 10}).
     */ var AceMultiCursorManager = /** @class */ function() {
        /**
         * Constructs a new AceMultiCursorManager that is bound to a particular
         * Ace EditSession instance.
         *
         * @param session
         *   The Ace EditSession to bind to.
         */ function AceMultiCursorManager(session) {
            this._cursors = {};
            this._session = session;
        }
        /**
         * Adds a new collaborative selection.
         *
         * @param id
         *   The unique system identifier for the user associated with this selection.
         * @param label
         *   A human readable / meaningful label / title that identifies the user.
         * @param color
         *   A valid css color string.
         * @param position
         *   A 2-d position or linear index indicating the location of the cursor.
         */ AceMultiCursorManager.prototype.addCursor = function(id, label, color, position) {
            if (this._cursors[id] !== undefined) throw new Error("Cursor with id already defined: " + id);
            var marker = new AceCursorMarker(this._session, id, label, color, position);
            this._cursors[id] = marker;
            this._session.addDynamicMarker(marker, true);
        };
        /**
         * Updates the selection for a particular user.
         *
         * @param id
         *   The unique identifier for the user.
         * @param position
         *   A 2-d position or linear index indicating the location of the cursor.
         */ AceMultiCursorManager.prototype.setCursor = function(id, position) {
            var cursor = this._getCursor(id);
            cursor.setPosition(position);
        };
        /**
         * Clears the cursor (but does not remove it) for the specified user.
         *
         * @param id
         *   The unique identifier for the user.
         */ AceMultiCursorManager.prototype.clearCursor = function(id) {
            var cursor = this._getCursor(id);
            cursor.setPosition(null);
        };
        /**
         * Removes the cursor for the specified user.
         *
         * @param id
         *   The unique identifier for the user.
         */ AceMultiCursorManager.prototype.removeCursor = function(id) {
            var cursor = this._cursors[id];
            if (cursor === undefined) throw new Error("Cursor not found: " + id);
            // Note: ace adds an id field to all added markers.
            this._session.removeMarker(cursor.id);
            delete this._cursors[id];
        };
        /**
         * Removes all cursors.
         */ AceMultiCursorManager.prototype.removeAll = function() {
            var _this = this;
            Object.getOwnPropertyNames(this._cursors).forEach(function(key) {
                _this.removeCursor(_this._cursors[key].cursorId());
            });
        };
        AceMultiCursorManager.prototype._getCursor = function(id) {
            var cursor = this._cursors[id];
            if (cursor === undefined) throw new Error("Cursor not found: " + id);
            return cursor;
        };
        return AceMultiCursorManager;
    }();
    /**
     * A helper class for working with Ace Ranges.
     */ var AceRangeUtil = /** @class */ function() {
        function AceRangeUtil() {}
        AceRangeUtil.rangeToJson = function(range) {
            return {
                start: {
                    row: range.start.row,
                    column: range.start.column
                },
                end: {
                    row: range.end.row,
                    column: range.end.column
                }
            };
        };
        AceRangeUtil.jsonToRange = function(range) {
            return new aceBuilds.Range(range.start.row, range.start.column, range.end.row, range.end.column);
        };
        AceRangeUtil.rangesToJson = function(ranges) {
            return ranges.map(function(range) {
                return AceRangeUtil.rangeToJson(range);
            });
        };
        AceRangeUtil.jsonToRanges = function(ranges) {
            return ranges.map(function(range) {
                return AceRangeUtil.jsonToRange(range);
            });
        };
        AceRangeUtil.toJson = function(value) {
            if (Array.isArray(value)) return AceRangeUtil.rangesToJson(value);
            return AceRangeUtil.rangeToJson(value);
        };
        AceRangeUtil.fromJson = function(value) {
            if (Array.isArray(value)) return AceRangeUtil.jsonToRanges(value);
            return AceRangeUtil.jsonToRange(value);
        };
        return AceRangeUtil;
    }();
    var AceRadarViewIndicator = /** @class */ function() {
        function AceRadarViewIndicator(label, color, viewRows, cursorRow, editor) {
            var _this = this;
            this._label = label;
            this._color = color;
            this._viewRows = viewRows;
            this._cursorRow = cursorRow;
            this._editor = editor;
            this._docLineCount = editor.getSession().getLength();
            this._editorListener = function() {
                var newLineCount = _this._editor.getSession().getLength();
                if (newLineCount !== _this._docLineCount) {
                    _this._docLineCount = newLineCount;
                    _this.update();
                }
            };
            this._editor.on("change", this._editorListener);
            this._scrollElement = document.createElement("div");
            this._scrollElement.className = "ace-radar-view-scroll-indicator";
            this._scrollElement.style.borderColor = this._color;
            this._scrollElement.style.background = this._color;
            // todo implement a custom tooltip for consistent presentation.
            this._scrollElement.title = this._label;
            this._scrollElement.addEventListener("click", function() {
                var middle = (_this._viewRows.end - _this._viewRows.start) / 2 + _this._viewRows.start;
                _this._editor.scrollToLine(middle, true, false, function() {});
            }, false);
            this._cursorElement = document.createElement("div");
            this._cursorElement.className = "ace-radar-view-cursor-indicator";
            this._cursorElement.style.background = this._color;
            this._cursorElement.title = this._label;
            this._cursorElement.addEventListener("click", function() {
                _this._editor.scrollToLine(_this._cursorRow, true, false, function() {});
            }, false);
            this._wrapper = document.createElement("div");
            this._wrapper.className = "ace-radar-view-wrapper";
            this._wrapper.style.display = "none";
            this._wrapper.appendChild(this._scrollElement);
            this._wrapper.appendChild(this._cursorElement);
        }
        AceRadarViewIndicator.prototype.element = function() {
            return this._wrapper;
        };
        AceRadarViewIndicator.prototype.setCursorRow = function(cursorRow) {
            this._cursorRow = cursorRow;
            this.update();
        };
        AceRadarViewIndicator.prototype.setViewRows = function(viewRows) {
            this._viewRows = viewRows;
            this.update();
        };
        AceRadarViewIndicator.prototype.update = function() {
            if (!_isSet(this._viewRows) && !_isSet(this._cursorRow)) this._wrapper.style.display = "none";
            else {
                this._wrapper.style.display = null;
                var maxLine = this._docLineCount - 1;
                if (!_isSet(this._viewRows)) this._scrollElement.style.display = "none";
                else {
                    var topPercent = Math.min(maxLine, this._viewRows.start) / maxLine * 100;
                    var bottomPercent = 100 - Math.min(maxLine, this._viewRows.end) / maxLine * 100;
                    this._scrollElement.style.top = topPercent + "%";
                    this._scrollElement.style.bottom = bottomPercent + "%";
                    this._scrollElement.style.display = null;
                }
                if (!_isSet(this._cursorRow)) this._cursorElement.style.display = "none";
                else {
                    var cursorPercent = Math.min(this._cursorRow, maxLine) / maxLine;
                    var ratio = (this._wrapper.offsetHeight - this._cursorElement.offsetHeight) / this._wrapper.offsetHeight;
                    var cursorTop = cursorPercent * ratio * 100;
                    this._cursorElement.style.top = cursorTop + "%";
                    this._cursorElement.style.display = null;
                }
            }
        };
        AceRadarViewIndicator.prototype.dispose = function() {
            this._wrapper.parentNode.removeChild(this._wrapper);
            this._editor.off("change", this._editorListener);
        };
        return AceRadarViewIndicator;
    }();
    function _isSet(value) {
        return value !== undefined && value !== null;
    }
    /**
     * Implements viewport awareness in the Ace Editor by showing where remote
     * users are scrolled too and where there cursor is in the document, even
     * if the cursor is not in view.
     */ var AceRadarView = /** @class */ function() {
        /**
         * Constructs a new AceRadarView bound to the supplied element and editor.
         *
         * @param element
         *          The HTML Element that the AceRadarView should render to.
         * @param editor
         *          The Ace Editor to listen to events from.
         */ function AceRadarView(element, editor) {
            this._container = null;
            if (typeof element === "string") this._container = document.getElementById(element);
            else this._container = element;
            this._container.style.position = "relative";
            this._views = {};
            this._editor = editor;
        }
        /**
         * Add a view indicator for a new remote user.
         *
         * @param id
         *          The unique id of the user.
         * @param label
         *          A text label to displAce for the user.
         * @param color
         *          The color to render the indicator with.
         * @param viewRows
         *          The rows the user's viewport spans.
         * @param cursorRow
         *          The row that the user's cursor is on.
         */ AceRadarView.prototype.addView = function(id, label, color, viewRows, cursorRow) {
            var indicator = new AceRadarViewIndicator(label, color, viewRows, cursorRow, this._editor);
            this._container.appendChild(indicator.element());
            indicator.update();
            this._views[id] = indicator;
        };
        /**
         * Determines if the AceRadarView has an indicator for this specified user.
         *
         * @param id
         *          The id of the user to check for.
         * @returns
         *   True if the AceRadarView has an indicator for this user, false otherwise.
         */ AceRadarView.prototype.hasView = function(id) {
            return this._views[id] !== undefined;
        };
        /**
         * Sets the view row span for a particular user.
         *
         * @param id
         *          The id of the user to set the rows for.
         * @param rows
         *          The row range to set.
         */ AceRadarView.prototype.setViewRows = function(id, rows) {
            var indicator = this._views[id];
            indicator.setViewRows(rows);
        };
        /**
         * Sets the cursor row for a particular user.
         *
         * @param id
         *          The id of the user to set the cursor row for.
         * @param row
         *          The row to set.
         */ AceRadarView.prototype.setCursorRow = function(id, row) {
            var indicator = this._views[id];
            indicator.setCursorRow(row);
        };
        /**
         * Clears the view for a particular user, causing their indicator to disapear.
         * @param id
         *   The id of the user to clear.
         */ AceRadarView.prototype.clearView = function(id) {
            var indicator = this._views[id];
            indicator.setCursorRow(null);
            indicator.setViewRows(null);
        };
        /**
         * Removes the view indicator for the specified user.
         * @param id
         *   The id of the user to remove the view indicator for.
         */ AceRadarView.prototype.removeView = function(id) {
            var indicator = this._views[id];
            indicator.dispose();
            delete this._views[id];
        };
        return AceRadarView;
    }();
    var AceViewportUtil = /** @class */ function() {
        function AceViewportUtil() {}
        AceViewportUtil.getVisibleIndexRange = function(editor) {
            var firstRow = editor.getFirstVisibleRow();
            var lastRow = editor.getLastVisibleRow();
            if (!editor.isRowFullyVisible(firstRow)) firstRow++;
            if (!editor.isRowFullyVisible(lastRow)) lastRow--;
            var startPos = editor.getSession().getDocument().positionToIndex({
                row: firstRow,
                column: 0
            }, 0);
            // todo, this should probably be the end of the row
            var endPos = editor.getSession().getDocument().positionToIndex({
                row: lastRow,
                column: 0
            }, 0);
            return {
                start: startPos,
                end: endPos
            };
        };
        AceViewportUtil.indicesToRows = function(editor, startIndex, endIndex) {
            var startRow = editor.getSession().getDocument().indexToPosition(startIndex, 0).row;
            var endRow = editor.getSession().getDocument().indexToPosition(endIndex, 0).row;
            return {
                start: startRow,
                end: endRow
            };
        };
        return AceViewportUtil;
    }();
    exports1.AceMultiCursorManager = AceMultiCursorManager;
    exports1.AceMultiSelectionManager = AceMultiSelectionManager;
    exports1.AceRadarView = AceRadarView;
    exports1.AceRangeUtil = AceRangeUtil;
    exports1.AceViewportUtil = AceViewportUtil;
    Object.defineProperty(exports1, "__esModule", {
        value: true
    });
});

},{"21d851e32bab3278":"lnKN4"}],"lnKN4":[function(require,module,exports) {
/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2010, Ajax.org B.V.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Ajax.org B.V. nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL AJAX.ORG B.V. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * ***** END LICENSE BLOCK ***** */ /**
 * Define a module along with a payload
 * @param module a name for the payload
 * @param payload a function to call with (require, exports, module) params
 */ (function() {
    var ACE_NAMESPACE = "ace";
    var global = function() {
        return this;
    }();
    if (!global && typeof window != "undefined") global = window; // strict mode
    if (!ACE_NAMESPACE && typeof requirejs !== "undefined") return;
    var define1 = function(module1, deps, payload) {
        if (typeof module1 !== "string") {
            if (define1.original) define1.original.apply(this, arguments);
            else {
                console.error("dropping module because define wasn't a string.");
                console.trace();
            }
            return;
        }
        if (arguments.length == 2) payload = deps;
        if (!define1.modules[module1]) {
            define1.payloads[module1] = payload;
            define1.modules[module1] = null;
        }
    };
    define1.modules = {};
    define1.payloads = {};
    /**
 * Get at functionality define()ed using the function above
 */ var _require = function(parentId, module1, callback) {
        if (typeof module1 === "string") {
            var payload = lookup(parentId, module1);
            if (payload != undefined) {
                callback && callback();
                return payload;
            }
        } else if (Object.prototype.toString.call(module1) === "[object Array]") {
            var params = [];
            for(var i = 0, l = module1.length; i < l; ++i){
                var dep = lookup(parentId, module1[i]);
                if (dep == undefined && require.original) return;
                params.push(dep);
            }
            return callback && callback.apply(null, params) || true;
        }
    };
    var require = function(module1, callback) {
        var packagedModule = _require("", module1, callback);
        if (packagedModule == undefined && require.original) return require.original.apply(this, arguments);
        return packagedModule;
    };
    var normalizeModule = function(parentId, moduleName) {
        // normalize plugin requires
        if (moduleName.indexOf("!") !== -1) {
            var chunks = moduleName.split("!");
            return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        // normalize relative requires
        if (moduleName.charAt(0) == ".") {
            var base = parentId.split("/").slice(0, -1).join("/");
            moduleName = base + "/" + moduleName;
            while(moduleName.indexOf(".") !== -1 && previous != moduleName){
                var previous = moduleName;
                moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
            }
        }
        return moduleName;
    };
    /**
 * Internal function to lookup moduleNames and resolve them by calling the
 * definition function if needed.
 */ var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module1 = define1.modules[moduleName];
        if (!module1) {
            module1 = define1.payloads[moduleName];
            if (typeof module1 === "function") {
                var exports = {};
                var mod = {
                    id: moduleName,
                    uri: "",
                    exports: exports,
                    packaged: true
                };
                var req = function(module1, callback) {
                    return _require(moduleName, module1, callback);
                };
                var returnValue = module1(req, exports, mod);
                exports = returnValue || mod.exports;
                define1.modules[moduleName] = exports;
                delete define1.payloads[moduleName];
            }
            module1 = define1.modules[moduleName] = exports || module1;
        }
        return module1;
    };
    function exportAce(ns) {
        var root = global;
        if (ns) {
            if (!global[ns]) global[ns] = {};
            root = global[ns];
        }
        if (!root.define || !root.define.packaged) {
            define1.original = root.define;
            root.define = define1;
            root.define.packaged = true;
        }
        if (!root.require || !root.require.packaged) {
            require.original = root.require;
            root.require = require;
            root.require.packaged = true;
        }
    }
    exportAce(ACE_NAMESPACE);
})();
ace.define("ace/lib/es6-shim", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
            value: val,
            enumerable: false,
            writable: true,
            configurable: true
        });
    }
    if (!String.prototype.startsWith) defineProp(String.prototype, "startsWith", function(searchString, position) {
        position = position || 0;
        return this.lastIndexOf(searchString, position) === position;
    });
    if (!String.prototype.endsWith) defineProp(String.prototype, "endsWith", function(searchString, position) {
        var subjectString = this;
        if (position === undefined || position > subjectString.length) position = subjectString.length;
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    });
    if (!String.prototype.repeat) defineProp(String.prototype, "repeat", function(count) {
        var result = "";
        var string = this;
        while(count > 0){
            if (count & 1) result += string;
            if (count >>= 1) string += string;
        }
        return result;
    });
    if (!String.prototype.includes) defineProp(String.prototype, "includes", function(str, position) {
        return this.indexOf(str, position) != -1;
    });
    if (!Object.assign) Object.assign = function(target) {
        if (target === undefined || target === null) throw new TypeError("Cannot convert undefined or null to object");
        var output = Object(target);
        for(var index = 1; index < arguments.length; index++){
            var source = arguments[index];
            if (source !== undefined && source !== null) Object.keys(source).forEach(function(key) {
                output[key] = source[key];
            });
        }
        return output;
    };
    if (!Object.values) Object.values = function(o) {
        return Object.keys(o).map(function(k) {
            return o[k];
        });
    };
    if (!Array.prototype.find) defineProp(Array.prototype, "find", function(predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for(var k = 0; k < len; k++){
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) return kValue;
        }
    });
    if (!Array.prototype.findIndex) defineProp(Array.prototype, "findIndex", function(predicate) {
        var len = this.length;
        var thisArg = arguments[1];
        for(var k = 0; k < len; k++){
            var kValue = this[k];
            if (predicate.call(thisArg, kValue, k, this)) return k;
        }
    });
    if (!Array.prototype.includes) defineProp(Array.prototype, "includes", function(item, position) {
        return this.indexOf(item, position) != -1;
    });
    if (!Array.prototype.fill) defineProp(Array.prototype, "fill", function(value) {
        var O = this;
        var len = O.length >>> 0;
        var start = arguments[1];
        var relativeStart = start >> 0;
        var k = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
        var end = arguments[2];
        var relativeEnd = end === undefined ? len : end >> 0;
        var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
        while(k < final){
            O[k] = value;
            k++;
        }
        return O;
    });
    if (!Array.of) defineProp(Array, "of", function() {
        return Array.prototype.slice.call(arguments);
    });
});
ace.define("ace/lib/fixoldbrowsers", [
    "require",
    "exports",
    "module",
    "ace/lib/es6-shim"
], function(require, exports, module1) {
    "use strict";
    require("./es6-shim");
});
ace.define("ace/lib/deep_copy", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    exports.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj) return obj;
        var copy;
        if (Array.isArray(obj)) {
            copy = [];
            for(var key = 0; key < obj.length; key++)copy[key] = deepCopy(obj[key]);
            return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]") return obj;
        copy = {};
        for(var key in obj)copy[key] = deepCopy(obj[key]);
        return copy;
    };
});
ace.define("ace/lib/lang", [
    "require",
    "exports",
    "module",
    "ace/lib/deep_copy"
], function(require, exports, module1) {
    "use strict";
    exports.last = function(a) {
        return a[a.length - 1];
    };
    exports.stringReverse = function(string) {
        return string.split("").reverse().join("");
    };
    exports.stringRepeat = function(string, count) {
        var result = "";
        while(count > 0){
            if (count & 1) result += string;
            if (count >>= 1) string += string;
        }
        return result;
    };
    var trimBeginRegexp = /^\s\s*/;
    var trimEndRegexp = /\s\s*$/;
    exports.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
    };
    exports.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
    };
    exports.copyObject = function(obj) {
        var copy = {};
        for(var key in obj)copy[key] = obj[key];
        return copy;
    };
    exports.copyArray = function(array) {
        var copy = [];
        for(var i = 0, l = array.length; i < l; i++)if (array[i] && typeof array[i] == "object") copy[i] = this.copyObject(array[i]);
        else copy[i] = array[i];
        return copy;
    };
    exports.deepCopy = require("./deep_copy").deepCopy;
    exports.arrayToMap = function(arr) {
        var map = {};
        for(var i = 0; i < arr.length; i++)map[arr[i]] = 1;
        return map;
    };
    exports.createMap = function(props) {
        var map = Object.create(null);
        for(var i in props)map[i] = props[i];
        return map;
    };
    exports.arrayRemove = function(array, value) {
        for(var i = 0; i <= array.length; i++)if (value === array[i]) array.splice(i, 1);
    };
    exports.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
    };
    exports.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    };
    exports.getMatchOffsets = function(string, regExp) {
        var matches = [];
        string.replace(regExp, function(str) {
            matches.push({
                offset: arguments[arguments.length - 2],
                length: str.length
            });
        });
        return matches;
    };
    exports.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };
        var deferred = function(timeout) {
            deferred.cancel();
            timer = setTimeout(callback, timeout || 0);
            return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
            this.cancel();
            fcn();
            return deferred;
        };
        deferred.cancel = function() {
            clearTimeout(timer);
            timer = null;
            return deferred;
        };
        deferred.isPending = function() {
            return timer;
        };
        return deferred;
    };
    exports.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
            timer = null;
            fcn();
        };
        var _self = function(timeout) {
            if (timer == null) timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
            timer && clearTimeout(timer);
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
            this.cancel();
            fcn();
        };
        _self.cancel = function() {
            timer && clearTimeout(timer);
            timer = null;
        };
        _self.isPending = function() {
            return timer;
        };
        return _self;
    };
    exports.supportsLookbehind = function() {
        try {
            new RegExp("(?<=.)");
        } catch (e) {
            return false;
        }
        return true;
    };
    exports.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
        return supportsUnicodeFlag && line.codePointAt(last) > 0xffff ? 2 : 1;
    };
});
ace.define("ace/lib/useragent", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    exports.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
    };
    exports.getOS = function() {
        if (exports.isMac) return exports.OS.MAC;
        else if (exports.isLinux) return exports.OS.LINUX;
        else return exports.OS.WINDOWS;
    };
    var _navigator = typeof navigator == "object" ? navigator : {};
    var os = (/mac|win|linux/i.exec(_navigator.platform) || [
        "other"
    ])[0].toLowerCase();
    var ua = _navigator.userAgent || "";
    var appName = _navigator.appName || "";
    exports.isWin = os == "win";
    exports.isMac = os == "mac";
    exports.isLinux = os == "linux";
    exports.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]); // for ie
    exports.isOldIE = exports.isIE && exports.isIE < 9;
    exports.isGecko = exports.isMozilla = ua.match(/ Gecko\/\d+/);
    exports.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
    exports.isWebKit = parseFloat(ua.split("WebKit/")[1]) || undefined;
    exports.isChrome = parseFloat(ua.split(" Chrome/")[1]) || undefined;
    exports.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports.isChrome || undefined;
    exports.isEdge = parseFloat(ua.split(" Edge/")[1]) || undefined;
    exports.isAIR = ua.indexOf("AdobeAIR") >= 0;
    exports.isAndroid = ua.indexOf("Android") >= 0;
    exports.isChromeOS = ua.indexOf(" CrOS ") >= 0;
    exports.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
    if (exports.isIOS) exports.isMac = true;
    exports.isMobile = exports.isIOS || exports.isAndroid;
});
ace.define("ace/lib/dom", [
    "require",
    "exports",
    "module",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var useragent = require("./useragent");
    var XHTML_NS = "http://www.w3.org/1999/xhtml";
    exports.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
            var txt = document.createTextNode(arr);
            if (parent) parent.appendChild(txt);
            return txt;
        }
        if (!Array.isArray(arr)) {
            if (arr && arr.appendChild && parent) parent.appendChild(arr);
            return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
            var els = [];
            for(var i = 0; i < arr.length; i++){
                var ch = buildDom(arr[i], parent, refs);
                ch && els.push(ch);
            }
            return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options)) childIndex = 2;
        for(var i = childIndex; i < arr.length; i++)buildDom(arr[i], el, refs);
        if (childIndex == 2) Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") el.className = Array.isArray(val) ? val.join(" ") : val;
            else if (typeof val == "function" || n == "value" || n[0] == "$") el[n] = val;
            else if (n === "ref") {
                if (refs) refs[val] = el;
            } else if (n === "style") {
                if (typeof val == "string") el.style.cssText = val;
            } else if (val != null) el.setAttribute(n, val);
        });
        if (parent) parent.appendChild(el);
        return el;
    };
    exports.getDocumentHead = function(doc) {
        if (!doc) doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
    };
    exports.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
    };
    exports.removeChildren = function(element) {
        element.innerHTML = "";
    };
    exports.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
    };
    exports.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
    };
    exports.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
    };
    exports.addCssClass = function(el, name) {
        if (!exports.hasCssClass(el, name)) el.className += " " + name;
    };
    exports.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while(true){
            var index = classes.indexOf(name);
            if (index == -1) break;
            classes.splice(index, 1);
        }
        el.className = classes.join(" ");
    };
    exports.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while(true){
            var index = classes.indexOf(name);
            if (index == -1) break;
            add = false;
            classes.splice(index, 1);
        }
        if (add) classes.push(name);
        el.className = classes.join(" ");
        return add;
    };
    exports.setCssClass = function(node, className, include) {
        if (include) exports.addCssClass(node, className);
        else exports.removeCssClass(node, className);
    };
    exports.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if (sheets = doc.querySelectorAll("style")) while(index < sheets.length){
            if (sheets[index++].id === id) return true;
        }
    };
    exports.removeElementById = function(id, doc) {
        doc = doc || document;
        if (doc.getElementById(id)) doc.getElementById(id).remove();
    };
    var strictCSP;
    var cssCache = [];
    exports.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false) insertPendingStyles();
        else if (!cssCache) cssCache = [];
    };
    function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item) {
            importCssString(item[0], item[1]);
        });
    }
    function importCssString(cssText, id, target) {
        if (typeof document == "undefined") return;
        if (cssCache) {
            if (target) insertPendingStyles();
            else if (target === false) return cssCache.push([
                cssText,
                id
            ]);
        }
        if (strictCSP) return;
        var container = target;
        if (!target || !target.getRootNode) container = document;
        else {
            container = target.getRootNode();
            if (!container || container == target) container = document;
        }
        var doc = container.ownerDocument || container;
        if (id && exports.hasCssString(id, container)) return null;
        if (id) cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id) style.id = id;
        if (container == doc) container = exports.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
    }
    exports.importCssString = importCssString;
    exports.importCssStylsheet = function(uri, doc) {
        exports.buildDom([
            "link",
            {
                rel: "stylesheet",
                href: uri
            }
        ], exports.getDocumentHead(doc));
    };
    exports.scrollbarWidth = function(doc) {
        var inner = exports.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc && doc.documentElement || document && document.documentElement;
        if (!body) return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) withScrollbar = outer.clientWidth;
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
    };
    exports.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
    };
    exports.setStyle = function(styles, property, value) {
        if (styles[property] !== value) styles[property] = value;
    };
    exports.HAS_CSS_ANIMATION = false;
    exports.HAS_CSS_TRANSFORMS = false;
    exports.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
    if (useragent.isChromeOS) exports.HI_DPI = false;
    if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports.HI_DPI && div.style.transform !== undefined) exports.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined") exports.HAS_CSS_ANIMATION = true;
        div = null;
    }
    if (exports.HAS_CSS_TRANSFORMS) exports.translate = function(element, tx, ty) {
        element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
    };
    else exports.translate = function(element, tx, ty) {
        element.style.top = Math.round(ty) + "px";
        element.style.left = Math.round(tx) + "px";
    };
});
ace.define("ace/lib/net", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var dom = require("./dom");
    exports.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) callback(xhr.responseText);
        };
        xhr.send(null);
    };
    exports.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s = document.createElement("script");
        s.src = path;
        head.appendChild(s);
        s.onload = s.onreadystatechange = function(_, isAbort) {
            if (isAbort || !s.readyState || s.readyState == "loaded" || s.readyState == "complete") {
                s = s.onload = s.onreadystatechange = null;
                if (!isAbort) callback();
            }
        };
    };
    exports.qualifyURL = function(url) {
        var a = document.createElement("a");
        a.href = url;
        return a.href;
    };
});
ace.define("ace/lib/oop", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    exports.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
    };
    exports.mixin = function(obj, mixin) {
        for(var key in mixin)obj[key] = mixin[key];
        return obj;
    };
    exports.implement = function(proto, mixin) {
        exports.mixin(proto, mixin);
    };
});
ace.define("ace/lib/event_emitter", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var EventEmitter = {};
    var stopPropagation = function() {
        this.propagationStopped = true;
    };
    var preventDefault = function() {
        this.defaultPrevented = true;
    };
    EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler) return;
        if (typeof e != "object" || !e) e = {};
        if (!e.type) e.type = eventName;
        if (!e.stopPropagation) e.stopPropagation = stopPropagation;
        if (!e.preventDefault) e.preventDefault = preventDefault;
        listeners = listeners.slice();
        for(var i = 0; i < listeners.length; i++){
            listeners[i](e, this);
            if (e.propagationStopped) break;
        }
        if (defaultHandler && !e.defaultPrevented) return defaultHandler(e, this);
    };
    EventEmitter._signal = function(eventName, e) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners) return;
        listeners = listeners.slice();
        for(var i = 0; i < listeners.length; i++)listeners[i](e, this);
    };
    EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
            _self.off(eventName, newCallback);
            callback.apply(null, arguments);
        });
        if (!callback) return new Promise(function(resolve) {
            callback = resolve;
        });
    };
    EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) handlers = this._defaultHandlers = {
            _disabled_: {}
        };
        if (handlers[eventName]) {
            var old = handlers[eventName];
            var disabled = handlers._disabled_[eventName];
            if (!disabled) handlers._disabled_[eventName] = disabled = [];
            disabled.push(old);
            var i = disabled.indexOf(callback);
            if (i != -1) disabled.splice(i, 1);
        }
        handlers[eventName] = callback;
    };
    EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers) return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
            if (disabled) this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
            var i = disabled.indexOf(callback);
            if (i != -1) disabled.splice(i, 1);
        }
    };
    EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners) listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1) listeners[capturing ? "unshift" : "push"](callback);
        return callback;
    };
    EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners) return;
        var index = listeners.indexOf(callback);
        if (index !== -1) listeners.splice(index, 1);
    };
    EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName) this._eventRegistry = this._defaultHandlers = undefined;
        if (this._eventRegistry) this._eventRegistry[eventName] = undefined;
        if (this._defaultHandlers) this._defaultHandlers[eventName] = undefined;
    };
    exports.EventEmitter = EventEmitter;
});
ace.define("ace/lib/report_error", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    exports.reportError = function reportError(msg, data) {
        var e = new Error(msg);
        e["data"] = data;
        if (typeof console == "object" && console.error) console.error(e);
        setTimeout(function() {
            throw e;
        });
    };
});
ace.define("ace/lib/default_english_messages", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    var defaultEnglishMessages = {
        "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
        "autocomplete.popup.aria-label": "Autocomplete suggestions",
        "autocomplete.popup.item.aria-roledescription": "item",
        "autocomplete.loading": "Loading...",
        "editor.scroller.aria-roledescription": "editor",
        "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
        "editor.gutter.aria-roledescription": "editor gutter",
        "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
        "error-marker.good-state": "Looks good!",
        "prompt.recently-used": "Recently used",
        "prompt.other-commands": "Other commands",
        "prompt.no-matching-commands": "No matching commands",
        "search-box.find.placeholder": "Search for",
        "search-box.find-all.text": "All",
        "search-box.replace.placeholder": "Replace with",
        "search-box.replace-next.text": "Replace",
        "search-box.replace-all.text": "All",
        "search-box.toggle-replace.title": "Toggle Replace mode",
        "search-box.toggle-regexp.title": "RegExp Search",
        "search-box.toggle-case.title": "CaseSensitive Search",
        "search-box.toggle-whole-word.title": "Whole Word Search",
        "search-box.toggle-in-selection.title": "Search In Selection",
        "search-box.search-counter": "$0 of $1",
        "text-input.aria-roledescription": "editor",
        "text-input.aria-label": "Cursor at row $0",
        "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
        "gutter.code-folding.closed.title": "Unfold code",
        "gutter.code-folding.open.title": "Fold code",
        "gutter.annotation.aria-label.error": "Error, read annotations row $0",
        "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
        "gutter.annotation.aria-label.info": "Info, read annotations row $0",
        "inline-fold.closed.title": "Unfold code",
        "gutter-tooltip.aria-label.error.singular": "error",
        "gutter-tooltip.aria-label.error.plural": "errors",
        "gutter-tooltip.aria-label.warning.singular": "warning",
        "gutter-tooltip.aria-label.warning.plural": "warnings",
        "gutter-tooltip.aria-label.info.singular": "information message",
        "gutter-tooltip.aria-label.info.plural": "information messages",
        "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
        "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
        "gutter-tooltip.aria-label.security.singular": "security finding",
        "gutter-tooltip.aria-label.security.plural": "security findings",
        "gutter-tooltip.aria-label.hint.singular": "suggestion",
        "gutter-tooltip.aria-label.hint.plural": "suggestions",
        "editor.tooltip.disable-editing": "Editing is disabled"
    };
    exports.defaultEnglishMessages = defaultEnglishMessages;
});
ace.define("ace/lib/app_config", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter",
    "ace/lib/report_error",
    "ace/lib/default_english_messages"
], function(require, exports, module1) {
    "no use strict";
    var oop = require("./oop");
    var EventEmitter = require("./event_emitter").EventEmitter;
    var reportError = require("./report_error").reportError;
    var defaultEnglishMessages = require("./default_english_messages").defaultEnglishMessages;
    var optionsProvider = {
        setOptions: function(optList) {
            Object.keys(optList).forEach(function(key) {
                this.setOption(key, optList[key]);
            }, this);
        },
        getOptions: function(optionNames) {
            var result = {};
            if (!optionNames) {
                var options = this.$options;
                optionNames = Object.keys(options).filter(function(key) {
                    return !options[key].hidden;
                });
            } else if (!Array.isArray(optionNames)) optionNames = Object.keys(optionNames);
            optionNames.forEach(function(key) {
                result[key] = this.getOption(key);
            }, this);
            return result;
        },
        setOption: function(name, value) {
            if (this["$" + name] === value) return;
            var opt = this.$options[name];
            if (!opt) return warn('misspelled option "' + name + '"');
            if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
            if (!opt.handlesSet) this["$" + name] = value;
            if (opt && opt.set) opt.set.call(this, value);
        },
        getOption: function(name) {
            var opt = this.$options[name];
            if (!opt) return warn('misspelled option "' + name + '"');
            if (opt.forwardTo) return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
            return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
    };
    function warn(message) {
        if (typeof console != "undefined" && console.warn) console.warn.apply(console, arguments);
    }
    var messages;
    var nlsPlaceholders;
    var AppConfig = /** @class */ function() {
        function AppConfig() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
        }
        AppConfig.prototype.defineOptions = function(obj, path, options) {
            if (!obj.$options) this.$defaultOptions[path] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
                var opt = options[key];
                if (typeof opt == "string") opt = {
                    forwardTo: opt
                };
                opt.name || (opt.name = key);
                obj.$options[opt.name] = opt;
                if ("initialValue" in opt) obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
        };
        AppConfig.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
                var opt = obj.$options[key];
                if ("value" in opt) obj.setOption(key, opt.value);
            });
        };
        AppConfig.prototype.setDefaultValue = function(path, name, value) {
            if (!path) {
                for(path in this.$defaultOptions)if (this.$defaultOptions[path][name]) break;
                if (!this.$defaultOptions[path][name]) return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
                if (opts.forwardTo) this.setDefaultValue(opts.forwardTo, name, value);
                else opts[name].value = value;
            }
        };
        AppConfig.prototype.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
                this.setDefaultValue(path, key, optionHash[key]);
            }, this);
        };
        AppConfig.prototype.setMessages = function(value, options) {
            messages = value;
            if (options && options.placeholders) nlsPlaceholders = options.placeholders;
        };
        AppConfig.prototype.nls = function(key, defaultString, params) {
            if (!messages[key]) {
                warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
                if (!messages[defaultString]) warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
            }
            var translated = messages[key] || messages[defaultString] || defaultString;
            if (params) {
                if (nlsPlaceholders === "dollarSigns") translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                    if (dollarMatch == "$") return "$";
                    return params[dollarMatch];
                });
                if (nlsPlaceholders === "curlyBrackets") translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                    return params[curlyBracketMatch];
                });
            }
            return translated;
        };
        return AppConfig;
    }();
    AppConfig.prototype.warn = warn;
    AppConfig.prototype.reportError = reportError;
    oop.implement(AppConfig.prototype, EventEmitter);
    exports.AppConfig = AppConfig;
});
ace.define("ace/theme/textmate-css", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    module1.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
});
ace.define("ace/theme/textmate", [
    "require",
    "exports",
    "module",
    "ace/theme/textmate-css",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    exports.isDark = false;
    exports.cssClass = "ace-tm";
    exports.cssText = require("./textmate-css");
    exports.$id = "ace/theme/textmate";
    var dom = require("../lib/dom");
    dom.importCssString(exports.cssText, exports.cssClass, false);
});
ace.define("ace/config", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/lib/net",
    "ace/lib/dom",
    "ace/lib/app_config",
    "ace/theme/textmate"
], function(require, exports, module1) {
    "no use strict";
    var lang = require("./lib/lang");
    var net = require("./lib/net");
    var dom = require("./lib/dom");
    var AppConfig = require("./lib/app_config").AppConfig;
    module1.exports = exports = new AppConfig();
    var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
    };
    exports.get = function(key) {
        if (!options.hasOwnProperty(key)) throw new Error("Unknown config key: " + key);
        return options[key];
    };
    exports.set = function(key, value) {
        if (options.hasOwnProperty(key)) options[key] = value;
        else if (this.setDefaultValue("", key, value) == false) throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP") dom.useStrictCSP(value);
    };
    exports.all = function() {
        return lang.copyObject(options);
    };
    exports.$modes = {};
    exports.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name]) return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
            var re = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
            base = base.replace(re, "");
        }
        if ((!base || base == component) && parts.length > 1) base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) path = options.basePath;
        else if (sep == "/") component = sep = "";
        if (path && path.slice(-1) != "/") path += "/";
        return path + component + sep + base + this.get("suffix");
    };
    exports.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
    };
    var loader = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate") return cb(null, require("./theme/textmate"));
        if (customLoader) return customLoader(moduleName, cb);
        console.error("loader is not configured");
    };
    var customLoader;
    exports.setLoader = function(cb) {
        customLoader = cb;
    };
    exports.dynamicModules = Object.create(null);
    exports.$loading = {};
    exports.$loaded = {};
    exports.loadModule = function(moduleId, onLoad) {
        var loadedModule;
        if (Array.isArray(moduleId)) {
            var moduleType = moduleId[0];
            var moduleName = moduleId[1];
        } else if (typeof moduleId == "string") var moduleName = moduleId;
        var load = function(module1) {
            if (module1 && !exports.$loading[moduleName]) return onLoad && onLoad(module1);
            if (!exports.$loading[moduleName]) exports.$loading[moduleName] = [];
            exports.$loading[moduleName].push(onLoad);
            if (exports.$loading[moduleName].length > 1) return;
            var afterLoad = function() {
                loader(moduleName, function(err, module1) {
                    if (module1) exports.$loaded[moduleName] = module1;
                    exports._emit("load.module", {
                        name: moduleName,
                        module: module1
                    });
                    var listeners = exports.$loading[moduleName];
                    exports.$loading[moduleName] = null;
                    listeners.forEach(function(onLoad) {
                        onLoad && onLoad(module1);
                    });
                });
            };
            if (!exports.get("packaged")) return afterLoad();
            net.loadScript(exports.moduleUrl(moduleName, moduleType), afterLoad);
            reportErrorIfPathIsNotConfigured();
        };
        if (exports.dynamicModules[moduleName]) exports.dynamicModules[moduleName]().then(function(module1) {
            if (module1.default) load(module1.default);
            else load(module1);
        });
        else {
            try {
                loadedModule = this.$require(moduleName);
            } catch (e) {}
            load(loadedModule || exports.$loaded[moduleName]);
        }
    };
    exports.$require = function(moduleName) {
        if (typeof module1["require"] == "function") {
            var req = "require";
            return module1[req](moduleName);
        }
    };
    exports.setModuleLoader = function(moduleName, onLoad) {
        exports.dynamicModules[moduleName] = onLoad;
    };
    var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
            console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
            reportErrorIfPathIsNotConfigured = function() {};
        }
    };
    exports.version = "1.42.0";
});
ace.define("ace/loader_build", [
    "require",
    "exports",
    "module",
    "ace/lib/fixoldbrowsers",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    require("./lib/fixoldbrowsers");
    var config = require("./config");
    config.setLoader(function(moduleName, cb) {
        require([
            moduleName
        ], function(module1) {
            cb(null, module1);
        });
    });
    var global = function() {
        return this || typeof window != "undefined" && window;
    }();
    module1.exports = function(ace1) {
        config.init = init;
        config.$require = require;
        ace1.require = require;
        if (typeof define === "function") ace1.define = define;
    };
    init(true);
    function init(packaged) {
        if (!global || !global.document) return;
        config.set("packaged", packaged || require.packaged || module1.packaged || global.define && define.packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript; // native or polyfill
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        if (currentScript && currentScript.src) scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        var scripts = currentDocument.getElementsByTagName("script");
        for(var i = 0; i < scripts.length; i++){
            var script = scripts[i];
            var src = script.src || script.getAttribute("src");
            if (!src) continue;
            var attributes = script.attributes;
            for(var j = 0, l = attributes.length; j < l; j++){
                var attr = attributes[j];
                if (attr.name.indexOf("data-ace-") === 0) scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
            var m = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
            if (m) scriptUrl = m[1];
        }
        if (scriptUrl) {
            scriptOptions.base = scriptOptions.base || scriptUrl;
            scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for(var key in scriptOptions)if (typeof scriptOptions[key] !== "undefined") config.set(key, scriptOptions[key]);
    }
    function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m, m1) {
            return m1.toUpperCase();
        });
    }
});
ace.define("ace/range", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var Range = /** @class */ function() {
        function Range(startRow, startColumn, endRow, endColumn) {
            this.start = {
                row: startRow,
                column: startColumn
            };
            this.end = {
                row: endRow,
                column: endColumn
            };
        }
        Range.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
        };
        Range.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        };
        Range.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
        };
        Range.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
                cmp = this.compare(start.row, start.column);
                if (cmp == 1) return 2;
                else if (cmp == 0) return 1;
                else return 0;
            } else if (cmp == -1) return -2;
            else {
                cmp = this.compare(start.row, start.column);
                if (cmp == -1) return -1;
                else if (cmp == 1) return 42;
                else return 0;
            }
        };
        Range.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
        };
        Range.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
        };
        Range.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
        };
        Range.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
        };
        Range.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
        };
        Range.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
                this.start.column = row.column;
                this.start.row = row.row;
            } else {
                this.start.row = row;
                this.start.column = column;
            }
        };
        Range.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
                this.end.column = row.column;
                this.end.row = row.row;
            } else {
                this.end.row = row;
                this.end.column = column;
            }
        };
        Range.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column) || this.isStart(row, column)) return false;
                else return true;
            }
            return false;
        };
        Range.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isEnd(row, column)) return false;
                else return true;
            }
            return false;
        };
        Range.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
                if (this.isStart(row, column)) return false;
                else return true;
            }
            return false;
        };
        Range.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
                if (row === this.start.row) return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
            }
            if (row < this.start.row) return -1;
            if (row > this.end.row) return 1;
            if (this.start.row === row) return column >= this.start.column ? 0 : -1;
            if (this.end.row === row) return column <= this.end.column ? 0 : 1;
            return 0;
        };
        Range.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) return -1;
            else return this.compare(row, column);
        };
        Range.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) return 1;
            else return this.compare(row, column);
        };
        Range.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) return 1;
            else if (this.start.row == row && this.start.column == column) return -1;
            else return this.compare(row, column);
        };
        Range.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow) var end = {
                row: lastRow + 1,
                column: 0
            };
            else if (this.end.row < firstRow) var end = {
                row: firstRow,
                column: 0
            };
            if (this.start.row > lastRow) var start = {
                row: lastRow + 1,
                column: 0
            };
            else if (this.start.row < firstRow) var start = {
                row: firstRow,
                column: 0
            };
            return Range.fromPoints(start || this.start, end || this.end);
        };
        Range.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0) return this;
            else if (cmp == -1) var start = {
                row: row,
                column: column
            };
            else var end = {
                row: row,
                column: column
            };
            return Range.fromPoints(start || this.start, end || this.end);
        };
        Range.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
        };
        Range.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
        };
        Range.prototype.clone = function() {
            return Range.fromPoints(this.start, this.end);
        };
        Range.prototype.collapseRows = function() {
            if (this.end.column == 0) return new Range(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else return new Range(this.start.row, 0, this.end.row, 0);
        };
        Range.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
        };
        Range.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
        };
        return Range;
    }();
    Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
    };
    Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
    };
    exports.Range = Range;
});
ace.define("ace/lib/keys", [
    "require",
    "exports",
    "module",
    "ace/lib/oop"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./oop");
    var Keys = {
        MODIFIER_KEYS: {
            16: "Shift",
            17: "Ctrl",
            18: "Alt",
            224: "Meta",
            91: "MetaLeft",
            92: "MetaRight",
            93: "ContextMenu"
        },
        KEY_MODS: {
            "ctrl": 1,
            "alt": 2,
            "option": 2,
            "shift": 4,
            "super": 8,
            "meta": 8,
            "command": 8,
            "cmd": 8,
            "control": 1
        },
        FUNCTION_KEYS: {
            8: "Backspace",
            9: "Tab",
            13: "Return",
            19: "Pause",
            27: "Esc",
            32: "Space",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "Left",
            38: "Up",
            39: "Right",
            40: "Down",
            44: "Print",
            45: "Insert",
            46: "Delete",
            "-13": "NumpadEnter",
            144: "Numlock",
            145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
            32: " ",
            59: ";",
            61: "=",
            107: "+",
            109: "-",
            110: ".",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            111: "/",
            106: "*"
        }
    };
    var codeToKeyCode = {
        Command: 224,
        Backspace: 8,
        Tab: 9,
        Return: 13,
        Enter: 13,
        Pause: 19,
        Escape: 27,
        PageUp: 33,
        PageDown: 34,
        End: 35,
        Home: 36,
        Insert: 45,
        Delete: 46,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Backquote: 192,
        Minus: 189,
        Equal: 187,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Semicolon: 186,
        Quote: 222,
        Comma: 188,
        Period: 190,
        Slash: 191,
        Space: 32,
        NumpadAdd: 107,
        NumpadDecimal: 110,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        NumpadMultiply: 106
    };
    for(var i = 0; i < 10; i++){
        codeToKeyCode["Digit" + i] = 48 + i;
        codeToKeyCode["Numpad" + i] = 96 + i;
        Keys.PRINTABLE_KEYS[48 + i] = "" + i;
        Keys.FUNCTION_KEYS[96 + i] = "Numpad" + i;
    }
    for(var i = 65; i < 91; i++){
        var chr = String.fromCharCode(i + 32);
        codeToKeyCode["Key" + chr.toUpperCase()] = i;
        Keys.PRINTABLE_KEYS[i] = chr;
    }
    for(var i = 1; i < 13; i++){
        codeToKeyCode["F" + i] = 111 + i;
        Keys.FUNCTION_KEYS[111 + i] = "F" + i;
    }
    var modifiers = {
        Shift: 16,
        Control: 17,
        Alt: 18,
        Meta: 224
    };
    for(var mod in modifiers)codeToKeyCode[mod] = codeToKeyCode[mod + "Left"] = codeToKeyCode[mod + "Right"] = modifiers[mod];
    exports.$codeToKeyCode = codeToKeyCode;
    Keys.PRINTABLE_KEYS[173] = "-";
    for(var j in Keys.FUNCTION_KEYS){
        var name = Keys.FUNCTION_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
    }
    for(var j in Keys.PRINTABLE_KEYS){
        var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
    }
    oop.mixin(Keys, Keys.MODIFIER_KEYS);
    oop.mixin(Keys, Keys.PRINTABLE_KEYS);
    oop.mixin(Keys, Keys.FUNCTION_KEYS);
    Keys.enter = Keys["return"];
    Keys.escape = Keys.esc;
    Keys.del = Keys["delete"];
    (function() {
        var mods = [
            "cmd",
            "ctrl",
            "alt",
            "shift"
        ];
        for(var i = Math.pow(2, mods.length); i--;)Keys.KEY_MODS[i] = mods.filter(function(x) {
            return i & Keys.KEY_MODS[x];
        }).join("-") + "-";
    })();
    Keys.KEY_MODS[0] = "";
    Keys.KEY_MODS[-1] = "input-";
    oop.mixin(exports, Keys);
    exports.default = exports;
    exports.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string") keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
    };
});
ace.define("ace/lib/event", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var keys = require("./keys");
    var useragent = require("./useragent");
    var pressedKeys = null;
    var ts = 0;
    var activeListenerOptions;
    function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
            document.createComment("").addEventListener("test", function() {}, {
                get passive () {
                    activeListenerOptions = {
                        passive: false
                    };
                    return true;
                }
            });
        } catch (e) {}
    }
    function getListenerOptions() {
        if (activeListenerOptions == undefined) detectListenerOptionsSupport();
        return activeListenerOptions;
    }
    function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
    }
    EventListener.prototype.destroy = function() {
        removeListener(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = undefined;
    };
    var addListener = exports.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer) destroyer.$toDestroy.push(new EventListener(elem, type, callback));
    };
    var removeListener = exports.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
    };
    exports.stopEvent = function(e) {
        exports.stopPropagation(e);
        exports.preventDefault(e);
        return false;
    };
    exports.stopPropagation = function(e) {
        if (e.stopPropagation) e.stopPropagation();
    };
    exports.preventDefault = function(e) {
        if (e.preventDefault) e.preventDefault();
    };
    exports.getButton = function(e) {
        if (e.type == "dblclick") return 0;
        if (e.type == "contextmenu" || useragent.isMac && e.ctrlKey && !e.altKey && !e.shiftKey) return 2;
        return e.button;
    };
    exports.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e) {
            eventHandler && eventHandler(e);
            releaseCaptureHandler && releaseCaptureHandler(e);
            removeListener(ownerDocument, "mousemove", eventHandler);
            removeListener(ownerDocument, "mouseup", onMouseUp);
            removeListener(ownerDocument, "dragstart", onMouseUp);
        }
        addListener(ownerDocument, "mousemove", eventHandler);
        addListener(ownerDocument, "mouseup", onMouseUp);
        addListener(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
    };
    exports.addMouseWheelListener = function(el, callback, destroyer) {
        addListener(el, "wheel", function(e) {
            var factor = 0.15;
            var deltaX = e.deltaX || 0;
            var deltaY = e.deltaY || 0;
            switch(e.deltaMode){
                case e.DOM_DELTA_PIXEL:
                    e.wheelX = deltaX * factor;
                    e.wheelY = deltaY * factor;
                    break;
                case e.DOM_DELTA_LINE:
                    var linePixels = 15;
                    e.wheelX = deltaX * linePixels;
                    e.wheelY = deltaY * linePixels;
                    break;
                case e.DOM_DELTA_PAGE:
                    var pagePixels = 150;
                    e.wheelX = deltaX * pagePixels;
                    e.wheelY = deltaY * pagePixels;
                    break;
            }
            callback(e);
        }, destroyer);
    };
    exports.addMultiMouseDownListener = function(elements, timeouts, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
            2: "dblclick",
            3: "tripleclick",
            4: "quadclick"
        };
        function onMousedown(e) {
            if (exports.getButton(e) !== 0) clicks = 0;
            else if (e.detail > 1) {
                clicks++;
                if (clicks > 4) clicks = 1;
            } else clicks = 1;
            if (useragent.isIE) {
                var isNewClick = Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5;
                if (!timer || isNewClick) clicks = 1;
                if (timer) clearTimeout(timer);
                timer = setTimeout(function() {
                    timer = null;
                }, timeouts[clicks - 1] || 600);
                if (clicks == 1) {
                    startX = e.clientX;
                    startY = e.clientY;
                }
            }
            e._clicks = clicks;
            eventHandler[callbackName]("mousedown", e);
            if (clicks > 4) clicks = 0;
            else if (clicks > 1) return eventHandler[callbackName](eventNames[clicks], e);
        }
        if (!Array.isArray(elements)) elements = [
            elements
        ];
        elements.forEach(function(el) {
            addListener(el, "mousedown", onMousedown, destroyer);
        });
    };
    function getModifierHash(e) {
        return 0 | (e.ctrlKey ? 1 : 0) | (e.altKey ? 2 : 0) | (e.shiftKey ? 4 : 0) | (e.metaKey ? 8 : 0);
    }
    exports.getModifierString = function(e) {
        return keys.KEY_MODS[getModifierHash(e)];
    };
    function normalizeCommandKeys(callback, e, keyCode) {
        var hashId = getModifierHash(e);
        if (!keyCode && e.code) keyCode = keys.$codeToKeyCode[e.code] || keyCode;
        if (!useragent.isMac && pressedKeys) {
            if (e.getModifierState && (e.getModifierState("OS") || e.getModifierState("Win"))) hashId |= 8;
            if (pressedKeys.altGr) {
                if ((3 & hashId) != 3) pressedKeys.altGr = 0;
                else return;
            }
            if (keyCode === 18 || keyCode === 17) {
                var location = e.location;
                if (keyCode === 17 && location === 1) {
                    if (pressedKeys[keyCode] == 1) ts = e.timeStamp;
                } else if (keyCode === 18 && hashId === 3 && location === 2) {
                    var dt = e.timeStamp - ts;
                    if (dt < 50) pressedKeys.altGr = true;
                }
            }
        }
        if (keyCode in keys.MODIFIER_KEYS) keyCode = -1;
        if (!hashId && keyCode === 13) {
            if (e.location === 3) {
                callback(e, hashId, -keyCode);
                if (e.defaultPrevented) return;
            }
        }
        if (useragent.isChromeOS && hashId & 8) {
            callback(e, hashId, keyCode);
            if (e.defaultPrevented) return;
            else hashId &= -9;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) return false;
        return callback(e, hashId, keyCode);
    }
    exports.addCommandKeyListener = function(el, callback, destroyer) {
        var lastDefaultPrevented = null;
        addListener(el, "keydown", function(e) {
            pressedKeys[e.keyCode] = (pressedKeys[e.keyCode] || 0) + 1;
            var result = normalizeCommandKeys(callback, e, e.keyCode);
            lastDefaultPrevented = e.defaultPrevented;
            return result;
        }, destroyer);
        addListener(el, "keypress", function(e) {
            if (lastDefaultPrevented && (e.ctrlKey || e.altKey || e.shiftKey || e.metaKey)) {
                exports.stopEvent(e);
                lastDefaultPrevented = null;
            }
        }, destroyer);
        addListener(el, "keyup", function(e) {
            pressedKeys[e.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
            resetPressedKeys();
            addListener(window, "focus", resetPressedKeys);
        }
    };
    function resetPressedKeys() {
        pressedKeys = Object.create(null);
    }
    if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports.nextTick = function(callback, win) {
            win = win || window;
            var messageName = "zero-timeout-message-" + postMessageId++;
            var listener = function(e) {
                if (e.data == messageName) {
                    exports.stopPropagation(e);
                    removeListener(win, "message", listener);
                    callback();
                }
            };
            addListener(win, "message", listener);
            win.postMessage(messageName, "*");
        };
    }
    exports.$idleBlocked = false;
    exports.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
            if (!exports.$idleBlocked) cb();
            else setTimeout(handler, 100);
        }, timeout);
    };
    exports.$idleBlockId = null;
    exports.blockIdle = function(delay) {
        if (exports.$idleBlockId) clearTimeout(exports.$idleBlockId);
        exports.$idleBlocked = true;
        exports.$idleBlockId = setTimeout(function() {
            exports.$idleBlocked = false;
        }, delay || 100);
    };
    exports.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"]);
    if (exports.nextFrame) exports.nextFrame = exports.nextFrame.bind(window);
    else exports.nextFrame = function(callback) {
        setTimeout(callback, 17);
    };
});
ace.define("ace/clipboard", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var $cancelT;
    module1.exports = {
        lineMode: false,
        pasteCancelled: function() {
            if ($cancelT && $cancelT > Date.now() - 50) return true;
            return $cancelT = false;
        },
        cancel: function() {
            $cancelT = Date.now();
        }
    };
});
ace.define("ace/keyboard/textinput", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/config",
    "ace/lib/useragent",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/clipboard",
    "ace/lib/keys"
], function(require, exports, module1) {
    "use strict";
    var event = require("../lib/event");
    var nls = require("../config").nls;
    var useragent = require("../lib/useragent");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var clipboard = require("../clipboard");
    var BROKEN_SETDATA = useragent.isChrome < 18;
    var USE_IE_MIME_TYPE = useragent.isIE;
    var HAS_FOCUS_ARGS = useragent.isChrome > 63;
    var MAX_LINE_LENGTH = 400;
    var KEYS = require("../lib/keys");
    var MODS = KEYS.KEY_MODS;
    var isIOS = useragent.isIOS;
    var valueResetRegex = isIOS ? /\s/ : /\n/;
    var isMobile = useragent.isMobile;
    var TextInput;
    TextInput = function(/**@type{HTMLTextAreaElement} */ parentNode, /**@type{import("../editor").Editor} */ host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", "false");
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        this.setHost = function(newHost) {
            host = newHost;
        };
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = "";
        if (!isMobile) text.style.fontSize = "1px";
        var commandMode = false;
        var ignoreFocusEvents = false;
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        var rowStart = Number.MAX_SAFE_INTEGER;
        var rowEnd = Number.MIN_SAFE_INTEGER;
        var numberOfExtraLines = 0;
        try {
            var isFocused = document.activeElement === text;
        } catch (e) {}
        this.setNumberOfExtraLines = function(/**@type{number}*/ number) {
            rowStart = Number.MAX_SAFE_INTEGER;
            rowEnd = Number.MIN_SAFE_INTEGER;
            if (number < 0) {
                numberOfExtraLines = 0;
                return;
            }
            numberOfExtraLines = number;
        };
        this.setAriaLabel = function() {
            var ariaLabel = "";
            if (host.$textInputAriaLabel) ariaLabel += "".concat(host.$textInputAriaLabel, ", ");
            if (host.session) {
                var row = host.session.selection.cursor.row;
                ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [
                    row + 1
                ]);
            }
            text.setAttribute("aria-label", ariaLabel);
        };
        this.setAriaOptions = function(options) {
            if (options.activeDescendant) {
                text.setAttribute("aria-haspopup", "true");
                text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
                text.setAttribute("aria-activedescendant", options.activeDescendant);
            } else {
                text.setAttribute("aria-haspopup", "false");
                text.setAttribute("aria-autocomplete", "both");
                text.removeAttribute("aria-activedescendant");
            }
            if (options.role) text.setAttribute("role", options.role);
            if (options.setLabel) {
                text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
                this.setAriaLabel();
            }
        };
        this.setAriaOptions({
            role: "textbox"
        });
        event.addListener(text, "blur", function(e) {
            if (ignoreFocusEvents) return;
            host.onBlur(e);
            isFocused = false;
        }, host);
        event.addListener(text, "focus", function(e) {
            if (ignoreFocusEvents) return;
            isFocused = true;
            if (useragent.isEdge) try {
                if (!document.hasFocus()) return;
            } catch (e) {}
            host.onFocus(e);
            if (useragent.isEdge) setTimeout(resetSelection);
            else resetSelection();
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
            this.setAriaOptions({
                setLabel: host.renderer.enableKeyboardAccessibility
            });
            if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser") return text.focus({
                preventScroll: true
            });
            var top = text.style.top;
            text.style.position = "fixed";
            text.style.top = "0px";
            try {
                var isTransformed = text.getBoundingClientRect().top != 0;
            } catch (e) {
                return;
            }
            var ancestors = [];
            if (isTransformed) {
                var t = text.parentElement;
                while(t && t.nodeType == 1){
                    ancestors.push(t);
                    t.setAttribute("ace_nocontext", "true");
                    if (!t.parentElement && t.getRootNode) t = t.getRootNode()["host"];
                    else t = t.parentElement;
                }
            }
            text.focus({
                preventScroll: true
            });
            if (isTransformed) ancestors.forEach(function(p) {
                p.removeAttribute("ace_nocontext");
            });
            setTimeout(function() {
                text.style.position = "";
                if (text.style.top == "0px") text.style.top = top;
            }, 0);
        };
        this.blur = function() {
            text.blur();
        };
        this.isFocused = function() {
            return isFocused;
        };
        host.on("beforeEndOperation", function() {
            var curOp = host.curOp;
            var commandName = curOp && curOp.command && curOp.command.name;
            if (commandName == "insertstring") return;
            var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
            if (inComposition && isUserAction) {
                lastValue = text.value = "";
                onCompositionEnd();
            }
            resetSelection();
        });
        host.on("changeSelection", this.setAriaLabel);
        var positionToSelection = function(row, column) {
            var selection = column;
            for(var i = 1; i <= row - rowStart && i < 2 * numberOfExtraLines + 1; i++)selection += host.session.getLine(row - i).length + 1;
            return selection;
        };
        var resetSelection = isIOS ? function(value) {
            if (!isFocused || copied && !value || sendingText) return;
            if (!value) value = "";
            var newValue = "\n ab" + value + "cde fg\n";
            if (newValue != text.value) text.value = lastValue = newValue;
            var selectionStart = 4;
            var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
            if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) text.setSelectionRange(selectionStart, selectionEnd);
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
        } : function() {
            if (inComposition || sendingText) return;
            if (!isFocused && !afterContextMenu) return;
            inComposition = true;
            var selectionStart = 0;
            var selectionEnd = 0;
            var line = "";
            if (host.session) {
                var selection = host.selection;
                var range = selection.getRange();
                var row = selection.cursor.row;
                if (row === rowEnd + 1) {
                    rowStart = rowEnd + 1;
                    rowEnd = rowStart + 2 * numberOfExtraLines;
                } else if (row === rowStart - 1) {
                    rowEnd = rowStart - 1;
                    rowStart = rowEnd - 2 * numberOfExtraLines;
                } else if (row < rowStart - 1 || row > rowEnd + 1) {
                    rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;
                    rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;
                }
                var lines = [];
                for(var i = rowStart; i <= rowEnd; i++)lines.push(host.session.getLine(i));
                line = lines.join("\n");
                selectionStart = positionToSelection(range.start.row, range.start.column);
                selectionEnd = positionToSelection(range.end.row, range.end.column);
                if (range.start.row < rowStart) {
                    var prevLine = host.session.getLine(rowStart - 1);
                    selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;
                    selectionEnd += prevLine.length + 1;
                    line = prevLine + "\n" + line;
                } else if (range.end.row > rowEnd) {
                    var nextLine = host.session.getLine(rowEnd + 1);
                    selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;
                    selectionEnd += line.length + 1;
                    line = line + "\n" + nextLine;
                } else if (isMobile && row > 0) {
                    line = "\n" + line;
                    selectionEnd += 1;
                    selectionStart += 1;
                }
                if (line.length > MAX_LINE_LENGTH) {
                    if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) line = line.slice(0, MAX_LINE_LENGTH);
                    else {
                        line = "\n";
                        if (selectionStart == selectionEnd) selectionStart = selectionEnd = 0;
                        else {
                            selectionStart = 0;
                            selectionEnd = 1;
                        }
                    }
                }
                var newValue = line + "\n\n";
                if (newValue != lastValue) {
                    text.value = lastValue = newValue;
                    lastSelectionStart = lastSelectionEnd = newValue.length;
                }
            }
            if (afterContextMenu) {
                lastSelectionStart = text.selectionStart;
                lastSelectionEnd = text.selectionEnd;
            }
            if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd // on ie edge selectionEnd changes silently after the initialization
            ) try {
                text.setSelectionRange(selectionStart, selectionEnd);
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
            } catch (e) {}
            inComposition = false;
        };
        this.resetSelection = resetSelection;
        if (isFocused) host.onFocus();
        var isAllSelected = function(text) {
            return text.selectionStart === 0 && text.selectionEnd >= lastValue.length && text.value === lastValue && lastValue && text.selectionEnd !== lastSelectionEnd;
        };
        var onSelect = function(e) {
            if (inComposition) return;
            if (copied) copied = false;
            else if (isAllSelected(text)) {
                host.selectAll();
                resetSelection();
            } else if (isMobile && text.selectionStart != lastSelectionStart) resetSelection();
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
            inputHandler = cb;
        };
        this.getInputHandler = function() {
            return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(value, fromInput) {
            if (afterContextMenu) afterContextMenu = false;
            if (pasted) {
                resetSelection();
                if (value) host.onPaste(value);
                pasted = false;
                return "";
            } else {
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
                var extendLeft = lastSelectionStart;
                var extendRight = lastValue.length - lastSelectionEnd;
                var inserted = value;
                var restoreStart = value.length - selectionStart;
                var restoreEnd = value.length - selectionEnd;
                var i = 0;
                while(extendLeft > 0 && lastValue[i] == value[i]){
                    i++;
                    extendLeft--;
                }
                inserted = inserted.slice(i);
                i = 1;
                while(extendRight > 0 && lastValue.length - i > lastSelectionStart - 1 && lastValue[lastValue.length - i] == value[value.length - i]){
                    i++;
                    extendRight--;
                }
                restoreStart -= i - 1;
                restoreEnd -= i - 1;
                var endIndex = inserted.length - i + 1;
                if (endIndex < 0) {
                    extendLeft = -endIndex;
                    endIndex = 0;
                }
                inserted = inserted.slice(0, endIndex);
                if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd) return "";
                sendingText = true;
                var shouldReset = false;
                if (useragent.isAndroid && inserted == ". ") {
                    inserted = "  ";
                    shouldReset = true;
                }
                if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) host.onTextInput(inserted);
                else host.onTextInput(inserted, {
                    extendLeft: extendLeft,
                    extendRight: extendRight,
                    restoreStart: restoreStart,
                    restoreEnd: restoreEnd
                });
                sendingText = false;
                lastValue = value;
                lastSelectionStart = selectionStart;
                lastSelectionEnd = selectionEnd;
                lastRestoreEnd = restoreEnd;
                return shouldReset ? "\n" : inserted;
            }
        };
        var onInput = function(e) {
            if (inComposition) return onCompositionUpdate();
            if (e && e.inputType) {
                if (e.inputType == "historyUndo") return host.execCommand("undo");
                if (e.inputType == "historyRedo") return host.execCommand("redo");
            }
            var data = text.value;
            var inserted = sendText(data, true);
            if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) resetSelection();
        };
        var handleClipboardData = function(e, data, forceIEMime) {
            var clipboardData = e.clipboardData || window["clipboardData"];
            if (!clipboardData || BROKEN_SETDATA) return;
            var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
            try {
                if (data) return clipboardData.setData(mime, data) !== false;
                else return clipboardData.getData(mime);
            } catch (e) {
                if (!forceIEMime) return handleClipboardData(e, data, true);
            }
        };
        var doCopy = function(e, isCut) {
            var data = host.getCopyText();
            if (!data) return event.preventDefault(e);
            if (handleClipboardData(e, data)) {
                if (isIOS) {
                    resetSelection(data);
                    copied = data;
                    setTimeout(function() {
                        copied = false;
                    }, 10);
                }
                isCut ? host.onCut() : host.onCopy();
                event.preventDefault(e);
            } else {
                copied = true;
                text.value = data;
                text.select();
                setTimeout(function() {
                    copied = false;
                    resetSelection();
                    isCut ? host.onCut() : host.onCopy();
                });
            }
        };
        var onCut = function(e) {
            doCopy(e, true);
        };
        var onCopy = function(e) {
            doCopy(e, false);
        };
        var onPaste = function(e) {
            var data = handleClipboardData(e);
            if (clipboard.pasteCancelled()) return;
            if (typeof data == "string") {
                if (data) host.onPaste(data, e);
                if (useragent.isIE) setTimeout(resetSelection);
                event.preventDefault(e);
            } else {
                text.value = "";
                pasted = true;
            }
        };
        event.addCommandKeyListener(text, function(e, hashId, keyCode) {
            if (inComposition) return;
            return host.onCommandKey(e, hashId, keyCode);
        }, host);
        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);
        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) event.addListener(parentNode, "keydown", function(e) {
            if (useragent.isMac && !e.metaKey || !e.ctrlKey) return;
            switch(e.keyCode){
                case 67:
                    onCopy(e);
                    break;
                case 86:
                    onPaste(e);
                    break;
                case 88:
                    onCut(e);
                    break;
            }
        }, host);
        var onCompositionStart = function(e) {
            if (inComposition || !host.onCompositionStart || host.$readOnly) return;
            inComposition = {};
            if (commandMode) return;
            if (e.data) inComposition.useTextareaForIME = false;
            setTimeout(onCompositionUpdate, 0);
            host._signal("compositionStart");
            host.on("mousedown", cancelComposition);
            var range = host.getSelectionRange();
            range.end.row = range.start.row;
            range.end.column = range.start.column;
            inComposition.markerRange = range;
            inComposition.selectionStart = lastSelectionStart;
            host.onCompositionStart(inComposition);
            if (inComposition.useTextareaForIME) {
                lastValue = text.value = "";
                lastSelectionStart = 0;
                lastSelectionEnd = 0;
            } else {
                if (text.msGetInputContext) inComposition.context = text.msGetInputContext();
                if (text.getInputContext) inComposition.context = text.getInputContext();
            }
        };
        var onCompositionUpdate = function() {
            if (!inComposition || !host.onCompositionUpdate || host.$readOnly) return;
            if (commandMode) return cancelComposition();
            if (inComposition.useTextareaForIME) host.onCompositionUpdate(text.value);
            else {
                var data = text.value;
                sendText(data);
                if (inComposition.markerRange) {
                    if (inComposition.context) inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
                    inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
                }
            }
        };
        var onCompositionEnd = function(e) {
            if (!host.onCompositionEnd || host.$readOnly) return;
            inComposition = false;
            host.onCompositionEnd();
            host.off("mousedown", cancelComposition);
            if (e) onInput();
        };
        function cancelComposition() {
            ignoreFocusEvents = true;
            text.blur();
            text.focus();
            ignoreFocusEvents = false;
        }
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        function onKeyup(e) {
            if (e.keyCode == 27 && text.value.length < text.selectionStart) {
                if (!inComposition) lastValue = text.value;
                lastSelectionStart = lastSelectionEnd = -1;
                resetSelection();
            }
            syncComposition();
        }
        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);
        this.getElement = function() {
            return text;
        };
        this.setCommandMode = function(value) {
            commandMode = value;
            text.readOnly = false;
        };
        this.setReadOnly = function(readOnly) {
            if (!commandMode) text.readOnly = readOnly;
        };
        this.setCopyWithEmptySelection = function(value) {};
        this.onContextMenu = function(e) {
            afterContextMenu = true;
            resetSelection();
            host._emit("nativecontextmenu", {
                target: host,
                domEvent: e
            });
            this.moveToMouse(e, true);
        };
        this.moveToMouse = function(e, bringToFront) {
            if (!tempStyle) tempStyle = text.style.cssText;
            text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
            var rect = host.container.getBoundingClientRect();
            var style = dom.computedStyle(host.container);
            var top = rect.top + (parseInt(style.borderTopWidth) || 0);
            var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
            var maxTop = rect.bottom - top - text.clientHeight - 2;
            var move = function(e) {
                dom.translate(text, e.clientX - left - 2, Math.min(e.clientY - top - 2, maxTop));
            };
            move(e);
            if (e.type != "mousedown") return;
            host.renderer.$isMousePressed = true;
            clearTimeout(closeTimeout);
            if (useragent.isWin) event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
            clearTimeout(closeTimeout);
            closeTimeout = setTimeout(function() {
                if (tempStyle) {
                    text.style.cssText = tempStyle;
                    tempStyle = "";
                }
                host.renderer.$isMousePressed = false;
                if (host.renderer.$keepTextAreaAtCursor) host.renderer.$moveTextAreaToCursor();
            }, 0);
        }
        var onContextMenu = function(e) {
            host.textInput.onContextMenu(e);
            onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e) {
            e.preventDefault();
            onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        if (isIOS) addIosSelectionHandler(parentNode, host, text);
        function addIosSelectionHandler(parentNode, host, text) {
            var typingResetTimeout = null;
            var typing = false;
            text.addEventListener("keydown", function(e) {
                if (typingResetTimeout) clearTimeout(typingResetTimeout);
                typing = true;
            }, true);
            text.addEventListener("keyup", function(e) {
                typingResetTimeout = setTimeout(function() {
                    typing = false;
                }, 100);
            }, true);
            var detectArrowKeys = function(e) {
                if (document.activeElement !== text) return;
                if (typing || inComposition || host.$mouseHandler.isMousePressed) return;
                if (copied) return;
                var selectionStart = text.selectionStart;
                var selectionEnd = text.selectionEnd;
                var key = null;
                var modifier = 0;
                if (selectionStart == 0) key = KEYS.up;
                else if (selectionStart == 1) key = KEYS.home;
                else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") key = KEYS.end;
                else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
                    key = KEYS.left;
                    modifier = MODS.option;
                } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) key = KEYS.left;
                else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) key = KEYS.down;
                else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
                    key = KEYS.right;
                    modifier = MODS.option;
                } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) key = KEYS.right;
                if (selectionStart !== selectionEnd) modifier |= MODS.shift;
                if (key) {
                    var result = host.onCommandKey({}, modifier, key);
                    if (!result && host.commands) {
                        key = KEYS.keyCodeToString(key);
                        var command = host.commands.findKeyCommand(modifier, key);
                        if (command) host.execCommand(command);
                    }
                    lastSelectionStart = selectionStart;
                    lastSelectionEnd = selectionEnd;
                    resetSelection("");
                }
            };
            document.addEventListener("selectionchange", detectArrowKeys);
            host.on("destroy", function() {
                document.removeEventListener("selectionchange", detectArrowKeys);
            });
        }
        this.destroy = function() {
            if (text.parentElement) text.parentElement.removeChild(text);
        };
    };
    exports.TextInput = TextInput;
    exports.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS = _isIOS;
    };
});
ace.define("ace/mouse/default_handlers", [
    "require",
    "exports",
    "module",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var useragent = require("../lib/useragent");
    var DRAG_OFFSET = 0; // pixels
    var SCROLL_COOLDOWN_T = 550; // milliseconds
    var DefaultHandlers = /** @class */ function() {
        function DefaultHandlers(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor = mouseHandler.editor;
            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports = [
                "select",
                "startSelect",
                "selectEnd",
                "selectAllEnd",
                "selectByWordsEnd",
                "selectByLinesEnd",
                "dragWait",
                "dragWaitEnd",
                "focusWait"
            ];
            exports.forEach(function(x) {
                mouseHandler[x] = this[x];
            }, this);
            mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
        }
        DefaultHandlers.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button = ev.getButton();
            if (button !== 0) {
                var selectionRange = editor.getSelectionRange();
                var selectionEmpty = selectionRange.isEmpty();
                if (selectionEmpty || button == 1) editor.selection.moveToPosition(pos);
                if (button == 2) {
                    editor.textInput.onContextMenu(ev.domEvent);
                    if (!useragent.isMozilla) ev.preventDefault();
                }
                return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
                editor.focus();
                if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                    this.setState("focusWait");
                    this.captureMouse(ev);
                    return;
                }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
        };
        DefaultHandlers.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent) return;
            if (this.mousedownEvent.getShiftKey()) editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection) editor.selection.moveToPosition(pos);
            if (!waitForClickSelection) this.select();
            editor.setStyle("ace_selecting");
            this.setState("select");
        };
        DefaultHandlers.prototype.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
                var cmp = this.$clickSelection.comparePoint(cursor);
                if (cmp == -1) anchor = this.$clickSelection.end;
                else if (cmp == 1) anchor = this.$clickSelection.start;
                else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };
        DefaultHandlers.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
                var cmpStart = this.$clickSelection.comparePoint(range.start);
                var cmpEnd = this.$clickSelection.comparePoint(range.end);
                if (cmpStart == -1 && cmpEnd <= 0) {
                    anchor = this.$clickSelection.end;
                    if (range.end.row != cursor.row || range.end.column != cursor.column) cursor = range.start;
                } else if (cmpEnd == 1 && cmpStart >= 0) {
                    anchor = this.$clickSelection.start;
                    if (range.start.row != cursor.row || range.start.column != cursor.column) cursor = range.end;
                } else if (cmpStart == -1 && cmpEnd == 1) {
                    cursor = range.end;
                    anchor = range.start;
                } else {
                    var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                    cursor = orientedRange.cursor;
                    anchor = orientedRange.anchor;
                }
                editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
        };
        DefaultHandlers.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
        };
        DefaultHandlers.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout) this.startSelect(this.mousedownEvent.getDocumentPosition());
        };
        DefaultHandlers.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
                if (range.isEmpty()) {
                    range.start.column--;
                    range.end.column++;
                }
                this.setState("select");
            } else {
                range = editor.selection.getWordRange(pos.row, pos.column);
                this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
        };
        DefaultHandlers.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
                this.$clickSelection = editor.selection.getLineRange(range.start.row);
                this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else this.$clickSelection = editor.selection.getLineRange(pos.row);
            this.select();
        };
        DefaultHandlers.prototype.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
        };
        DefaultHandlers.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey()) return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
                ev.wheelX = ev.wheelY;
                ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll) this.$lastScroll = {
                t: 0,
                vx: 0,
                vy: 0,
                allowed: 0
            };
            var prevScroll = this.$lastScroll;
            var t = ev.domEvent.timeStamp;
            var dt = t - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
                vx = (vx + prevScroll.vx) / 2;
                vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0)) canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed)) canScroll = true;
            if (canScroll) prevScroll.allowed = t;
            else if (t - prevScroll.allowed < SCROLL_COOLDOWN_T) {
                var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
                if (isSlower) {
                    canScroll = true;
                    prevScroll.allowed = t;
                } else prevScroll.allowed = 0;
            }
            prevScroll.t = t;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
                editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
                return ev.stop();
            }
        };
        return DefaultHandlers;
    }();
    DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
    DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
    DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
    exports.DefaultHandlers = DefaultHandlers;
    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row) var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column) var cmp = cursor.column - 4;
        else var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0) return {
            cursor: range.start,
            anchor: range.end
        };
        else return {
            cursor: range.end,
            anchor: range.start
        };
    }
});
ace.define("ace/lib/scroll", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    exports.preventParentScroll = function preventParentScroll(event) {
        event.stopPropagation();
        var target = event.currentTarget;
        var contentOverflows = target.scrollHeight > target.clientHeight;
        if (!contentOverflows) event.preventDefault();
    };
});
ace.define("ace/tooltip", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/range",
    "ace/lib/scroll"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var dom = require("./lib/dom");
    var event = require("./lib/event");
    var Range = require("./range").Range;
    var preventParentScroll = require("./lib/scroll").preventParentScroll;
    var CLASSNAME = "ace_tooltip";
    var Tooltip = /** @class */ function() {
        function Tooltip(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
        }
        Tooltip.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
        };
        Tooltip.prototype.getElement = function() {
            return this.$element || this.$init();
        };
        Tooltip.prototype.setText = function(text) {
            this.getElement().textContent = text;
        };
        Tooltip.prototype.setHtml = function(html) {
            this.getElement().innerHTML = html;
        };
        Tooltip.prototype.setPosition = function(x, y) {
            this.getElement().style.left = x + "px";
            this.getElement().style.top = y + "px";
        };
        Tooltip.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
        };
        Tooltip.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
        };
        Tooltip.prototype.show = function(text, x, y) {
            if (text != null) this.setText(text);
            if (x != null && y != null) this.setPosition(x, y);
            if (!this.isOpen) {
                this.getElement().style.display = "block";
                this.isOpen = true;
            }
        };
        Tooltip.prototype.hide = function(e) {
            if (this.isOpen) {
                this.getElement().style.display = "none";
                this.getElement().className = CLASSNAME;
                this.isOpen = false;
            }
        };
        Tooltip.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
        };
        Tooltip.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
        };
        Tooltip.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) this.$element.parentNode.removeChild(this.$element);
        };
        return Tooltip;
    }();
    var PopupManager = /** @class */ function() {
        function PopupManager() {
            this.popups = [];
        }
        PopupManager.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
        };
        PopupManager.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
                this.popups.splice(index, 1);
                this.updatePopups();
            }
        };
        PopupManager.prototype.updatePopups = function() {
            var e_1, _a, e_2, _b;
            this.popups.sort(function(a, b) {
                return b.priority - a.priority;
            });
            var visiblepopups = [];
            try {
                for(var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()){
                    var popup = _d.value;
                    var shouldDisplay = true;
                    try {
                        for(var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()){
                            var visiblePopup = visiblepopups_1_1.value;
                            if (this.doPopupsOverlap(visiblePopup, popup)) {
                                shouldDisplay = false;
                                break;
                            }
                        }
                    } catch (e_2_1) {
                        e_2 = {
                            error: e_2_1
                        };
                    } finally{
                        try {
                            if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
                        } finally{
                            if (e_2) throw e_2.error;
                        }
                    }
                    if (shouldDisplay) visiblepopups.push(popup);
                    else popup.hide();
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
        };
        PopupManager.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
        };
        return PopupManager;
    }();
    var popupManager = new PopupManager();
    exports.popupManager = popupManager;
    exports.Tooltip = Tooltip;
    var HoverTooltip = /** @class */ function(_super) {
        __extends(HoverTooltip, _super);
        function HoverTooltip(parentNode) {
            if (parentNode === void 0) parentNode = document.body;
            var _this = _super.call(this, parentNode) || this;
            _this.timeout = undefined;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = undefined;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", (function() {
                if (!el.contains(document.activeElement)) this.hide();
            }).bind(_this));
            el.addEventListener("wheel", preventParentScroll);
            return _this;
        }
        HoverTooltip.prototype.addToEditor = function(editor) {
            editor.on("mousemove", this.onMouseMove);
            editor.on("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
        };
        HoverTooltip.prototype.removeFromEditor = function(editor) {
            editor.off("mousemove", this.onMouseMove);
            editor.off("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        HoverTooltip.prototype.onMouseMove = function(e, editor) {
            this.lastEvent = e;
            this.lastT = Date.now();
            var isMousePressed = editor.$mouseHandler.isMousePressed;
            if (this.isOpen) {
                var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
                if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) this.hide();
            }
            if (this.timeout || isMousePressed) return;
            this.lastEvent = e;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
        };
        HoverTooltip.prototype.waitForHover = function() {
            if (this.timeout) clearTimeout(this.timeout);
            var dt = Date.now() - this.lastT;
            if (this.idleTime - dt > 10) {
                this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
                return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) this.$gatherData(this.lastEvent, this.lastEvent.editor);
        };
        HoverTooltip.prototype.isOutsideOfText = function(e) {
            var editor = e.editor;
            var docPos = e.getDocumentPosition();
            var line = editor.session.getLine(docPos.row);
            if (docPos.column == line.length) {
                var screenPos = editor.renderer.pixelToScreenCoordinates(e.clientX, e.clientY);
                var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
                if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) return true;
            }
            return false;
        };
        HoverTooltip.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
        };
        HoverTooltip.prototype.showForRange = function(editor, range, domNode, startingEvent) {
            var MARGIN = 10;
            if (startingEvent && startingEvent != this.lastEvent) return;
            if (this.isOpen && document.activeElement == this.getElement()) return;
            var renderer = editor.renderer;
            if (!this.isOpen) {
                popupManager.addPopup(this);
                this.$registerCloseEvents();
                this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor.session);
            this.range = Range.fromPoints(range.start, range.end);
            var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var rect = renderer.scroller.getBoundingClientRect();
            if (position.pageX < rect.left) position.pageX = rect.left;
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.maxHeight = "";
            element.style.display = "block";
            var labelHeight = element.clientHeight;
            var labelWidth = element.clientWidth;
            var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
            var isAbove = true;
            if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) isAbove = false;
            element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
            element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
            element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
            element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
        };
        HoverTooltip.prototype.addMarker = function(range, session) {
            if (this.marker) this.$markerSession.removeMarker(this.marker);
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
        };
        HoverTooltip.prototype.hide = function(e) {
            if (!e && document.activeElement == this.getElement()) return;
            if (e && e.target && (e.type != "keydown" || e.ctrlKey || e.metaKey) && this.$element.contains(e.target)) return;
            this.lastEvent = null;
            if (this.timeout) clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
                this.$removeCloseEvents();
                this.getElement().style.display = "none";
                this.isOpen = false;
                popupManager.removePopup(this);
            }
        };
        HoverTooltip.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("wheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
        };
        HoverTooltip.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("wheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
        };
        HoverTooltip.prototype.onMouseOut = function(e) {
            if (this.timeout) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen) return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;
            if (e && e.currentTarget.contains(e.relatedTarget)) return;
            if (!e.relatedTarget.classList.contains("ace_content")) this.hide();
        };
        return HoverTooltip;
    }(Tooltip);
    exports.HoverTooltip = HoverTooltip;
});
ace.define("ace/mouse/default_gutter_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/tooltip",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var dom = require("../lib/dom");
    var event = require("../lib/event");
    var Tooltip = require("../tooltip").Tooltip;
    var nls = require("../config").nls;
    var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
    var GUTTER_TOOLTIP_TOP_OFFSET = 3;
    exports.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
    exports.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
    function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor, true);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e) {
            if (!editor.isFocused() || e.getButton() != 0) return;
            var gutterRegion = gutter.getRegion(e);
            if (gutterRegion == "foldWidgets") return;
            var row = e.getDocumentPosition().row;
            var selection = editor.session.selection;
            if (e.getShiftKey()) selection.selectTo(row, 0);
            else {
                if (e.domEvent.detail == 2) {
                    editor.selectAll();
                    return e.preventDefault();
                }
                mouseHandler.$clickSelection = editor.selection.getLineRange(row);
            }
            mouseHandler.setState("selectByLines");
            mouseHandler.captureMouse(e);
            return e.preventDefault();
        });
        var tooltipTimeout, mouseEvent;
        function showTooltip() {
            var row = mouseEvent.getDocumentPosition().row;
            var maxRow = editor.session.getLength();
            if (row == maxRow) {
                var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
                var pos = mouseEvent.$pos;
                if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column)) return hideTooltip();
            }
            tooltip.showTooltip(row);
            if (!tooltip.isOpen) return;
            editor.on("mousewheel", hideTooltip);
            editor.on("changeSession", hideTooltip);
            window.addEventListener("keydown", hideTooltip, true);
            if (mouseHandler.$tooltipFollowsMouse) moveTooltip(mouseEvent);
            else {
                var gutterRow = mouseEvent.getGutterRow();
                var gutterCell = gutter.$lines.get(gutterRow);
                if (gutterCell) {
                    var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
                    var rect = gutterElement.getBoundingClientRect();
                    var style = tooltip.getElement().style;
                    style.left = rect.right - GUTTER_TOOLTIP_LEFT_OFFSET + "px";
                    style.top = rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET + "px";
                } else moveTooltip(mouseEvent);
            }
        }
        function hideTooltip(e) {
            if (e && e.type === "keydown" && (e.ctrlKey || e.metaKey)) return;
            if (e && e.type === "mouseout" && (!e.relatedTarget || tooltip.getElement().contains(e.relatedTarget))) return;
            if (tooltipTimeout) tooltipTimeout = clearTimeout(tooltipTimeout);
            if (tooltip.isOpen) {
                tooltip.hideTooltip();
                editor.off("mousewheel", hideTooltip);
                editor.off("changeSession", hideTooltip);
                window.removeEventListener("keydown", hideTooltip, true);
            }
        }
        function moveTooltip(e) {
            tooltip.setPosition(e.x, e.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e) {
            var target = e.domEvent.target || e.domEvent.srcElement;
            if (dom.hasCssClass(target, "ace_fold-widget") || dom.hasCssClass(target, "ace_custom-widget")) return hideTooltip();
            if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse) moveTooltip(e);
            mouseEvent = e;
            if (tooltipTimeout) return;
            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                if (mouseEvent && !mouseHandler.isMousePressed) showTooltip();
            }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e) {
            mouseEvent = null;
            if (!tooltip.isOpen) return;
            tooltipTimeout = setTimeout(function() {
                tooltipTimeout = null;
                hideTooltip(e);
            }, 50);
        }, editor);
    }
    exports.GutterHandler = GutterHandler;
    var GutterTooltip = /** @class */ function(_super) {
        __extends(GutterTooltip, _super);
        function GutterTooltip(editor, isHover) {
            if (isHover === void 0) isHover = false;
            var _this = _super.call(this, editor.container) || this;
            _this.editor = editor;
            _this.visibleTooltipRow;
            var el = _this.getElement();
            el.setAttribute("role", "tooltip");
            el.style.pointerEvents = "auto";
            if (isHover) {
                _this.onMouseOut = _this.onMouseOut.bind(_this);
                el.addEventListener("mouseout", _this.onMouseOut);
            }
            return _this;
        }
        GutterTooltip.prototype.onMouseOut = function(e) {
            if (!this.isOpen) return;
            if (!e.relatedTarget || this.getElement().contains(e.relatedTarget)) return;
            if (e && e.currentTarget.contains(e.relatedTarget)) return;
            this.hideTooltip();
        };
        GutterTooltip.prototype.setPosition = function(x, y) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x += 15;
            y += 15;
            if (x + width > windowWidth) x -= x + width - windowWidth;
            if (y + height > windowHeight) y -= 20 + height;
            Tooltip.prototype.setPosition.call(this, x, y);
        };
        Object.defineProperty(GutterTooltip, "annotationLabels", {
            get: function() {
                return {
                    error: {
                        singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                        plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
                    },
                    security: {
                        singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                        plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
                    },
                    warning: {
                        singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                        plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
                    },
                    info: {
                        singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                        plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
                    },
                    hint: {
                        singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                        plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
                    }
                };
            },
            enumerable: false,
            configurable: true
        });
        GutterTooltip.prototype.showTooltip = function(row) {
            var _a;
            var gutter = this.editor.renderer.$gutterLayer;
            var annotationsInRow = gutter.$annotations[row];
            var annotation;
            if (annotationsInRow) annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
            };
            else annotation = {
                displayText: [],
                type: []
            };
            var fold = gutter.session.getFoldLine(row);
            if (fold && gutter.$showFoldedAnnotations) {
                var annotationsInFold = {
                    error: [],
                    security: [],
                    warning: [],
                    info: [],
                    hint: []
                };
                var severityRank = {
                    error: 1,
                    security: 2,
                    warning: 3,
                    info: 4,
                    hint: 5
                };
                var mostSevereAnnotationTypeInFold;
                for(var i = row + 1; i <= fold.end.row; i++){
                    if (!gutter.$annotations[i]) continue;
                    for(var j = 0; j < gutter.$annotations[i].text.length; j++){
                        var annotationType = gutter.$annotations[i].type[j];
                        annotationsInFold[annotationType].push(gutter.$annotations[i].text[j]);
                        if (!mostSevereAnnotationTypeInFold || severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) mostSevereAnnotationTypeInFold = annotationType;
                    }
                }
                if ([
                    "error",
                    "security",
                    "warning"
                ].includes(mostSevereAnnotationTypeInFold)) {
                    var summaryFoldedAnnotations = "".concat(GutterTooltip.annotationsToSummaryString(annotationsInFold), " in folded code.");
                    annotation.displayText.push(summaryFoldedAnnotations);
                    annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
                }
            }
            if (annotation.displayText.length === 0) return this.hideTooltip();
            var annotationMessages = {
                error: [],
                security: [],
                warning: [],
                info: [],
                hint: []
            };
            var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for(var i = 0; i < annotation.displayText.length; i++){
                var lineElement = dom.createElement("span");
                var iconElement = dom.createElement("span");
                (_a = iconElement.classList).add.apply(_a, [
                    "ace_".concat(annotation.type[i]),
                    iconClassName
                ]);
                iconElement.setAttribute("aria-label", "".concat(GutterTooltip.annotationLabels[annotation.type[i].replace("_fold", "")].singular));
                iconElement.setAttribute("role", "img");
                iconElement.appendChild(dom.createTextNode(" "));
                lineElement.appendChild(iconElement);
                lineElement.appendChild(dom.createTextNode(annotation.displayText[i]));
                lineElement.appendChild(dom.createElement("br"));
                annotationMessages[annotation.type[i].replace("_fold", "")].push(lineElement);
            }
            var tooltipElement = this.getElement();
            dom.removeChildren(tooltipElement);
            annotationMessages.error.forEach(function(el) {
                return tooltipElement.appendChild(el);
            });
            annotationMessages.security.forEach(function(el) {
                return tooltipElement.appendChild(el);
            });
            annotationMessages.warning.forEach(function(el) {
                return tooltipElement.appendChild(el);
            });
            annotationMessages.info.forEach(function(el) {
                return tooltipElement.appendChild(el);
            });
            annotationMessages.hint.forEach(function(el) {
                return tooltipElement.appendChild(el);
            });
            tooltipElement.setAttribute("aria-live", "polite");
            if (!this.isOpen) {
                this.setTheme(this.editor.renderer.theme);
                this.setClassName("ace_gutter-tooltip");
            }
            this.show();
            this.visibleTooltipRow = row;
            this.editor._signal("showGutterTooltip", this);
        };
        GutterTooltip.prototype.hideTooltip = function() {
            if (!this.isOpen) return;
            this.$element.removeAttribute("aria-live");
            this.hide();
            this.visibleTooltipRow = undefined;
            this.editor._signal("hideGutterTooltip", this);
        };
        GutterTooltip.annotationsToSummaryString = function(annotations) {
            var e_1, _a;
            var summary = [];
            var annotationTypes = [
                "error",
                "security",
                "warning",
                "info",
                "hint"
            ];
            try {
                for(var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()){
                    var annotationType = annotationTypes_1_1.value;
                    if (!annotations[annotationType].length) continue;
                    var label = annotations[annotationType].length === 1 ? GutterTooltip.annotationLabels[annotationType].singular : GutterTooltip.annotationLabels[annotationType].plural;
                    summary.push("".concat(annotations[annotationType].length, " ").concat(label));
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return summary.join(", ");
        };
        return GutterTooltip;
    }(Tooltip);
    exports.GutterTooltip = GutterTooltip;
});
ace.define("ace/mouse/mouse_event", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var MouseEvent = /** @class */ function() {
        function MouseEvent(domEvent, editor) {
            this.speed;
            this.wheelX;
            this.wheelY;
            this.domEvent = domEvent;
            this.editor = editor;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
        }
        MouseEvent.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
        };
        MouseEvent.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
        };
        MouseEvent.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
        };
        MouseEvent.prototype.getDocumentPosition = function() {
            if (this.$pos) return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
        };
        MouseEvent.prototype.getGutterRow = function() {
            var documentRow = this.getDocumentPosition().row;
            var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
            var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return screenRow - screenTopRow;
        };
        MouseEvent.prototype.inSelection = function() {
            if (this.$inSelection !== null) return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty()) this.$inSelection = false;
            else {
                var pos = this.getDocumentPosition();
                this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
        };
        MouseEvent.prototype.getButton = function() {
            return event.getButton(this.domEvent);
        };
        MouseEvent.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
        };
        MouseEvent.prototype.getAccelKey = function() {
            return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
        };
        return MouseEvent;
    }();
    exports.MouseEvent = MouseEvent;
});
ace.define("ace/mouse/dragdrop_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var AUTOSCROLL_DELAY = 200;
    var SCROLL_CURSOR_DELAY = 200;
    var SCROLL_CURSOR_HYSTERESIS = 5;
    function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = "\xa0";
        var exports = [
            "dragWait",
            "dragWaitEnd",
            "startDrag",
            "dragReadyEnd",
            "onMouseDrag"
        ];
        exports.forEach(function(x) {
            mouseHandler[x] = this[x];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x, y;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e) {
            if (this.cancelDrag || !mouseTarget.draggable) {
                var self1 = this;
                setTimeout(function() {
                    self1.startSelect();
                    self1.captureMouse(e);
                }, 0);
                return e.preventDefault();
            }
            range = editor.getSelectionRange();
            var dataTransfer = e.dataTransfer;
            dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
            editor.container.appendChild(dragImage);
            dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
            setTimeout(function() {
                editor.container.removeChild(dragImage);
            });
            dataTransfer.clearData();
            dataTransfer.setData("Text", editor.session.getTextRange());
            isInternal = true;
            this.setState("drag");
        };
        this.onDragEnd = function(e) {
            mouseTarget.draggable = false;
            isInternal = false;
            this.setState(null);
            if (!editor.getReadOnly()) {
                var dropEffect = e.dataTransfer.dropEffect;
                if (!dragOperation && dropEffect == "move") editor.session.remove(editor.getSelectionRange());
                editor.$resetCursorStyle();
            }
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker) addDragMarker();
            counter++;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };
        this.onDragOver = function(e) {
            if (editor.getReadOnly() || !canAccept(e.dataTransfer)) return;
            x = e.clientX;
            y = e.clientY;
            if (!dragSelectionMarker) {
                addDragMarker();
                counter++;
            }
            if (onMouseMoveTimer !== null) onMouseMoveTimer = null;
            e.dataTransfer.dropEffect = dragOperation = getDropEffect(e);
            return event.preventDefault(e);
        };
        this.onDragLeave = function(e) {
            counter--;
            if (counter <= 0 && dragSelectionMarker) {
                clearDragMarker();
                dragOperation = null;
                return event.preventDefault(e);
            }
        };
        this.onDrop = function(e) {
            if (!dragCursor) return;
            var dataTransfer = e.dataTransfer;
            if (isInternal) switch(dragOperation){
                case "move":
                    if (range.contains(dragCursor.row, dragCursor.column)) range = {
                        start: dragCursor,
                        end: dragCursor
                    };
                    else range = editor.moveText(range, dragCursor);
                    break;
                case "copy":
                    range = editor.moveText(range, dragCursor, true);
                    break;
            }
            else {
                var dropData = dataTransfer.getData("Text");
                range = {
                    start: dragCursor,
                    end: editor.session.insert(dragCursor, dropData)
                };
                editor.focus();
                dragOperation = null;
            }
            clearDragMarker();
            return event.preventDefault(e);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
        function scrollCursorIntoView(cursor, prevCursor) {
            var now = Date.now();
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            var hMovement = !prevCursor || cursor.column != prevCursor.column;
            if (!cursorMovedTime || vMovement || hMovement) {
                editor.moveCursorToPosition(cursor);
                cursorMovedTime = now;
                cursorPointOnCaretMoved = {
                    x: x,
                    y: y
                };
            } else {
                var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x, y);
                if (distance > SCROLL_CURSOR_HYSTERESIS) cursorMovedTime = null;
                else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
                    editor.renderer.scrollCursorIntoView();
                    cursorMovedTime = null;
                }
            }
        }
        function autoScroll(cursor, prevCursor) {
            var now = Date.now();
            var lineHeight = editor.renderer.layerConfig.lineHeight;
            var characterWidth = editor.renderer.layerConfig.characterWidth;
            var editorRect = editor.renderer.scroller.getBoundingClientRect();
            var offsets = {
                x: {
                    left: x - editorRect.left,
                    right: editorRect.right - x
                },
                y: {
                    top: y - editorRect.top,
                    bottom: editorRect.bottom - y
                }
            };
            var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
            var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
            var scrollCursor = {
                row: cursor.row,
                column: cursor.column
            };
            if (nearestXOffset / characterWidth <= 2) scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
            if (nearestYOffset / lineHeight <= 1) scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
            var vScroll = cursor.row != scrollCursor.row;
            var hScroll = cursor.column != scrollCursor.column;
            var vMovement = !prevCursor || cursor.row != prevCursor.row;
            if (vScroll || hScroll && !vMovement) {
                if (!autoScrollStartTime) autoScrollStartTime = now;
                else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY) editor.renderer.scrollCursorIntoView(scrollCursor);
            } else autoScrollStartTime = null;
        }
        function onDragInterval() {
            var prevCursor = dragCursor;
            dragCursor = editor.renderer.screenToTextCoordinates(x, y);
            scrollCursorIntoView(dragCursor, prevCursor);
            autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
            range = editor.selection.toOrientedRange();
            dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
            editor.clearSelection();
            if (editor.isFocused()) editor.renderer.$cursorLayer.setBlinking(false);
            clearInterval(timerId);
            onDragInterval();
            timerId = setInterval(onDragInterval, 20);
            counter = 0;
            event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
            clearInterval(timerId);
            editor.session.removeMarker(dragSelectionMarker);
            dragSelectionMarker = null;
            editor.selection.fromOrientedRange(range);
            if (editor.isFocused() && !isInternal) editor.$resetCursorStyle();
            range = null;
            dragCursor = null;
            counter = 0;
            autoScrollStartTime = null;
            cursorMovedTime = null;
            event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
            if (onMouseMoveTimer == null) onMouseMoveTimer = setTimeout(function() {
                if (onMouseMoveTimer != null && dragSelectionMarker) clearDragMarker();
            }, 20);
        }
        function canAccept(dataTransfer) {
            var types = dataTransfer.types;
            return !types || Array.prototype.some.call(types, function(type) {
                return type == "text/plain" || type == "Text";
            });
        }
        function getDropEffect(e) {
            var copyAllowed = [
                "copy",
                "copymove",
                "all",
                "uninitialized"
            ];
            var moveAllowed = [
                "move",
                "copymove",
                "linkmove",
                "all",
                "uninitialized"
            ];
            var copyModifierState = useragent.isMac ? e.altKey : e.ctrlKey;
            var effectAllowed = "uninitialized";
            try {
                effectAllowed = e.dataTransfer.effectAllowed.toLowerCase();
            } catch (e) {}
            var dropEffect = "none";
            if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";
            else if (moveAllowed.indexOf(effectAllowed) >= 0) dropEffect = "move";
            else if (copyAllowed.indexOf(effectAllowed) >= 0) dropEffect = "copy";
            return dropEffect;
        }
    }
    (function() {
        this.dragWait = function() {
            var interval = Date.now() - this.mousedownEvent.time;
            if (interval > this.editor.getDragDelay()) this.startDrag();
        };
        this.dragWaitEnd = function() {
            var target = this.editor.container;
            target.draggable = false;
            this.startSelect(this.mousedownEvent.getDocumentPosition());
            this.selectEnd();
        };
        this.dragReadyEnd = function(e) {
            this.editor.$resetCursorStyle();
            this.editor.unsetStyle("ace_dragging");
            this.editor.renderer.setCursorStyle("");
            this.dragWaitEnd();
        };
        this.startDrag = function() {
            this.cancelDrag = false;
            var editor = this.editor;
            var target = editor.container;
            target.draggable = true;
            editor.renderer.$cursorLayer.setBlinking(false);
            editor.setStyle("ace_dragging");
            var cursorStyle = useragent.isWin ? "default" : "move";
            editor.renderer.setCursorStyle(cursorStyle);
            this.setState("dragReady");
        };
        this.onMouseDrag = function(e) {
            var target = this.editor.container;
            if (useragent.isIE && this.state == "dragReady") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 3) target.dragDrop();
            }
            if (this.state === "dragWait") {
                var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
                if (distance > 0) {
                    target.draggable = false;
                    this.startSelect(this.mousedownEvent.getDocumentPosition());
                }
            }
        };
        this.onMouseDown = function(e) {
            if (!this.$dragEnabled) return;
            this.mousedownEvent = e;
            var editor = this.editor;
            var inSelection = e.inSelection();
            var button = e.getButton();
            var clickCount = e.domEvent.detail || 1;
            if (clickCount === 1 && button === 0 && inSelection) {
                if (e.editor.inMultiSelectMode && (e.getAccelKey() || e.getShiftKey())) return;
                this.mousedownEvent.time = Date.now();
                var eventTarget = e.domEvent.target || e.domEvent.srcElement;
                if ("unselectable" in eventTarget) eventTarget.unselectable = "on";
                if (editor.getDragDelay()) {
                    if (useragent.isWebKit) {
                        this.cancelDrag = true;
                        var mouseTarget = editor.container;
                        mouseTarget.draggable = true;
                    }
                    this.setState("dragWait");
                } else this.startDrag();
                this.captureMouse(e, this.onMouseDrag.bind(this));
                e.defaultPrevented = true;
            }
        };
    }).call(DragdropHandler.prototype);
    function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
    }
    exports.DragdropHandler = DragdropHandler;
});
ace.define("ace/mouse/touch_handler", [
    "require",
    "exports",
    "module",
    "ace/mouse/mouse_event",
    "ace/lib/event",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var MouseEvent = require("./mouse_event").MouseEvent;
    var event = require("../lib/event");
    var dom = require("../lib/dom");
    exports.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
            var clipboard = window.navigator && window.navigator.clipboard;
            var isOpen = false;
            var updateMenu = function() {
                var selected = editor.getCopyText();
                var hasUndo = editor.session.getUndoManager().hasUndo();
                contextMenu.replaceChild(dom.buildDom(isOpen ? [
                    "span",
                    !selected && canExecuteCommand("selectall") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "selectall"
                        },
                        "Select All"
                    ],
                    selected && canExecuteCommand("copy") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "copy"
                        },
                        "Copy"
                    ],
                    selected && canExecuteCommand("cut") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "cut"
                        },
                        "Cut"
                    ],
                    clipboard && canExecuteCommand("paste") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "paste"
                        },
                        "Paste"
                    ],
                    hasUndo && canExecuteCommand("undo") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "undo"
                        },
                        "Undo"
                    ],
                    canExecuteCommand("find") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "find"
                        },
                        "Find"
                    ],
                    canExecuteCommand("openCommandPalette") && [
                        "span",
                        {
                            class: "ace_mobile-button",
                            action: "openCommandPalette"
                        },
                        "Palette"
                    ]
                ] : [
                    "span"
                ]), contextMenu.firstChild);
            };
            var canExecuteCommand = function(/** @type {string} */ cmd) {
                return editor.commands.canExecute(cmd, editor);
            };
            var handleClick = function(e) {
                var action = e.target.getAttribute("action");
                if (action == "more" || !isOpen) {
                    isOpen = !isOpen;
                    return updateMenu();
                }
                if (action == "paste") clipboard.readText().then(function(text) {
                    editor.execCommand(action, text);
                });
                else if (action) {
                    if (action == "cut" || action == "copy") {
                        if (clipboard) clipboard.writeText(editor.getCopyText());
                        else document.execCommand("copy");
                    }
                    editor.execCommand(action);
                }
                contextMenu.firstChild.style.display = "none";
                isOpen = false;
                if (action != "openCommandPalette") editor.focus();
            };
            contextMenu = dom.buildDom([
                "div",
                {
                    class: "ace_mobile-menu",
                    ontouchstart: function(e) {
                        mode = "menu";
                        e.stopPropagation();
                        e.preventDefault();
                        editor.textInput.focus();
                    },
                    ontouchend: function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        handleClick(e);
                    },
                    onclick: handleClick
                },
                [
                    "span"
                ],
                [
                    "span",
                    {
                        class: "ace_mobile-button",
                        action: "more"
                    },
                    "..."
                ]
            ], editor.container);
        }
        function showContextMenu() {
            if (!editor.getOption("enableMobileMenu")) {
                if (contextMenu) hideContextMenu();
                return;
            }
            if (!contextMenu) createContextMenu();
            var cursor = editor.selection.cursor;
            var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
            var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
            var scrollLeft = editor.renderer.scrollLeft;
            var rect = editor.container.getBoundingClientRect();
            contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
            if (pagePos.pageX - rect.left < rect.width - 70) {
                contextMenu.style.left = "";
                contextMenu.style.right = "10px";
            } else {
                contextMenu.style.right = "";
                contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
            }
            contextMenu.style.display = "";
            contextMenu.firstChild.style.display = "none";
            editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e) {
            if (contextMenu) contextMenu.style.display = "none";
            editor.off("input", hideContextMenu);
        }
        function handleLongTap() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            var range = editor.selection.getRange();
            var inSelection = range.contains(pos.row, pos.column);
            if (range.isEmpty() || !inSelection) {
                editor.selection.moveToPosition(pos);
                editor.selection.selectWord();
            }
            mode = "wait";
            showContextMenu();
        }
        function switchToSelectionMode() {
            longTouchTimer = null;
            clearTimeout(longTouchTimer);
            editor.selection.moveToPosition(pos);
            var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
            if (range && !range.isEmpty()) editor.selection.setRange(range);
            else editor.selection.selectWord();
            mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e) {
            if (!pressed) return;
            var textarea = editor.textInput.getElement();
            textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function(e) {
            var touches = e.touches;
            if (longTouchTimer || touches.length > 1) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
                touchStartT = -1;
                mode = "zoom";
                return;
            }
            pressed = editor.$mouseHandler.isMousePressed = true;
            var h = editor.renderer.layerConfig.lineHeight;
            var w = editor.renderer.layerConfig.lineHeight;
            var t = e.timeStamp;
            lastT = t;
            var touchObj = touches[0];
            var x = touchObj.clientX;
            var y = touchObj.clientY;
            if (Math.abs(startX - x) + Math.abs(startY - y) > h) touchStartT = -1;
            startX = e.clientX = x;
            startY = e.clientY = y;
            vX = vY = 0;
            var ev = new MouseEvent(e, editor);
            pos = ev.getDocumentPosition();
            if (t - touchStartT < 500 && touches.length == 1 && !animationSteps) {
                clickCount++;
                e.preventDefault();
                e.button = 0;
                switchToSelectionMode();
            } else {
                clickCount = 0;
                var cursor = editor.selection.cursor;
                var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
                var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
                var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
                var rect = editor.renderer.scroller.getBoundingClientRect();
                var offsetTop = editor.renderer.layerConfig.offset;
                var offsetLeft = editor.renderer.scrollLeft;
                var weightedDistance = function(x, y) {
                    x = x / w;
                    y = y / h - 0.75;
                    return x * x + y * y;
                };
                if (e.clientX < rect.left) {
                    mode = "zoom";
                    return;
                }
                var diff1 = weightedDistance(e.clientX - rect.left - cursorPos.left + offsetLeft, e.clientY - rect.top - cursorPos.top + offsetTop);
                var diff2 = weightedDistance(e.clientX - rect.left - anchorPos.left + offsetLeft, e.clientY - rect.top - anchorPos.top + offsetTop);
                if (diff1 < 3.5 && diff2 < 3.5) mode = diff1 > diff2 ? "cursor" : "anchor";
                if (diff2 < 3.5) mode = "anchor";
                else if (diff1 < 3.5) mode = "cursor";
                else mode = "scroll";
                longTouchTimer = setTimeout(handleLongTap, 450);
            }
            touchStartT = t;
        }, editor);
        event.addListener(el, "touchend", function(e) {
            pressed = editor.$mouseHandler.isMousePressed = false;
            if (animationTimer) clearInterval(animationTimer);
            if (mode == "zoom") {
                mode = "";
                animationSteps = 0;
            } else if (longTouchTimer) {
                editor.selection.moveToPosition(pos);
                animationSteps = 0;
                showContextMenu();
            } else if (mode == "scroll") {
                animate();
                hideContextMenu();
            } else showContextMenu();
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function(e) {
            if (longTouchTimer) {
                clearTimeout(longTouchTimer);
                longTouchTimer = null;
            }
            var touches = e.touches;
            if (touches.length > 1 || mode == "zoom") return;
            var touchObj = touches[0];
            var wheelX = startX - touchObj.clientX;
            var wheelY = startY - touchObj.clientY;
            if (mode == "wait") {
                if (wheelX * wheelX + wheelY * wheelY > 4) mode = "cursor";
                else return e.preventDefault();
            }
            startX = touchObj.clientX;
            startY = touchObj.clientY;
            e.clientX = touchObj.clientX;
            e.clientY = touchObj.clientY;
            var t = e.timeStamp;
            var dt = t - lastT;
            lastT = t;
            if (mode == "scroll") {
                var mouseEvent = new MouseEvent(e, editor);
                mouseEvent.speed = 1;
                mouseEvent.wheelX = wheelX;
                mouseEvent.wheelY = wheelY;
                if (10 * Math.abs(wheelX) < Math.abs(wheelY)) wheelX = 0;
                if (10 * Math.abs(wheelY) < Math.abs(wheelX)) wheelY = 0;
                if (dt != 0) {
                    vX = wheelX / dt;
                    vY = wheelY / dt;
                }
                editor._emit("mousewheel", mouseEvent);
                if (!mouseEvent.propagationStopped) vX = vY = 0;
            } else {
                var ev = new MouseEvent(e, editor);
                var pos = ev.getDocumentPosition();
                if (mode == "cursor") editor.selection.moveCursorToPosition(pos);
                else if (mode == "anchor") editor.selection.setSelectionAnchor(pos.row, pos.column);
                editor.renderer.scrollCursorIntoView(pos);
                e.preventDefault();
            }
        }, editor);
        function animate() {
            animationSteps += 60;
            animationTimer = setInterval(function() {
                if (animationSteps-- <= 0) {
                    clearInterval(animationTimer);
                    animationTimer = null;
                }
                if (Math.abs(vX) < 0.01) vX = 0;
                if (Math.abs(vY) < 0.01) vY = 0;
                if (animationSteps < 20) vX = 0.9 * vX;
                if (animationSteps < 20) vY = 0.9 * vY;
                var oldScrollTop = editor.session.getScrollTop();
                editor.renderer.scrollBy(10 * vX, 10 * vY);
                if (oldScrollTop == editor.session.getScrollTop()) animationSteps = 0;
            }, 10);
        }
    };
});
ace.define("ace/mouse/mouse_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent",
    "ace/mouse/default_handlers",
    "ace/mouse/default_gutter_handler",
    "ace/mouse/mouse_event",
    "ace/mouse/dragdrop_handler",
    "ace/mouse/touch_handler",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var DefaultHandlers = require("./default_handlers").DefaultHandlers;
    var DefaultGutterHandler = require("./default_gutter_handler").GutterHandler;
    var MouseEvent = require("./mouse_event").MouseEvent;
    var DragdropHandler = require("./dragdrop_handler").DragdropHandler;
    var addTouchListeners = require("./touch_handler").addTouchListeners;
    var config = require("../config");
    var MouseHandler = /** @class */ function() {
        function MouseHandler(editor) {
            this.$dragDelay;
            this.$dragEnabled;
            this.$mouseMoved;
            this.mouseEvent;
            this.$focusTimeout;
            var _self = this;
            this.editor = editor;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e) {
                var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
                if (windowBlurred) window.focus();
                editor.focus();
                setTimeout(function() {
                    if (!editor.isFocused()) editor.focus();
                });
            };
            var mouseTarget = editor.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
            event.addMultiMouseDownListener([
                mouseTarget,
                editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
                editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
                editor.textInput && editor.textInput.getElement()
            ].filter(Boolean), [
                400,
                300,
                250
            ], this, "onMouseEvent", editor);
            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
            addTouchListeners(editor.container, editor);
            var gutterEl = editor.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor);
            event.addListener(gutterEl, "mousedown", focusEditor, editor);
            if (useragent.isIE && editor.renderer.scrollBarV) {
                event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
                event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
            }
            editor.on("mousemove", function(e) {
                if (_self.state || _self.$dragDelay || !_self.$dragEnabled) return;
                var character = editor.renderer.screenToTextCoordinates(e.x, e.y);
                var range = editor.session.selection.getRange();
                var renderer = editor.renderer;
                if (!range.isEmpty() && range.insideStart(character.row, character.column)) renderer.setCursorStyle("default");
                else renderer.setCursorStyle("");
            }, editor);
        }
        MouseHandler.prototype.onMouseEvent = function(name, e) {
            if (!this.editor.session) return;
            this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        MouseHandler.prototype.onMouseMove = function(name, e) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length) return;
            this.editor._emit(name, new MouseEvent(e, this.editor));
        };
        MouseHandler.prototype.onMouseWheel = function(name, e) {
            var mouseEvent = new MouseEvent(e, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e.wheelX;
            mouseEvent.wheelY = e.wheelY;
            this.editor._emit(name, mouseEvent);
        };
        MouseHandler.prototype.setState = function(state) {
            this.state = state;
        };
        MouseHandler.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self1 = this;
            var continueCapture = true;
            var onMouseMove = function(e) {
                if (!e) return;
                if (useragent.isWebKit && !e.which && self1.releaseMouse) return self1.releaseMouse();
                self1.x = e.clientX;
                self1.y = e.clientY;
                mouseMoveHandler && mouseMoveHandler(e);
                self1.mouseEvent = new MouseEvent(e, self1.editor);
                self1.$mouseMoved = true;
            };
            var onCaptureEnd = function(e) {
                editor.off("beforeEndOperation", onOperationEnd);
                continueCapture = false;
                if (editor.session) onCaptureUpdate();
                self1[self1.state + "End"] && self1[self1.state + "End"](e);
                self1.state = "";
                self1.isMousePressed = renderer.$isMousePressed = false;
                if (renderer.$keepTextAreaAtCursor) renderer.$moveTextAreaToCursor();
                self1.$onCaptureMouseMove = self1.releaseMouse = null;
                e && self1.onMouseEvent("mouseup", e);
                editor.endOperation();
            };
            var onCaptureUpdate = function() {
                self1[self1.state] && self1[self1.state]();
                self1.$mouseMoved = false;
            };
            var onCaptureInterval = function() {
                if (continueCapture) {
                    onCaptureUpdate();
                    event.nextFrame(onCaptureInterval);
                }
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") return setTimeout(function() {
                onCaptureEnd(ev);
            });
            var onOperationEnd = function(e) {
                if (!self1.releaseMouse) return;
                if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                    self1[self1.state + "End"] && self1[self1.state + "End"]();
                    self1.state = "";
                    self1.releaseMouse();
                }
            };
            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({
                command: {
                    name: "mouse"
                }
            });
            self1.$onCaptureMouseMove = onMouseMove;
            self1.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            onCaptureInterval();
        };
        MouseHandler.prototype.cancelContextMenu = function() {
            var stop = (function(e) {
                if (e && e.domEvent && e.domEvent.type != "contextmenu") return;
                this.editor.off("nativecontextmenu", stop);
                if (e && e.domEvent) event.stopEvent(e.domEvent);
            }).bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
        };
        MouseHandler.prototype.destroy = function() {
            if (this.releaseMouse) this.releaseMouse();
        };
        return MouseHandler;
    }();
    MouseHandler.prototype.releaseMouse = null;
    config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: {
            initialValue: 2
        },
        dragDelay: {
            initialValue: useragent.isMac ? 150 : 0
        },
        dragEnabled: {
            initialValue: true
        },
        focusTimeout: {
            initialValue: 0
        },
        tooltipFollowsMouse: {
            initialValue: true
        }
    });
    exports.MouseHandler = MouseHandler;
});
ace.define("ace/mouse/fold_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var FoldHandler = /** @class */ function() {
        function FoldHandler(editor) {
            editor.on("click", function(e) {
                var position = e.getDocumentPosition();
                var session = editor.session;
                var fold = session.getFoldAt(position.row, position.column, 1);
                if (fold) {
                    if (e.getAccelKey()) session.removeFold(fold);
                    else session.expandFold(fold);
                    e.stop();
                }
                var target = e.domEvent && e.domEvent.target;
                if (target && dom.hasCssClass(target, "ace_inline_button")) {
                    if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                        session.setOption("wrap", !session.getUseWrapMode());
                        editor.renderer.scrollCursorIntoView();
                    }
                }
            });
            editor.on("gutterclick", function(e) {
                var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                if (gutterRegion == "foldWidgets") {
                    var row = e.getDocumentPosition().row;
                    var session = editor.session;
                    if (session.foldWidgets && session.foldWidgets[row]) editor.session.onFoldWidgetClick(row, e);
                    if (!editor.isFocused()) editor.focus();
                    e.stop();
                }
            });
            editor.on("gutterdblclick", function(e) {
                var gutterRegion = editor.renderer.$gutterLayer.getRegion(e);
                if (gutterRegion == "foldWidgets") {
                    var row = e.getDocumentPosition().row;
                    var session = editor.session;
                    var data = session.getParentFoldRangeData(row, true);
                    var range = data.range || data.firstRange;
                    if (range) {
                        row = range.start.row;
                        var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                        if (fold) session.removeFold(fold);
                        else {
                            session.addFold("...", range);
                            editor.renderer.scrollCursorIntoView({
                                row: range.start.row,
                                column: 0
                            });
                        }
                    }
                    e.stop();
                }
            });
        }
        return FoldHandler;
    }();
    exports.FoldHandler = FoldHandler;
});
ace.define("ace/keyboard/keybinding", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/event"
], function(require, exports, module1) {
    "use strict";
    var keyUtil = require("../lib/keys");
    var event = require("../lib/event");
    var KeyBinding = /** @class */ function() {
        function KeyBinding(editor) {
            this.$editor = editor;
            this.$data = {
                editor: editor
            };
            this.$handlers = [];
            this.setDefaultHandler(editor.commands);
        }
        KeyBinding.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
        };
        KeyBinding.prototype.setKeyboardHandler = function(kb) {
            var h = this.$handlers;
            if (h[h.length - 1] == kb) return;
            while(h[h.length - 1] && h[h.length - 1] != this.$defaultHandler)this.removeKeyboardHandler(h[h.length - 1]);
            this.addKeyboardHandler(kb, 1);
        };
        KeyBinding.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb) return;
            if (typeof kb == "function" && !kb.handleKeyboard) kb.handleKeyboard = kb;
            var i = this.$handlers.indexOf(kb);
            if (i != -1) this.$handlers.splice(i, 1);
            if (pos == undefined) this.$handlers.push(kb);
            else this.$handlers.splice(pos, 0, kb);
            if (i == -1 && kb.attach) kb.attach(this.$editor);
        };
        KeyBinding.prototype.removeKeyboardHandler = function(kb) {
            var i = this.$handlers.indexOf(kb);
            if (i == -1) return false;
            this.$handlers.splice(i, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
        };
        KeyBinding.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
        };
        KeyBinding.prototype.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h) {
                return h.getStatusText && h.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
        };
        KeyBinding.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for(var i = this.$handlers.length; i--;){
                toExecute = this.$handlers[i].handleKeyboard(this.$data, hashId, keyString, keyCode, e);
                if (!toExecute || !toExecute.command) continue;
                if (toExecute.command == "null") success = true;
                else success = commands.exec(toExecute.command, this.$editor, toExecute.args, e);
                if (success && e && hashId != -1 && toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) event.stopEvent(e);
                if (success) break;
            }
            if (!success && hashId == -1) {
                toExecute = {
                    command: "insertstring"
                };
                success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal) this.$editor._signal("keyboardActivity", toExecute);
            return success;
        };
        KeyBinding.prototype.onCommandKey = function(e, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e);
        };
        KeyBinding.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
        };
        return KeyBinding;
    }();
    exports.KeyBinding = KeyBinding;
});
ace.define("ace/lib/bidiutil", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var ArabicAlefBetIntervalsBegine = [
        "ÿ°",
        "ŸÅ"
    ];
    var ArabicAlefBetIntervalsEnd = [
        "ÿ∫",
        "Ÿä"
    ];
    var dir = 0, hiLevel = 0;
    var lastArabic = false, hasUBAT_AL = false, hasUBAT_B = false, hasUBAT_S = false, hasBlockSep = false, hasSegSep = false;
    var impTab_LTR = [
        [
            0,
            3,
            0,
            1,
            0,
            0,
            0
        ],
        [
            0,
            3,
            0,
            1,
            2,
            2,
            0
        ],
        [
            0,
            3,
            0,
            0x11,
            2,
            0,
            1
        ],
        [
            0,
            3,
            5,
            5,
            4,
            1,
            0
        ],
        [
            0,
            3,
            0x15,
            0x15,
            4,
            0,
            1
        ],
        [
            0,
            3,
            5,
            5,
            4,
            2,
            0
        ]
    ];
    var impTab_RTL = [
        [
            2,
            0,
            1,
            1,
            0,
            1,
            0
        ],
        [
            2,
            0,
            1,
            1,
            0,
            2,
            0
        ],
        [
            2,
            0,
            2,
            1,
            3,
            2,
            0
        ],
        [
            2,
            0,
            2,
            0x21,
            3,
            1,
            1
        ]
    ];
    var LTR = 0, RTL = 1;
    var L = 0;
    var R = 1;
    var EN = 2;
    var AN = 3;
    var ON = 4;
    var B = 5;
    var S = 6;
    var AL = 7;
    var WS = 8;
    var CS = 9;
    var ES = 10;
    var ET = 11;
    var NSM = 12;
    var LRE = 13;
    var RLE = 14;
    var PDF = 15;
    var LRO = 16;
    var RLO = 17;
    var BN = 18;
    var UnicodeTBL00 = [
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        S,
        B,
        S,
        WS,
        B,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B,
        B,
        B,
        S,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        L,
        ON,
        ON,
        ON,
        ON,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L,
        ON,
        ON,
        BN,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L,
        ON,
        ON,
        ON,
        EN,
        L,
        ON,
        ON,
        ON,
        ON,
        ON
    ];
    var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN,
        BN,
        BN,
        L,
        R,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
    ];
    function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i = null, ix = null, classes = [];
        if (!charTypes) for(i = 0, charTypes = []; i < len; i++)charTypes[i] = _getCharacterType(chars[i]);
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_AL = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for(ix = 0; ix < len; ix++){
            prevState = newState;
            classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
            newState = impTab[prevState][newClass];
            action = newState & 0xF0;
            newState &= 0x0F;
            levels[ix] = newLevel = impTab[newState][5];
            if (action > 0) {
                if (action == 0x10) {
                    for(i = condPos; i < ix; i++)levels[i] = 1;
                    condPos = -1;
                } else condPos = -1;
            }
            cond = impTab[newState][6];
            if (cond) {
                if (condPos == -1) condPos = ix;
            } else if (condPos > -1) {
                for(i = condPos; i < ix; i++)levels[i] = newLevel;
                condPos = -1;
            }
            if (charTypes[ix] == B) levels[ix] = 0;
            hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
            for(i = 0; i < len; i++)if (charTypes[i] == S) {
                levels[i] = dir;
                for(var j = i - 1; j >= 0; j--){
                    if (charTypes[j] == WS) levels[j] = dir;
                    else break;
                }
            }
        }
    }
    function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) return;
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
            _array.reverse();
            return;
        }
        var len = _array.length, start = 0, end, lo, hi, tmp;
        while(start < len){
            if (levels[start] >= lev) {
                end = start + 1;
                while(end < len && levels[end] >= lev)end++;
                for(lo = start, hi = end - 1; lo < hi; lo++, hi--){
                    tmp = _array[lo];
                    _array[lo] = _array[hi];
                    _array[hi] = tmp;
                }
                start = end;
            }
            start++;
        }
    }
    function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i;
        switch(cType){
            case L:
            case R:
                lastArabic = false;
            case ON:
            case AN:
                return cType;
            case EN:
                return lastArabic ? AN : EN;
            case AL:
                lastArabic = true;
                hasUBAT_AL = true;
                return R;
            case WS:
                return ON;
            case CS:
                if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) return ON;
                if (lastArabic) nType = AN;
                return nType == wType ? nType : ON;
            case ES:
                wType = ix > 0 ? classes[ix - 1] : B;
                if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) return EN;
                return ON;
            case ET:
                if (ix > 0 && classes[ix - 1] == EN) return EN;
                if (lastArabic) return ON;
                i = ix + 1;
                len = types.length;
                while(i < len && types[i] == ET)i++;
                if (i < len && types[i] == EN) return EN;
                return ON;
            case NSM:
                len = types.length;
                i = ix + 1;
                while(i < len && types[i] == NSM)i++;
                if (i < len) {
                    var c = chars[ix], rtlCandidate = c >= 0x0591 && c <= 0x08FF || c == 0xFB1E;
                    wType = types[i];
                    if (rtlCandidate && (wType == R || wType == AL)) return R;
                }
                if (ix < 1 || (wType = types[ix - 1]) == B) return ON;
                return classes[ix - 1];
            case B:
                lastArabic = false;
                hasUBAT_B = true;
                return dir;
            case S:
                hasUBAT_S = true;
                return ON;
            case LRE:
            case RLE:
            case LRO:
            case RLO:
            case PDF:
                lastArabic = false;
            case BN:
                return ON;
        }
    }
    function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0), hi = uc >> 8;
        if (hi == 0) return uc > 0x00BF ? L : UnicodeTBL00[uc];
        else if (hi == 5) return /[\u0591-\u05f4]/.test(ch) ? R : L;
        else if (hi == 6) {
            if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch)) return NSM;
            else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch)) return AN;
            else if (uc == 0x066A) return ET;
            else if (/[\u06f0-\u06f9]/.test(ch)) return EN;
            else return AL;
        } else if (hi == 0x20 && uc <= 0x205F) return UnicodeTBL20[uc & 0xFF];
        else if (hi == 0xFE) return uc >= 0xFE70 ? AL : ON;
        return ON;
    }
    function _isArabicDiacritics(ch) {
        return ch >= "Ÿã" && ch <= "Ÿï";
    }
    exports.L = L;
    exports.R = R;
    exports.EN = EN;
    exports.ON_R = 3;
    exports.AN = 4;
    exports.R_H = 5;
    exports.B = 6;
    exports.RLE = 7;
    exports.DOT = "\xb7";
    exports.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2) return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for(var i = 0; i < logicalFromVisual.length; logicalFromVisual[i] = i, i++);
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for(var i = 0; i < logicalFromVisual.length - 1; i++){
            if (textCharTypes[i] === AN) levels[i] = exports.AN;
            else if (levels[i] === R && (textCharTypes[i] > AL && textCharTypes[i] < LRE || textCharTypes[i] === ON || textCharTypes[i] === BN)) levels[i] = exports.ON_R;
            else if (i > 0 && chars[i - 1] === "ŸÑ" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i])) {
                levels[i - 1] = levels[i] = exports.R_H;
                i++;
            }
        }
        if (chars[chars.length - 1] === exports.DOT) levels[chars.length - 1] = exports.B;
        if (chars[0] === "‚Ä´") levels[0] = exports.RLE;
        for(var i = 0; i < logicalFromVisual.length; i++)bidiLevels[i] = levels[logicalFromVisual[i]];
        return {
            "logicalFromVisual": logicalFromVisual,
            "bidiLevels": bidiLevels
        };
    };
    exports.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for(var i = 0; i < text.length; i++){
            textCharTypes[i] = _getCharacterType(text.charAt(i));
            if (!ret && (textCharTypes[i] == R || textCharTypes[i] == AL || textCharTypes[i] == AN)) ret = true;
        }
        return ret;
    };
    exports.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for(var i = 0; i < rowMap.logicalFromVisual.length; i++){
            if (rowMap.logicalFromVisual[i] == logIdx) return i;
        }
        return 0;
    };
});
ace.define("ace/bidihandler", [
    "require",
    "exports",
    "module",
    "ace/lib/bidiutil",
    "ace/lib/lang"
], function(require, exports, module1) {
    "use strict";
    var bidiUtil = require("./lib/bidiutil");
    var lang = require("./lib/lang");
    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
    var BidiHandler = /** @class */ function() {
        function BidiHandler(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "\xac";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "\xb6";
            this.RLE = "‚Ä´";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
        }
        BidiHandler.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi) return false;
            if (screenRow !== this.currentRow) {
                this.currentRow = screenRow;
                this.updateRowLine(docRow, splitIndex);
                this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
        };
        BidiHandler.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
                if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                    this.seenBidi = true;
                    this.currentRow = null;
                }
            } else this.currentRow = null;
        };
        BidiHandler.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                if (index >= 0) docRow = this.session.$docRowCache[index];
            }
            return docRow;
        };
        BidiHandler.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
                var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
                while(this.currentRow - splitIndex > 0){
                    currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                    if (currentIndex !== prevIndex) break;
                    prevIndex = currentIndex;
                    splitIndex++;
                }
            } else splitIndex = this.currentRow;
            return splitIndex;
        };
        BidiHandler.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === undefined) docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
                var splits = this.session.$wrapData[docRow];
                if (splits) {
                    if (splitIndex === undefined) splitIndex = this.getSplitIndex();
                    if (splitIndex > 0 && splits.length) {
                        this.wrapIndent = splits.indent;
                        this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                        this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                    } else this.line = this.line.substring(0, splits[splitIndex]);
                    if (splitIndex == splits.length) this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
            } else this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i) {
                if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                    size = ch === "	" ? session.getScreenTabSize(i + shift) : 2;
                    shift += size - 1;
                    return lang.stringRepeat(bidiUtil.DOT, size);
                }
                return ch;
            });
            if (this.isRtlDir) {
                this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
                this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
        };
        BidiHandler.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            else this.bidiMap = {};
        };
        BidiHandler.prototype.markAsDirty = function() {
            this.currentRow = null;
        };
        BidiHandler.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width) return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("◊î");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
        };
        BidiHandler.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
        };
        BidiHandler.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
        };
        BidiHandler.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
        };
        BidiHandler.prototype.isRtlLine = function(row) {
            if (this.$isRtl) return true;
            if (row != undefined) return this.session.getLine(row).charAt(0) == this.RLE;
            else return this.isRtlDir;
        };
        BidiHandler.prototype.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition();
            for(var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++){
                if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE) editor.session.doc.removeInLine(row, 0, 1);
                else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE) editor.session.doc.insert({
                    column: 0,
                    row: row
                }, editor.session.$bidiHandler.RLE);
            }
        };
        BidiHandler.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0) visualIdx++;
            for(var i = 0; i < visualIdx; i++)left += this.charWidths[levels[i]];
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0) left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent) left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir) left += this.rtlLineOffset;
            return left;
        };
        BidiHandler.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent) offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for(var logIdx, visIdx = 0; visIdx < levels.length; visIdx++){
                logIdx = map.logicalFromVisual[visIdx];
                level = levels[visIdx];
                isSelected = logIdx >= selColMin && logIdx < selColMax;
                if (isSelected && !isSelectedPrev) selectionStart = offset;
                else if (!isSelected && isSelectedPrev) selections.push({
                    left: selectionStart,
                    width: offset - selectionStart
                });
                offset += this.charWidths[level];
                isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) selections.push({
                left: selectionStart,
                width: offset - selectionStart
            });
            if (this.isRtlDir) for(var i = 0; i < selections.length; i++)selections[i].left += this.rtlLineOffset;
            return selections;
        };
        BidiHandler.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir) posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent) posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while(posX > offset + charWidth / 2){
                offset += charWidth;
                if (visualIdx === levels.length - 1) {
                    charWidth = 0;
                    break;
                }
                charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
                if (posX < offset) visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            else {
                if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0) visualIdx--;
                logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir) logicalIdx++;
            return logicalIdx + this.wrapIndent;
        };
        return BidiHandler;
    }();
    exports.BidiHandler = BidiHandler;
});
ace.define("ace/selection", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/lib/event_emitter",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Selection = /** @class */ function() {
        function Selection(session) {
            this.session = session;
            this.doc = session.getDocument();
            this.clearSelection();
            this.cursor = this.lead = this.doc.createAnchor(0, 0);
            this.anchor = this.doc.createAnchor(0, 0);
            this.$silent = false;
            var self1 = this;
            this.cursor.on("change", function(e) {
                self1.$cursorChanged = true;
                if (!self1.$silent) self1._emit("changeCursor");
                if (!self1.$isEmpty && !self1.$silent) self1._emit("changeSelection");
                if (!self1.$keepDesiredColumnOnChange && e.old.column != e.value.column) self1.$desiredColumn = null;
            });
            this.anchor.on("change", function() {
                self1.$anchorChanged = true;
                if (!self1.$isEmpty && !self1.$silent) self1._emit("changeSelection");
            });
        }
        Selection.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        };
        Selection.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
        };
        Selection.prototype.getCursor = function() {
            return this.lead.getPosition();
        };
        Selection.prototype.setAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
        };
        Selection.prototype.getAnchor = function() {
            if (this.$isEmpty) return this.getSelectionLead();
            return this.anchor.getPosition();
        };
        Selection.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
        };
        Selection.prototype.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
        };
        Selection.prototype.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.$isEmpty) return Range.fromPoints(lead, lead);
            return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
        };
        Selection.prototype.clearSelection = function() {
            if (!this.$isEmpty) {
                this.$isEmpty = true;
                this._emit("changeSelection");
            }
        };
        Selection.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        };
        Selection.prototype.setRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
        };
        Selection.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent) return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged) this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect) this._emit("changeSelection");
        };
        Selection.prototype.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty) this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
        };
        Selection.prototype.selectTo = function(row, column) {
            this.$moveSelection(function() {
                this.moveCursorTo(row, column);
            });
        };
        Selection.prototype.selectToPosition = function(pos) {
            this.$moveSelection(function() {
                this.moveCursorToPosition(pos);
            });
        };
        Selection.prototype.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
        };
        Selection.prototype.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
        };
        Selection.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
        };
        Selection.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
        };
        Selection.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
        };
        Selection.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
        };
        Selection.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
        };
        Selection.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
        };
        Selection.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
        };
        Selection.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
        };
        Selection.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
        };
        Selection.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
        };
        Selection.prototype.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
                var cursor = row || this.lead;
                row = cursor.row;
                column = cursor.column;
            }
            return this.session.getWordRange(row, column);
        };
        Selection.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
        };
        Selection.prototype.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
        };
        Selection.prototype.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
                rowStart = foldLine.start.row;
                rowEnd = foldLine.end.row;
            } else rowEnd = rowStart;
            if (excludeLastChar === true) return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else return new Range(rowStart, 0, rowEnd + 1, 0);
        };
        Selection.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
        };
        Selection.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
        };
        Selection.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
        };
        Selection.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
                start = cursor.column - tabSize;
                end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
        };
        Selection.prototype.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) this.moveCursorTo(fold.start.row, fold.start.column);
            else if (cursor.column === 0) {
                if (cursor.row > 0) this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
            } else {
                var tabSize = this.session.getTabSize();
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) this.moveCursorBy(0, -tabSize);
                else this.moveCursorBy(0, -1);
            }
        };
        Selection.prototype.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) this.moveCursorTo(fold.end.row, fold.end.column);
            else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
                if (this.lead.row < this.doc.getLength() - 1) this.moveCursorTo(this.lead.row + 1, 0);
            } else {
                var tabSize = this.session.getTabSize();
                var cursor = this.lead;
                if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) this.moveCursorBy(0, tabSize);
                else this.moveCursorBy(0, 1);
            }
        };
        Selection.prototype.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart) firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
        };
        Selection.prototype.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
                var line = this.session.getLine(lineEnd.row);
                if (lineEnd.column == line.length) {
                    var textEnd = line.search(/\s+$/);
                    if (textEnd > 0) lineEnd.column = textEnd;
                }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
        };
        Selection.prototype.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
        };
        Selection.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
        };
        Selection.prototype.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                this.moveCursorTo(fold.end.row, fold.end.column);
                return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
                column += this.session.nonTokenRe.lastIndex;
                this.session.nonTokenRe.lastIndex = 0;
                rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
                this.moveCursorTo(row, line.length);
                this.moveCursorRight();
                if (row < this.doc.getLength() - 1) this.moveCursorWordRight();
                return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
                column += this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
        };
        Selection.prototype.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
                this.moveCursorTo(fold.start.row, fold.start.column);
                return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) str = this.doc.getLine(row).substring(0, column);
            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
                column -= this.session.nonTokenRe.lastIndex;
                leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
                this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
                this.moveCursorTo(row, 0);
                this.moveCursorLeft();
                if (row > 0) this.moveCursorWordLeft();
                return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
                column -= this.session.tokenRe.lastIndex;
                this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
        };
        Selection.prototype.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) index = this.session.tokenRe.lastIndex;
            else {
                while((ch = rightOfCursor[index]) && whitespaceRe.test(ch))index++;
                if (index < 1) {
                    tokenRe.lastIndex = 0;
                    while((ch = rightOfCursor[index]) && !tokenRe.test(ch)){
                        tokenRe.lastIndex = 0;
                        index++;
                        if (whitespaceRe.test(ch)) {
                            if (index > 2) {
                                index--;
                                break;
                            } else {
                                while((ch = rightOfCursor[index]) && whitespaceRe.test(ch))index++;
                                if (index > 2) break;
                            }
                        }
                    }
                }
            }
            tokenRe.lastIndex = 0;
            return index;
        };
        Selection.prototype.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) return this.moveCursorTo(fold.end.row, fold.end.column);
            if (column == line.length) {
                var l = this.doc.getLength();
                do {
                    row++;
                    rightOfCursor = this.doc.getLine(row);
                }while (row < l && /^\s*$/.test(rightOfCursor));
                if (!/^\s+/.test(rightOfCursor)) rightOfCursor = "";
                column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
        };
        Selection.prototype.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) return this.moveCursorTo(fold.start.row, fold.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
                do {
                    row--;
                    line = this.doc.getLine(row);
                }while (row > 0 && /^\s*$/.test(line));
                column = line.length;
                if (!/\s+$/.test(line)) line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
        };
        Selection.prototype.moveCursorWordRight = function() {
            if (this.session.$selectLongWords) this.moveCursorLongWordRight();
            else this.moveCursorShortWordRight();
        };
        Selection.prototype.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords) this.moveCursorLongWordLeft();
            else this.moveCursorShortWordLeft();
        };
        Selection.prototype.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
            var offsetX;
            if (chars === 0) {
                if (rows !== 0) {
                    if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                        offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                        screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                    } else offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
                if (this.$desiredColumn) screenPos.column = this.$desiredColumn;
                else this.$desiredColumn = screenPos.column;
            }
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
                var widget = this.session.lineWidgets[this.lead.row];
                if (rows < 0) rows -= widget.rowsAbove || 0;
                else if (rows > 0) rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            rows !== 0 && chars === 0 && docPos.row === this.lead.row && (docPos.column, this.lead.column);
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
        };
        Selection.prototype.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
        };
        Selection.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
                row = fold.start.row;
                column = fold.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
                if (this.lead.row == row && this.lead.column == column + 1) column = column - 1;
                else column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn) this.$desiredColumn = null;
        };
        Selection.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
        };
        Selection.prototype.detach = function() {
            this.lead.detach();
            this.anchor.detach();
        };
        Selection.prototype.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
        };
        Selection.prototype.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
                range.start.column = r.start.column;
                range.start.row = r.start.row;
                range.end.column = r.end.column;
                range.end.row = r.end.row;
            } else range = r;
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
        };
        Selection.prototype.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
                func(this);
                var end = this.getCursor();
                return Range.fromPoints(start, end);
            } catch (e) {
                return Range.fromPoints(start, start);
            } finally{
                this.moveCursorToPosition(start);
            }
        };
        Selection.prototype.toJSON = function() {
            if (this.rangeCount) var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
            });
            else {
                var data = this.getRange();
                data.isBackwards = this.isBackwards();
            }
            return data;
        };
        Selection.prototype.fromJSON = function(data) {
            if (data.start == undefined) {
                if (this.rangeList && data.length > 1) {
                    this.toSingleRange(data[0]);
                    for(var i = data.length; i--;){
                        var r = Range.fromPoints(data[i].start, data[i].end);
                        if (data[i].isBackwards) r.cursor = r.start;
                        this.addRange(r, true);
                    }
                    return;
                } else data = data[0];
            }
            if (this.rangeList) this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
        };
        Selection.prototype.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount) return false;
            if (!data.length || !this.ranges) return this.getRange().isEqual(data);
            for(var i = this.ranges.length; i--;){
                if (!this.ranges[i].isEqual(data[i])) return false;
            }
            return true;
        };
        return Selection;
    }();
    Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
    Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
    Selection.prototype.setSelectionRange = Selection.prototype.setRange;
    oop.implement(Selection.prototype, EventEmitter);
    exports.Selection = Selection;
});
ace.define("ace/tokenizer", [
    "require",
    "exports",
    "module",
    "ace/lib/report_error"
], function(require, exports, module1) {
    "use strict";
    var reportError = require("./lib/report_error").reportError;
    var MAX_TOKEN_COUNT = 2000;
    var Tokenizer = /** @class */ function() {
        function Tokenizer(rules) {
            this.splitRegex;
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for(var key in this.states){
                var state = this.states[key];
                var ruleRegExps = [];
                var matchTotal = 0;
                var mapping = this.matchMappings[key] = {
                    defaultToken: "text"
                };
                var flag = "g";
                var splitterRurles = [];
                for(var i = 0; i < state.length; i++){
                    var rule = state[i];
                    if (rule.defaultToken) mapping.defaultToken = rule.defaultToken;
                    if (rule.caseInsensitive && flag.indexOf("i") === -1) flag += "i";
                    if (rule.unicode && flag.indexOf("u") === -1) flag += "u";
                    if (rule.regex == null) continue;
                    if (rule.regex instanceof RegExp) rule.regex = rule.regex.toString().slice(1, -1);
                    var adjustedregex = rule.regex;
                    var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                    if (Array.isArray(rule.token)) {
                        if (rule.token.length == 1 || matchcount == 1) rule.token = rule.token[0];
                        else if (matchcount - 1 != rule.token.length) {
                            this.reportError("number of classes and regexp groups doesn't match", {
                                rule: rule,
                                groupCount: matchcount - 1
                            });
                            rule.token = rule.token[0];
                        } else {
                            rule.tokenArray = rule.token;
                            rule.token = null;
                            rule.onMatch = this.$arrayTokens;
                        }
                    } else if (typeof rule.token == "function" && !rule.onMatch) {
                        if (matchcount > 1) rule.onMatch = this.$applyToken;
                        else rule.onMatch = rule.token;
                    }
                    if (matchcount > 1) {
                        if (/\\\d/.test(rule.regex)) adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match, digit) {
                            return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                        });
                        else {
                            matchcount = 1;
                            adjustedregex = this.removeCapturingGroups(rule.regex);
                        }
                        if (!rule.splitRegex && typeof rule.token != "string") splitterRurles.push(rule); // flag will be known only at the very end
                    }
                    mapping[matchTotal] = i;
                    matchTotal += matchcount;
                    ruleRegExps.push(adjustedregex);
                    if (!rule.onMatch) rule.onMatch = null;
                }
                if (!ruleRegExps.length) {
                    mapping[0] = 0;
                    ruleRegExps.push("$");
                }
                splitterRurles.forEach(function(rule) {
                    rule.splitRegex = this.createSplitterRegexp(rule.regex, flag);
                }, this);
                this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
        }
        Tokenizer.prototype.$setMaxTokenCount = function(m) {
            MAX_TOKEN_COUNT = m | 0;
        };
        Tokenizer.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string") return [
                {
                    type: types,
                    value: str
                }
            ];
            var tokens = [];
            for(var i = 0, l = types.length; i < l; i++)if (values[i]) tokens[tokens.length] = {
                type: types[i],
                value: values[i]
            };
            return tokens;
        };
        Tokenizer.prototype.$arrayTokens = function(str) {
            if (!str) return [];
            var values = this.splitRegex.exec(str);
            if (!values) return "text";
            var tokens = [];
            var types = this.tokenArray;
            for(var i = 0, l = types.length; i < l; i++)if (values[i + 1]) tokens[tokens.length] = {
                type: types[i],
                value: values[i + 1]
            };
            return tokens;
        };
        Tokenizer.prototype.removeCapturingGroups = function(src) {
            var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x, y) {
                return y ? "(?:" : x;
            });
            return r;
        };
        Tokenizer.prototype.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
                var stack = 0;
                var inChClass = false;
                var lastCapture = {};
                src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m, esc, parenOpen, parenClose, square, index) {
                    if (inChClass) inChClass = square != "]";
                    else if (square) inChClass = true;
                    else if (parenClose) {
                        if (stack == lastCapture.stack) {
                            lastCapture.end = index + 1;
                            lastCapture.stack = -1;
                        }
                        stack--;
                    } else if (parenOpen) {
                        stack++;
                        if (parenOpen.length != 1) {
                            lastCapture.stack = stack;
                            lastCapture.start = index;
                        }
                    }
                    return m;
                });
                if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end))) src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^") src = "^" + src;
            if (src.charAt(src.length - 1) != "$") src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
        };
        Tokenizer.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
                var stack = startState.slice(0);
                startState = stack[0];
                if (startState === "#tmp") {
                    stack.shift();
                    startState = stack.shift();
                }
            } else var stack = [];
            var currentState = /**@type{string}*/ startState || "start";
            var state = this.states[currentState];
            if (!state) {
                currentState = "start";
                state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re = this.regExps[currentState];
            re.lastIndex = 0;
            var match, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = {
                type: null,
                value: ""
            };
            while(match = re.exec(line)){
                var type = mapping.defaultToken;
                var rule = null;
                var value = match[0];
                var index = re.lastIndex;
                if (index - value.length > lastIndex) {
                    var skipped = line.substring(lastIndex, index - value.length);
                    if (token.type == type) token.value += skipped;
                    else {
                        if (token.type) tokens.push(token);
                        token = {
                            type: type,
                            value: skipped
                        };
                    }
                }
                for(var i = 0; i < match.length - 2; i++){
                    if (match[i + 1] === undefined) continue;
                    rule = state[mapping[i]];
                    if (rule.onMatch) type = rule.onMatch(value, currentState, stack, line);
                    else type = rule.token;
                    if (rule.next) {
                        if (typeof rule.next == "string") currentState = rule.next;
                        else currentState = rule.next(currentState, stack);
                        state = this.states[currentState];
                        if (!state) {
                            this.reportError("state doesn't exist", currentState);
                            currentState = "start";
                            state = this.states[currentState];
                        }
                        mapping = this.matchMappings[currentState];
                        lastIndex = index;
                        re = this.regExps[currentState];
                        re.lastIndex = index;
                    }
                    if (rule.consumeLineEnd) lastIndex = index;
                    break;
                }
                if (value) {
                    if (typeof type === "string") {
                        if ((!rule || rule.merge !== false) && token.type === type) token.value += value;
                        else {
                            if (token.type) tokens.push(token);
                            token = {
                                type: type,
                                value: value
                            };
                        }
                    } else if (type) {
                        if (token.type) tokens.push(token);
                        token = {
                            type: null,
                            value: ""
                        };
                        for(var i = 0; i < type.length; i++)tokens.push(type[i]);
                    }
                }
                if (lastIndex == line.length) break;
                lastIndex = index;
                if (matchAttempts++ > MAX_TOKEN_COUNT) {
                    if (matchAttempts > 2 * line.length) this.reportError("infinite loop with in ace tokenizer", {
                        startState: startState,
                        line: line
                    });
                    while(lastIndex < line.length){
                        if (token.type) tokens.push(token);
                        token = {
                            value: line.substring(lastIndex, lastIndex += 500),
                            type: "overflow"
                        };
                    }
                    currentState = "start";
                    stack = [];
                    break;
                }
            }
            if (token.type) tokens.push(token);
            if (stack.length > 1) {
                if (stack[0] !== currentState) stack.unshift("#tmp", currentState);
            }
            return {
                tokens: tokens,
                state: stack.length ? stack : currentState
            };
        };
        return Tokenizer;
    }();
    Tokenizer.prototype.reportError = reportError;
    exports.Tokenizer = Tokenizer;
});
ace.define("ace/mode/text_highlight_rules", [
    "require",
    "exports",
    "module",
    "ace/lib/deep_copy"
], function(require, exports, module1) {
    "use strict";
    var deepCopy = require("../lib/deep_copy").deepCopy;
    var TextHighlightRules;
    TextHighlightRules = function() {
        this.$rules = {
            "start": [
                {
                    token: "empty_line",
                    regex: "^$"
                },
                {
                    defaultToken: "text"
                }
            ]
        };
    };
    (function() {
        this.addRules = function(rules, prefix) {
            if (!prefix) {
                for(var key in rules)this.$rules[key] = rules[key];
                return;
            }
            for(var key in rules){
                var state = rules[key];
                for(var i = 0; i < state.length; i++){
                    var rule = state[i];
                    if (rule.next || rule.onMatch) {
                        if (typeof rule.next == "string") {
                            if (rule.next.indexOf(prefix) !== 0) rule.next = prefix + rule.next;
                        }
                        if (rule.nextState && rule.nextState.indexOf(prefix) !== 0) rule.nextState = prefix + rule.nextState;
                    }
                }
                this.$rules[prefix + key] = state;
            }
        };
        this.getRules = function() {
            return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
            var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
            if (states) for(var i = 0; i < states.length; i++)states[i] = prefix + states[i];
            else {
                states = [];
                for(var key in embedRules)states.push(prefix + key);
            }
            this.addRules(embedRules, prefix);
            if (escapeRules) {
                var addRules = Array.prototype[append ? "push" : "unshift"];
                for(var i = 0; i < states.length; i++)addRules.apply(this.$rules[states[i]], deepCopy(escapeRules));
            }
            if (!this.$embeds) this.$embeds = [];
            this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
            return this.$embeds;
        };
        var pushState = function(currentState, stack) {
            if (currentState != "start" || stack.length) stack.unshift(this.nextState, currentState);
            return this.nextState;
        };
        var popState = function(currentState, stack) {
            stack.shift();
            return stack.shift() || "start";
        };
        this.normalizeRules = function() {
            var id = 0;
            var rules = this.$rules;
            function processState(key) {
                var state = rules[key];
                state["processed"] = true;
                for(var i = 0; i < state.length; i++){
                    var rule = state[i];
                    var toInsert = null;
                    if (Array.isArray(rule)) {
                        toInsert = rule;
                        rule = {};
                    }
                    if (!rule.regex && rule.start) {
                        rule.regex = rule.start;
                        if (!rule.next) rule.next = [];
                        rule.next.push({
                            defaultToken: rule.token
                        }, {
                            token: rule.token + ".end",
                            regex: rule.end || rule.start,
                            next: "pop"
                        });
                        rule.token = rule.token + ".start";
                        rule.push = true;
                    }
                    var next = rule.next || rule.push;
                    if (next && Array.isArray(next)) {
                        var stateName = rule.stateName;
                        if (!stateName) {
                            stateName = rule.token;
                            if (typeof stateName != "string") stateName = stateName[0] || "";
                            if (rules[stateName]) stateName += id++;
                        }
                        rules[stateName] = next;
                        rule.next = stateName;
                        processState(stateName);
                    } else if (next == "pop") rule.next = popState;
                    if (rule.push) {
                        rule.nextState = rule.next || rule.push;
                        rule.next = pushState;
                        delete rule.push;
                    }
                    if (rule.rules) for(var r in rule.rules){
                        if (rules[r]) {
                            if (rules[r].push) rules[r].push.apply(rules[r], rule.rules[r]);
                        } else rules[r] = rule.rules[r];
                    }
                    var includeName = typeof rule == "string" ? rule : rule.include;
                    if (includeName) {
                        if (includeName === "$self") includeName = "start";
                        if (Array.isArray(includeName)) toInsert = includeName.map(function(x) {
                            return rules[x];
                        });
                        else toInsert = rules[includeName];
                    }
                    if (toInsert) {
                        var args = [
                            i,
                            1
                        ].concat(toInsert);
                        if (rule.noEscape) args = args.filter(function(x) {
                            return !x.next;
                        });
                        state.splice.apply(state, args);
                        i--;
                    }
                    if (rule.keywordMap) {
                        rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                        delete rule.defaultToken;
                    }
                }
            }
            Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
            var keywords = Object.create(null);
            this.$keywordList = [];
            Object.keys(map).forEach(function(className) {
                var a = map[className];
                var list = a.split(splitChar || "|");
                for(var i = list.length; i--;){
                    var word = list[i];
                    this.$keywordList.push(word);
                    if (ignoreCase) word = word.toLowerCase();
                    keywords[word] = className;
                }
            }, this);
            map = null;
            return ignoreCase ? function(value) {
                return keywords[value.toLowerCase()] || defaultToken;
            } : function(value) {
                return keywords[value] || defaultToken;
            };
        };
        this.getKeywords = function() {
            return this.$keywords;
        };
    }).call(TextHighlightRules.prototype);
    exports.TextHighlightRules = TextHighlightRules;
});
ace.define("ace/mode/behaviour", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var Behaviour;
    Behaviour = function() {
        this.$behaviours = {};
    };
    (function() {
        this.add = function(name, action, callback) {
            switch(undefined){
                case this.$behaviours:
                    this.$behaviours = {};
                case this.$behaviours[name]:
                    this.$behaviours[name] = {};
            }
            this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
            for(var key in behaviours)for(var action in behaviours[key])this.add(key, action, behaviours[key][action]);
        };
        this.remove = function(name) {
            if (this.$behaviours && this.$behaviours[name]) delete this.$behaviours[name];
        };
        this.inherit = function(mode, filter) {
            if (typeof mode === "function") var behaviours = new mode().getBehaviours(filter);
            else var behaviours = mode.getBehaviours(filter);
            this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter) {
            if (!filter) return this.$behaviours;
            else {
                var ret = {};
                for(var i = 0; i < filter.length; i++)if (this.$behaviours[filter[i]]) ret[filter[i]] = this.$behaviours[filter[i]];
                return ret;
            }
        };
    }).call(Behaviour.prototype);
    exports.Behaviour = Behaviour;
});
ace.define("ace/token_iterator", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var Range = require("./range").Range;
    var TokenIterator = /** @class */ function() {
        function TokenIterator(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
        }
        TokenIterator.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while(this.$tokenIndex < 0){
                this.$row -= 1;
                if (this.$row < 0) {
                    this.$row = 0;
                    return null;
                }
                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while(this.$tokenIndex >= this.$rowTokens.length){
                this.$row += 1;
                if (!rowCount) rowCount = this.$session.getLength();
                if (this.$row >= rowCount) {
                    this.$row = rowCount - 1;
                    return null;
                }
                this.$rowTokens = this.$session.getTokens(this.$row);
                this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
        };
        TokenIterator.prototype.getCurrentTokenRow = function() {
            return this.$row;
        };
        TokenIterator.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== undefined) return column;
            column = 0;
            while(tokenIndex > 0){
                tokenIndex -= 1;
                column += rowTokens[tokenIndex].value.length;
            }
            return column;
        };
        TokenIterator.prototype.getCurrentTokenPosition = function() {
            return {
                row: this.$row,
                column: this.getCurrentTokenColumn()
            };
        };
        TokenIterator.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
        };
        return TokenIterator;
    }();
    exports.TokenIterator = TokenIterator;
});
ace.define("ace/mode/behaviour/cstyle", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/mode/behaviour",
    "ace/token_iterator",
    "ace/lib/lang"
], function(require, exports, module1) {
    "use strict";
    var oop = require("../../lib/oop");
    var Behaviour = require("../behaviour").Behaviour;
    var TokenIterator = require("../../token_iterator").TokenIterator;
    var lang = require("../../lib/lang");
    var SAFE_INSERT_IN_TOKENS = [
        "text",
        "paren.rparen",
        "rparen",
        "paren",
        "punctuation.operator"
    ];
    var SAFE_INSERT_BEFORE_TOKENS = [
        "text",
        "paren.rparen",
        "rparen",
        "paren",
        "punctuation.operator",
        "comment"
    ];
    var context;
    var contextCache = {};
    var defaultQuotes = {
        '"': '"',
        "'": "'"
    };
    var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
            id = editor.selection.index;
            if (contextCache.rangeCount != editor.multiSelect.rangeCount) contextCache = {
                rangeCount: editor.multiSelect.rangeCount
            };
        }
        if (contextCache[id]) return context = contextCache[id];
        context = contextCache[id] = {
            autoInsertedBrackets: 0,
            autoInsertedRow: -1,
            autoInsertedLineEnd: "",
            maybeInsertedBrackets: 0,
            maybeInsertedRow: -1,
            maybeInsertedLineStart: "",
            maybeInsertedLineEnd: ""
        };
    };
    var getWrapped = function(selection, selected, opening, closing) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
            text: opening + selected + closing,
            selection: [
                0,
                selection.start.column + 1,
                rowDiff,
                selection.end.column + (rowDiff ? 0 : 1)
            ]
        };
    };
    var CstyleBehaviour;
    CstyleBehaviour = function(options) {
        options = options || {};
        this.add("braces", "insertion", function(state, action, editor, session, text) {
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            if (text == "{") {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                var token = session.getTokenAt(cursor.row, cursor.column);
                if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) return getWrapped(selection, selected, "{", "}");
                else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
                    var excludeTokens = [
                        /tag\-(?:open|name)/,
                        /attribute\-name/
                    ];
                    if (excludeTokens.some(function(el) {
                        return el.test(token.type);
                    }) || /(string)\.quasi/.test(token.type) && token.value[cursor.column - token.start - 1] !== "$") return;
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: "{}",
                        selection: [
                            1,
                            1
                        ]
                    };
                } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                        CstyleBehaviour.recordAutoInsert(editor, session, "}");
                        return {
                            text: "{}",
                            selection: [
                                1,
                                1
                            ]
                        };
                    } else {
                        CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                        return {
                            text: "{",
                            selection: [
                                1,
                                1
                            ]
                        };
                    }
                }
            } else if (text == "}") {
                initContext(editor);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == "}") {
                    var matching = session.$findOpeningBracket("}", {
                        column: cursor.column + 1,
                        row: cursor.row
                    });
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: "",
                            selection: [
                                1,
                                1
                            ]
                        };
                    }
                }
            } else if (text == "\n" || text == "\r\n") {
                initContext(editor);
                var closing = "";
                if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                    closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                    CstyleBehaviour.clearMaybeInsertedClosing();
                }
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar === "}") {
                    var openBracePos = session.findMatchingBracket({
                        row: cursor.row,
                        column: cursor.column + 1
                    }, "}");
                    if (!openBracePos) return null;
                    var next_indent = this.$getIndent(session.getLine(openBracePos.row));
                } else if (closing) var next_indent = this.$getIndent(line);
                else {
                    CstyleBehaviour.clearMaybeInsertedClosing();
                    return;
                }
                var indent = next_indent + session.getTabString();
                return {
                    text: "\n" + indent + "\n" + next_indent + closing,
                    selection: [
                        1,
                        indent.length,
                        1,
                        indent.length
                    ]
                };
            } else CstyleBehaviour.clearMaybeInsertedClosing();
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "{") {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.end.column, range.end.column + 1);
                if (rightChar == "}") {
                    range.end.column++;
                    return range;
                } else context.maybeInsertedBrackets--;
            }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
            if (text == "(") {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) return getWrapped(selection, selected, "(", ")");
                else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, ")");
                    return {
                        text: "()",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            } else if (text == ")") {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == ")") {
                    var matching = session.$findOpeningBracket(")", {
                        column: cursor.column + 1,
                        row: cursor.row
                    });
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: "",
                            selection: [
                                1,
                                1
                            ]
                        };
                    }
                }
            }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "(") {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == ")") {
                    range.end.column++;
                    return range;
                }
            }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
            if (text == "[") {
                initContext(editor);
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && editor.getWrapBehavioursEnabled()) return getWrapped(selection, selected, "[", "]");
                else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "]");
                    return {
                        text: "[]",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            } else if (text == "]") {
                initContext(editor);
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var rightChar = line.substring(cursor.column, cursor.column + 1);
                if (rightChar == "]") {
                    var matching = session.$findOpeningBracket("]", {
                        column: cursor.column + 1,
                        row: cursor.row
                    });
                    if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                        CstyleBehaviour.popAutoInsertedClosing();
                        return {
                            text: "",
                            selection: [
                                1,
                                1
                            ]
                        };
                    }
                }
            }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && selected == "[") {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == "]") {
                    range.end.column++;
                    return range;
                }
            }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
            var quotes = session.$mode.$quotes || defaultQuotes;
            if (text.length == 1 && quotes[text]) {
                if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1) return;
                initContext(editor);
                var quote = text;
                var selection = editor.getSelectionRange();
                var selected = session.doc.getTextRange(selection);
                if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) return getWrapped(selection, selected, quote, quote);
                else if (!selected) {
                    var cursor = editor.getCursorPosition();
                    var line = session.doc.getLine(cursor.row);
                    var leftChar = line.substring(cursor.column - 1, cursor.column);
                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                    var token = session.getTokenAt(cursor.row, cursor.column);
                    var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
                    if (leftChar == "\\" && token && /escape/.test(token.type)) return null;
                    var stringBefore = token && /string|escape/.test(token.type);
                    var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
                    var pair;
                    if (rightChar == quote) {
                        pair = stringBefore !== stringAfter;
                        if (pair && /string\.end/.test(rightToken.type)) pair = false;
                    } else {
                        if (stringBefore && !stringAfter) return null; // wrap string with different quote
                        if (stringBefore && stringAfter) return null; // do not pair quotes inside strings
                        var wordRe = session.$mode.tokenRe;
                        wordRe.lastIndex = 0;
                        var isWordBefore = wordRe.test(leftChar);
                        wordRe.lastIndex = 0;
                        var isWordAfter = wordRe.test(rightChar);
                        var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                        var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                        if (!shouldPairQuotes && isWordBefore || isWordAfter) return null; // before or after alphanumeric
                        if (rightChar && !/[\s;,.})\]\\]/.test(rightChar)) return null; // there is rightChar and it isn't closing
                        var charBefore = line[cursor.column - 2];
                        if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore))) return null;
                        pair = true;
                    }
                    return {
                        text: pair ? quote + quote : "",
                        selection: [
                            1,
                            1
                        ]
                    };
                }
            }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
            var quotes = session.$mode.$quotes || defaultQuotes;
            var selected = session.doc.getTextRange(range);
            if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
                initContext(editor);
                var line = session.doc.getLine(range.start.row);
                var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
                if (rightChar == selected) {
                    range.end.column++;
                    return range;
                }
            }
        });
        if (options.closeDocComment !== false) this.add("doc comment end", "insertion", function(state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
                var cursor = editor.getCursorPosition();
                if (cursor.column === 0) return;
                var line = session.doc.getLine(cursor.row);
                var nextLine = session.doc.getLine(cursor.row + 1);
                var tokens = session.getTokens(cursor.row);
                var index = 0;
                for(var i = 0; i < tokens.length; i++){
                    index += tokens[i].value.length;
                    var currentToken = tokens[i];
                    if (index >= cursor.column) {
                        if (index === cursor.column) {
                            if (!/\.doc/.test(currentToken.type)) return;
                            if (/\*\//.test(currentToken.value)) {
                                var nextToken = tokens[i + 1];
                                if (!nextToken || !/\.doc/.test(nextToken.type)) return;
                            }
                        }
                        var cursorPosInToken = cursor.column - (index - currentToken.value.length);
                        var closeDocPos = currentToken.value.indexOf("*/");
                        var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
                        if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) return;
                        if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) return;
                        break;
                    }
                }
                var indent = this.$getIndent(line);
                if (/\s*\*/.test(nextLine)) {
                    if (/^\s*\*/.test(line)) return {
                        text: text + indent + "* ",
                        selection: [
                            1,
                            2 + indent.length,
                            1,
                            2 + indent.length
                        ]
                    };
                    else return {
                        text: text + indent + " * ",
                        selection: [
                            1,
                            3 + indent.length,
                            1,
                            3 + indent.length
                        ]
                    };
                }
                if (/\/\*\*/.test(line.substring(0, cursor.column))) return {
                    text: text + indent + " * " + text + " " + indent + "*/",
                    selection: [
                        1,
                        4 + indent.length,
                        1,
                        4 + indent.length
                    ]
                };
            }
        });
    };
    CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
            if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column])) return true;
            var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
            if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
    };
    CstyleBehaviour["$matchTokenType"] = function(token, types) {
        return types.indexOf(token.type || token) > -1;
    };
    CstyleBehaviour["recordAutoInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0])) context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
    };
    CstyleBehaviour["recordMaybeInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isMaybeInsertedClosing"](cursor, line)) context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
    };
    CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
    };
    CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
    };
    CstyleBehaviour["popAutoInsertedClosing"] = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
    };
    CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
        if (context) {
            context.maybeInsertedBrackets = 0;
            context.maybeInsertedRow = -1;
        }
    };
    oop.inherits(CstyleBehaviour, Behaviour);
    exports.CstyleBehaviour = CstyleBehaviour;
});
ace.define("ace/unicode", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    var wordChars = [
        48,
        9,
        8,
        25,
        5,
        0,
        2,
        25,
        48,
        0,
        11,
        0,
        5,
        0,
        6,
        22,
        2,
        30,
        2,
        457,
        5,
        11,
        15,
        4,
        8,
        0,
        2,
        0,
        18,
        116,
        2,
        1,
        3,
        3,
        9,
        0,
        2,
        2,
        2,
        0,
        2,
        19,
        2,
        82,
        2,
        138,
        2,
        4,
        3,
        155,
        12,
        37,
        3,
        0,
        8,
        38,
        10,
        44,
        2,
        0,
        2,
        1,
        2,
        1,
        2,
        0,
        9,
        26,
        6,
        2,
        30,
        10,
        7,
        61,
        2,
        9,
        5,
        101,
        2,
        7,
        3,
        9,
        2,
        18,
        3,
        0,
        17,
        58,
        3,
        100,
        15,
        53,
        5,
        0,
        6,
        45,
        211,
        57,
        3,
        18,
        2,
        5,
        3,
        11,
        3,
        9,
        2,
        1,
        7,
        6,
        2,
        2,
        2,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        0,
        4,
        3,
        3,
        8,
        3,
        1,
        3,
        3,
        9,
        0,
        5,
        1,
        2,
        4,
        3,
        11,
        16,
        2,
        2,
        5,
        5,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        1,
        2,
        1,
        3,
        0,
        2,
        4,
        5,
        1,
        3,
        2,
        4,
        0,
        8,
        3,
        2,
        0,
        8,
        15,
        12,
        2,
        2,
        8,
        2,
        2,
        2,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        3,
        9,
        2,
        2,
        2,
        2,
        3,
        0,
        16,
        3,
        3,
        9,
        18,
        2,
        2,
        7,
        3,
        1,
        3,
        21,
        2,
        6,
        2,
        1,
        2,
        4,
        3,
        8,
        3,
        1,
        3,
        2,
        9,
        1,
        5,
        1,
        2,
        4,
        3,
        9,
        2,
        0,
        17,
        1,
        2,
        5,
        4,
        2,
        2,
        3,
        4,
        1,
        2,
        0,
        2,
        1,
        4,
        1,
        4,
        2,
        4,
        11,
        5,
        4,
        4,
        2,
        2,
        3,
        3,
        0,
        7,
        0,
        15,
        9,
        18,
        2,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        9,
        2,
        4,
        4,
        7,
        2,
        2,
        2,
        3,
        8,
        1,
        2,
        1,
        7,
        3,
        3,
        9,
        19,
        1,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        9,
        2,
        4,
        3,
        8,
        2,
        2,
        2,
        3,
        8,
        1,
        8,
        0,
        2,
        3,
        3,
        9,
        19,
        1,
        2,
        7,
        2,
        2,
        2,
        22,
        2,
        15,
        4,
        7,
        2,
        2,
        2,
        3,
        10,
        0,
        9,
        3,
        3,
        9,
        11,
        5,
        3,
        1,
        2,
        17,
        4,
        23,
        2,
        8,
        2,
        0,
        3,
        6,
        4,
        0,
        5,
        5,
        2,
        0,
        2,
        7,
        19,
        1,
        14,
        57,
        6,
        14,
        2,
        9,
        40,
        1,
        2,
        0,
        3,
        1,
        2,
        0,
        3,
        0,
        7,
        3,
        2,
        6,
        2,
        2,
        2,
        0,
        2,
        0,
        3,
        1,
        2,
        12,
        2,
        2,
        3,
        4,
        2,
        0,
        2,
        5,
        3,
        9,
        3,
        1,
        35,
        0,
        24,
        1,
        7,
        9,
        12,
        0,
        2,
        0,
        2,
        0,
        5,
        9,
        2,
        35,
        5,
        19,
        2,
        5,
        5,
        7,
        2,
        35,
        10,
        0,
        58,
        73,
        7,
        77,
        3,
        37,
        11,
        42,
        2,
        0,
        4,
        328,
        2,
        3,
        3,
        6,
        2,
        0,
        2,
        3,
        3,
        40,
        2,
        3,
        3,
        32,
        2,
        3,
        3,
        6,
        2,
        0,
        2,
        3,
        3,
        14,
        2,
        56,
        2,
        3,
        3,
        66,
        5,
        0,
        33,
        15,
        17,
        84,
        13,
        619,
        3,
        16,
        2,
        25,
        6,
        74,
        22,
        12,
        2,
        6,
        12,
        20,
        12,
        19,
        13,
        12,
        2,
        2,
        2,
        1,
        13,
        51,
        3,
        29,
        4,
        0,
        5,
        1,
        3,
        9,
        34,
        2,
        3,
        9,
        7,
        87,
        9,
        42,
        6,
        69,
        11,
        28,
        4,
        11,
        5,
        11,
        11,
        39,
        3,
        4,
        12,
        43,
        5,
        25,
        7,
        10,
        38,
        27,
        5,
        62,
        2,
        28,
        3,
        10,
        7,
        9,
        14,
        0,
        89,
        75,
        5,
        9,
        18,
        8,
        13,
        42,
        4,
        11,
        71,
        55,
        9,
        9,
        4,
        48,
        83,
        2,
        2,
        30,
        14,
        230,
        23,
        280,
        3,
        5,
        3,
        37,
        3,
        5,
        3,
        7,
        2,
        0,
        2,
        0,
        2,
        0,
        2,
        30,
        3,
        52,
        2,
        6,
        2,
        0,
        4,
        2,
        2,
        6,
        4,
        3,
        3,
        5,
        5,
        12,
        6,
        2,
        2,
        6,
        67,
        1,
        20,
        0,
        29,
        0,
        14,
        0,
        17,
        4,
        60,
        12,
        5,
        0,
        4,
        11,
        18,
        0,
        5,
        0,
        3,
        9,
        2,
        0,
        4,
        4,
        7,
        0,
        2,
        0,
        2,
        0,
        2,
        3,
        2,
        10,
        3,
        3,
        6,
        4,
        5,
        0,
        53,
        1,
        2684,
        46,
        2,
        46,
        2,
        132,
        7,
        6,
        15,
        37,
        11,
        53,
        10,
        0,
        17,
        22,
        10,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        6,
        2,
        31,
        48,
        0,
        470,
        1,
        36,
        5,
        2,
        4,
        6,
        1,
        5,
        85,
        3,
        1,
        3,
        2,
        2,
        89,
        2,
        3,
        6,
        40,
        4,
        93,
        18,
        23,
        57,
        15,
        513,
        6581,
        75,
        20939,
        53,
        1164,
        68,
        45,
        3,
        268,
        4,
        27,
        21,
        31,
        3,
        13,
        13,
        1,
        2,
        24,
        9,
        69,
        11,
        1,
        38,
        8,
        3,
        102,
        3,
        1,
        111,
        44,
        25,
        51,
        13,
        68,
        12,
        9,
        7,
        23,
        4,
        0,
        5,
        45,
        3,
        35,
        13,
        28,
        4,
        64,
        15,
        10,
        39,
        54,
        10,
        13,
        3,
        9,
        7,
        22,
        4,
        1,
        5,
        66,
        25,
        2,
        227,
        42,
        2,
        1,
        3,
        9,
        7,
        11171,
        13,
        22,
        5,
        48,
        8453,
        301,
        3,
        61,
        3,
        105,
        39,
        6,
        13,
        4,
        6,
        11,
        2,
        12,
        2,
        4,
        2,
        0,
        2,
        1,
        2,
        1,
        2,
        107,
        34,
        362,
        19,
        63,
        3,
        53,
        41,
        11,
        5,
        15,
        17,
        6,
        13,
        1,
        25,
        2,
        33,
        4,
        2,
        134,
        20,
        9,
        8,
        25,
        5,
        0,
        2,
        25,
        12,
        88,
        4,
        5,
        3,
        5,
        3,
        5,
        3,
        2
    ];
    var code = 0;
    var str = [];
    for(var i = 0; i < wordChars.length; i += 2){
        str.push(code += wordChars[i]);
        if (wordChars[i + 1]) str.push(45, code += wordChars[i + 1]);
    }
    exports.wordChars = String.fromCharCode.apply(null, str);
});
ace.define("ace/mode/text", [
    "require",
    "exports",
    "module",
    "ace/config",
    "ace/tokenizer",
    "ace/mode/text_highlight_rules",
    "ace/mode/behaviour/cstyle",
    "ace/unicode",
    "ace/lib/lang",
    "ace/token_iterator",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var config = require("../config");
    var Tokenizer = require("../tokenizer").Tokenizer;
    var TextHighlightRules = require("./text_highlight_rules").TextHighlightRules;
    var CstyleBehaviour = require("./behaviour/cstyle").CstyleBehaviour;
    var unicode = require("../unicode");
    var lang = require("../lib/lang");
    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;
    var Mode;
    Mode = function() {
        this.HighlightRules = TextHighlightRules;
    };
    (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
            if (!this.$tokenizer) {
                this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
                this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
            }
            return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
            var doc = session.doc;
            var ignoreBlankLines = true;
            var shouldRemove = true;
            var minIndent = Infinity;
            var tabSize = session.getTabSize();
            var insertAtTabStop = false;
            if (!this.lineCommentStart) {
                if (!this.blockComment) return false;
                var lineCommentStart = this.blockComment.start;
                var lineCommentEnd = this.blockComment.end;
                var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
                var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
                var comment = function(line, i) {
                    if (testRemove(line, i)) return;
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        doc.insertInLine({
                            row: i,
                            column: line.length
                        }, lineCommentEnd);
                        doc.insertInLine({
                            row: i,
                            column: minIndent
                        }, lineCommentStart);
                    }
                };
                var uncomment = function(line, i) {
                    var m;
                    if (m = line.match(regexpEnd)) doc.removeInLine(i, line.length - m[0].length, line.length);
                    if (m = line.match(regexpStart)) doc.removeInLine(i, m[1].length, m[0].length);
                };
                var testRemove = function(line, row) {
                    if (regexpStart.test(line)) return true;
                    var tokens = session.getTokens(row);
                    for(var i = 0; i < tokens.length; i++){
                        if (tokens[i].type === "comment") return true;
                    }
                };
            } else {
                if (Array.isArray(this.lineCommentStart)) {
                    var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
                    var lineCommentStart = this.lineCommentStart[0];
                } else {
                    var regexpStart = lang.escapeRegExp(this.lineCommentStart);
                    var lineCommentStart = this.lineCommentStart;
                }
                regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
                insertAtTabStop = session.getUseSoftTabs();
                var uncomment = function(line, i) {
                    var m = line.match(regexpStart);
                    if (!m) return;
                    var start = m[1].length, end = m[0].length;
                    if (!shouldInsertSpace(line, start, end) && m[0][end - 1] == " ") end--;
                    doc.removeInLine(i, start, end);
                };
                var commentWithSpace = lineCommentStart + " ";
                var comment = function(line, i) {
                    if (!ignoreBlankLines || /\S/.test(line)) {
                        if (shouldInsertSpace(line, minIndent, minIndent)) doc.insertInLine({
                            row: i,
                            column: minIndent
                        }, commentWithSpace);
                        else doc.insertInLine({
                            row: i,
                            column: minIndent
                        }, lineCommentStart);
                    }
                };
                var testRemove = function(line, i) {
                    return regexpStart.test(line);
                };
                var shouldInsertSpace = function(line, before, after) {
                    var spaces = 0;
                    while(before-- && line.charAt(before) == " ")spaces++;
                    if (spaces % tabSize != 0) return false;
                    var spaces = 0;
                    while(line.charAt(after++) == " ")spaces++;
                    if (tabSize > 2) return spaces % tabSize != tabSize - 1;
                    else return spaces % tabSize == 0;
                };
            }
            function iter(fun) {
                for(var i = startRow; i <= endRow; i++)fun(doc.getLine(i), i);
            }
            var minEmptyLength = Infinity;
            iter(function(line, i) {
                var indent = line.search(/\S/);
                if (indent !== -1) {
                    if (indent < minIndent) minIndent = indent;
                    if (shouldRemove && !testRemove(line, i)) shouldRemove = false;
                } else if (minEmptyLength > line.length) minEmptyLength = line.length;
            });
            if (minIndent == Infinity) {
                minIndent = minEmptyLength;
                ignoreBlankLines = false;
                shouldRemove = false;
            }
            if (insertAtTabStop && minIndent % tabSize != 0) minIndent = Math.floor(minIndent / tabSize) * tabSize;
            iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
            var comment = this.blockComment;
            if (!comment) return;
            if (!comment.start && comment[0]) comment = comment[0];
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            var sel = session.selection;
            var initialRange = session.selection.toOrientedRange();
            var startRow, colDiff;
            if (token && /comment/.test(token.type)) {
                var startRange, endRange;
                while(token && /comment/.test(token.type)){
                    var i = token.value.indexOf(comment.start);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        startRange = new Range(row, column, row, column + comment.start.length);
                        break;
                    }
                    token = iterator.stepBackward();
                }
                var iterator = new TokenIterator(session, cursor.row, cursor.column);
                var token = iterator.getCurrentToken();
                while(token && /comment/.test(token.type)){
                    var i = token.value.indexOf(comment.end);
                    if (i != -1) {
                        var row = iterator.getCurrentTokenRow();
                        var column = iterator.getCurrentTokenColumn() + i;
                        endRange = new Range(row, column, row, column + comment.end.length);
                        break;
                    }
                    token = iterator.stepForward();
                }
                if (endRange) session.remove(endRange);
                if (startRange) {
                    session.remove(startRange);
                    startRow = startRange.start.row;
                    colDiff = -comment.start.length;
                }
            } else {
                colDiff = comment.start.length;
                startRow = range.start.row;
                session.insert(range.end, comment.end);
                session.insert(range.start, comment.start);
            }
            if (initialRange.start.row == startRow) initialRange.start.column += colDiff;
            if (initialRange.end.row == startRow) initialRange.end.column += colDiff;
            session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
            return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
            return false;
        };
        this.autoOutdent = function(state, doc, row) {};
        this.$getIndent = function(line) {
            return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
            return null;
        };
        this.createModeDelegates = function(mapping) {
            this.$embeds = [];
            this.$modes = {};
            for(var i in mapping)if (mapping[i]) {
                var Mode = mapping[i];
                var id = Mode.prototype.$id;
                var mode = config.$modes[id];
                if (!mode) config.$modes[id] = mode = new Mode();
                if (!config.$modes[i]) config.$modes[i] = mode;
                this.$embeds.push(i);
                this.$modes[i] = mode;
            }
            var delegations = [
                "toggleBlockComment",
                "toggleCommentLines",
                "getNextLineIndent",
                "checkOutdent",
                "autoOutdent",
                "transformAction",
                "getCompletions"
            ];
            var _loop_1 = function(i) {
                (function(scope) {
                    var functionName = delegations[i];
                    var defaultHandler = scope[functionName];
                    scope[delegations[i]] = function() {
                        return this.$delegator(functionName, arguments, defaultHandler);
                    };
                })(this_1);
            };
            var this_1 = this;
            for(var i = 0; i < delegations.length; i++)_loop_1(i);
        };
        this.$delegator = function(method, args, defaultHandler) {
            var state = args[0] || "start";
            if (typeof state != "string") {
                if (Array.isArray(state[2])) {
                    var language = state[2][state[2].length - 1];
                    var mode = this.$modes[language];
                    if (mode) return mode[method].apply(mode, [
                        state[1]
                    ].concat([].slice.call(args, 1)));
                }
                state = state[0] || "start";
            }
            for(var i = 0; i < this.$embeds.length; i++){
                if (!this.$modes[this.$embeds[i]]) continue;
                var split = state.split(this.$embeds[i]);
                if (!split[0] && split[1]) {
                    args[0] = split[1];
                    var mode = this.$modes[this.$embeds[i]];
                    return mode[method].apply(mode, args);
                }
            }
            var ret = defaultHandler.apply(this, args);
            return defaultHandler ? ret : undefined;
        };
        this.transformAction = function(state, action, editor, session, param) {
            if (this.$behaviour) {
                var behaviours = this.$behaviour.getBehaviours();
                for(var key in behaviours)if (behaviours[key][action]) {
                    var ret = behaviours[key][action].apply(this, arguments);
                    if (ret) return ret;
                }
            }
        };
        this.getKeywords = function(append) {
            if (!this.completionKeywords) {
                var rules = this.$tokenizer["rules"];
                var completionKeywords = [];
                for(var rule in rules){
                    var ruleItr = rules[rule];
                    for(var r = 0, l = ruleItr.length; r < l; r++){
                        if (typeof ruleItr[r].token === "string") {
                            if (/keyword|support|storage/.test(ruleItr[r].token)) completionKeywords.push(ruleItr[r].regex);
                        } else if (typeof ruleItr[r].token === "object") {
                            for(var a = 0, aLength = ruleItr[r].token.length; a < aLength; a++)if (/keyword|support|storage/.test(ruleItr[r].token[a])) {
                                var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a];
                                completionKeywords.push(rule.substr(1, rule.length - 2));
                            }
                        }
                    }
                }
                this.completionKeywords = completionKeywords;
            }
            if (!append) return this.$keywordList;
            return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
            if (!this.$highlightRules) this.getTokenizer();
            return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
            var keywords = this.$keywordList || this.$createKeywordList();
            return keywords.map(function(word) {
                return {
                    name: word,
                    value: word,
                    score: 0,
                    meta: "keyword"
                };
            });
        };
        this.$id = "ace/mode/text";
    }).call(Mode.prototype);
    exports.Mode = Mode;
});
ace.define("ace/line_widgets", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var dom = require("./lib/dom");
    var LineWidgets = /** @class */ function() {
        function LineWidgets(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
        }
        LineWidgets.prototype.getRowLength = function(row) {
            var h;
            if (this.lineWidgets) h = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else h = 0;
            if (!this["$useWrapMode"] || !this["$wrapData"][row]) return 1 + h;
            else return this["$wrapData"][row].length + 1 + h;
        };
        LineWidgets.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w) {
                if (w && w.rowCount && !w.hidden) screenRows += w.rowCount;
            });
            return screenRows;
        };
        LineWidgets.prototype.$onChangeEditor = function(e) {
            this.attach(e.editor);
        };
        LineWidgets.prototype.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this) editor.widgetManager.detach();
            if (this.editor == editor) return;
            this.detach();
            this.editor = editor;
            if (editor) {
                editor.widgetManager = this;
                editor.renderer.on("beforeRender", this.measureWidgets);
                editor.renderer.on("afterRender", this.renderWidgets);
            }
        };
        LineWidgets.prototype.detach = function(e) {
            var editor = this.editor;
            if (!editor) return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w) {
                if (w && w.el && w.el.parentNode) {
                    w._inDocument = false;
                    w.el.parentNode.removeChild(w.el);
                }
            });
        };
        LineWidgets.prototype.updateOnFold = function(e, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e.action) return;
            var fold = e.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e.action == "add";
            for(var i = start + 1; i < end; i++)if (lineWidgets[i]) lineWidgets[i].hidden = hide;
            if (lineWidgets[end]) {
                if (hide) {
                    if (!lineWidgets[start]) lineWidgets[start] = lineWidgets[end];
                    else lineWidgets[end].hidden = hide;
                } else {
                    if (lineWidgets[start] == lineWidgets[end]) lineWidgets[start] = undefined;
                    lineWidgets[end].hidden = hide;
                }
            }
        };
        LineWidgets.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) ;
            else if (delta.action == "remove") {
                var removed = lineWidgets.splice(startRow + 1, len);
                if (!lineWidgets[startRow] && removed[removed.length - 1]) lineWidgets[startRow] = removed.pop();
                removed.forEach(function(w) {
                    w && this.removeLineWidget(w);
                }, this);
                this.$updateRows();
            } else {
                var args = new Array(len);
                if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                    if (delta.start.column > lineWidgets[startRow].column) startRow++;
                }
                args.unshift(startRow, 0);
                lineWidgets.splice.apply(lineWidgets, args);
                this.$updateRows();
            }
        };
        LineWidgets.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            var noWidgets = true;
            lineWidgets.forEach(function(w, i) {
                if (w) {
                    noWidgets = false;
                    w.row = i;
                    while(w.$oldWidget){
                        w.$oldWidget.row = i;
                        w = w.$oldWidget;
                    }
                }
            });
            if (noWidgets) this.session.lineWidgets = null;
        };
        LineWidgets.prototype.$registerLineWidget = function(w) {
            if (!this.session.lineWidgets) this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w.row];
            if (old) {
                w.$oldWidget = old;
                if (old.el && old.el.parentNode) {
                    old.el.parentNode.removeChild(old.el);
                    old._inDocument = false;
                }
            }
            this.session.lineWidgets[w.row] = w;
            return w;
        };
        LineWidgets.prototype.addLineWidget = function(w) {
            this.$registerLineWidget(w);
            w.session = this.session;
            if (!this.editor) return w;
            var renderer = this.editor.renderer;
            if (w.html && !w.el) {
                w.el = dom.createElement("div");
                w.el.innerHTML = w.html;
            }
            if (w.text && !w.el) {
                w.el = dom.createElement("div");
                w.el.textContent = w.text;
            }
            if (w.el) {
                dom.addCssClass(w.el, "ace_lineWidgetContainer");
                if (w.className) dom.addCssClass(w.el, w.className);
                w.el.style.position = "absolute";
                w.el.style.zIndex = "5";
                renderer.container.appendChild(w.el);
                w._inDocument = true;
                if (!w.coverGutter) w.el.style.zIndex = "3";
                if (w.pixelHeight == null) w.pixelHeight = w.el.offsetHeight;
            }
            if (w.rowCount == null) w.rowCount = w.pixelHeight / renderer.layerConfig.lineHeight;
            var fold = this.session.getFoldAt(w.row, 0);
            w.$fold = fold;
            if (fold) {
                var lineWidgets = this.session.lineWidgets;
                if (w.row == fold.end.row && !lineWidgets[fold.start.row]) lineWidgets[fold.start.row] = w;
                else w.hidden = true;
            }
            this.session._emit("changeFold", {
                data: {
                    start: {
                        row: w.row
                    }
                }
            });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w);
            return w;
        };
        LineWidgets.prototype.removeLineWidget = function(w) {
            w._inDocument = false;
            w.session = null;
            if (w.el && w.el.parentNode) w.el.parentNode.removeChild(w.el);
            if (w.editor && w.editor.destroy) try {
                w.editor.destroy();
            } catch (e) {}
            if (this.session.lineWidgets) {
                var w1 = this.session.lineWidgets[w.row];
                if (w1 == w) {
                    this.session.lineWidgets[w.row] = w.$oldWidget;
                    if (w.$oldWidget) this.onWidgetChanged(w.$oldWidget);
                } else while(w1){
                    if (w1.$oldWidget == w) {
                        w1.$oldWidget = w.$oldWidget;
                        break;
                    }
                    w1 = w1.$oldWidget;
                }
            }
            this.session._emit("changeFold", {
                data: {
                    start: {
                        row: w.row
                    }
                }
            });
            this.$updateRows();
        };
        LineWidgets.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w = lineWidgets && lineWidgets[row];
            var list = [];
            while(w){
                list.push(w);
                w = w.$oldWidget;
            }
            return list;
        };
        LineWidgets.prototype.onWidgetChanged = function(w) {
            this.session._changedWidgets.push(w);
            this.editor && this.editor.renderer.updateFull();
        };
        LineWidgets.prototype.measureWidgets = function(e, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length) return;
            var min = Infinity;
            for(var i = 0; i < changedWidgets.length; i++){
                var w = changedWidgets[i];
                if (!w || !w.el) continue;
                if (w.session != this.session) continue;
                if (!w._inDocument) {
                    if (this.session.lineWidgets[w.row] != w) continue;
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                w.h = w.el.offsetHeight;
                if (!w.fixedWidth) {
                    w.w = w.el.offsetWidth;
                    w.screenWidth = Math.ceil(w.w / config.characterWidth);
                }
                var rowCount = w.h / config.lineHeight;
                if (w.coverLine) {
                    rowCount -= this.session.getRowLineCount(w.row);
                    if (rowCount < 0) rowCount = 0;
                }
                if (w.rowCount != rowCount) {
                    w.rowCount = rowCount;
                    if (w.row < min) min = w.row;
                }
            }
            if (min != Infinity) {
                this.session._emit("changeFold", {
                    data: {
                        start: {
                            row: min
                        }
                    }
                });
                this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
        };
        LineWidgets.prototype.renderWidgets = function(e, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets) return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while(first > 0 && !lineWidgets[first])first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for(var i = first; i <= last; i++){
                var w = lineWidgets[i];
                if (!w || !w.el) continue;
                if (w.hidden) {
                    w.el.style.top = -100 - (w.pixelHeight || 0) + "px";
                    continue;
                }
                if (!w._inDocument) {
                    w._inDocument = true;
                    renderer.container.appendChild(w.el);
                }
                var top = renderer.$cursorLayer.getPixelPosition({
                    row: i,
                    column: 0
                }, true).top;
                if (!w.coverLine) top += config.lineHeight * this.session.getRowLineCount(w.row);
                w.el.style.top = top - config.offset + "px";
                var left = w.coverGutter ? 0 : renderer.gutterWidth;
                if (!w.fixedWidth) left -= renderer.scrollLeft;
                w.el.style.left = left + "px";
                if (w.fullWidth && w.screenWidth) w.el.style.minWidth = config.width + 2 * config.padding + "px";
                if (w.fixedWidth) w.el.style.right = renderer.scrollBar.getWidth() + "px";
                else w.el.style.right = "";
            }
        };
        return LineWidgets;
    }();
    exports.LineWidgets = LineWidgets;
});
ace.define("ace/apply_delta", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    "use strict";
    function throwDeltaError(delta, errorText) {
        console.log("Invalid Delta:", delta);
        throw "Invalid Delta: " + errorText;
    }
    function positionInDocument(docLines, position) {
        return position.row >= 0 && position.row < docLines.length && position.column >= 0 && position.column <= docLines[position.row].length;
    }
    function validateDelta(docLines, delta) {
        if (delta.action != "insert" && delta.action != "remove") throwDeltaError(delta, "delta.action must be 'insert' or 'remove'");
        if (!(delta.lines instanceof Array)) throwDeltaError(delta, "delta.lines must be an Array");
        if (!delta.start || !delta.end) throwDeltaError(delta, "delta.start/end must be an present");
        var start = delta.start;
        if (!positionInDocument(docLines, delta.start)) throwDeltaError(delta, "delta.start must be contained in document");
        var end = delta.end;
        if (delta.action == "remove" && !positionInDocument(docLines, end)) throwDeltaError(delta, "delta.end must contained in document for 'remove' actions");
        var numRangeRows = end.row - start.row;
        var numRangeLastLineChars = end.column - (numRangeRows == 0 ? start.column : 0);
        if (numRangeRows != delta.lines.length - 1 || delta.lines[numRangeRows].length != numRangeLastLineChars) throwDeltaError(delta, "delta.range must match delta lines");
    }
    exports.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch(delta.action){
            case "insert":
                var lines = delta.lines;
                if (lines.length === 1) docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
                else {
                    var args = [
                        row,
                        1
                    ].concat(delta.lines);
                    docLines.splice.apply(docLines, args);
                    docLines[row] = line.substring(0, startColumn) + docLines[row];
                    docLines[row + delta.lines.length - 1] += line.substring(startColumn);
                }
                break;
            case "remove":
                var endColumn = delta.end.column;
                var endRow = delta.end.row;
                if (row === endRow) docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
                else docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
                break;
        }
    };
});
ace.define("ace/anchor", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Anchor = /** @class */ function() {
        function Anchor(doc, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc);
            if (typeof row != "number") this.setPosition(row.row, row.column);
            else this.setPosition(row, column);
        }
        Anchor.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
        };
        Anchor.prototype.getDocument = function() {
            return this.document;
        };
        Anchor.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row) return;
            if (delta.start.row > this.row) return;
            var point = $getTransformedPoint(delta, {
                row: this.row,
                column: this.column
            }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
        };
        Anchor.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) pos = {
                row: row,
                column: column
            };
            else pos = this.$clipPositionToDocument(row, column);
            if (this.row == pos.row && this.column == pos.column) return;
            var old = {
                row: this.row,
                column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
                old: old,
                value: pos
            });
        };
        Anchor.prototype.detach = function() {
            this.document.off("change", this.$onChange);
        };
        Anchor.prototype.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
        };
        Anchor.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
                pos.row = Math.max(0, this.document.getLength() - 1);
                pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
                pos.row = 0;
                pos.column = 0;
            } else {
                pos.row = row;
                pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0) pos.column = 0;
            return pos;
        };
        return Anchor;
    }();
    Anchor.prototype.$insertRight = false;
    oop.implement(Anchor.prototype, EventEmitter);
    function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
    }
    function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end; // Collapse insert range.
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) return {
            row: point.row,
            column: point.column
        };
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
        };
        return {
            row: deltaStart.row,
            column: deltaStart.column
        };
    }
    exports.Anchor = Anchor;
});
ace.define("ace/document", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/apply_delta",
    "ace/lib/event_emitter",
    "ace/range",
    "ace/anchor"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var applyDelta = require("./apply_delta").applyDelta;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Range = require("./range").Range;
    var Anchor = require("./anchor").Anchor;
    var Document = /** @class */ function() {
        function Document(textOrLines) {
            this.$lines = [
                ""
            ];
            if (textOrLines.length === 0) this.$lines = [
                ""
            ];
            else if (Array.isArray(textOrLines)) this.insertMergedLines({
                row: 0,
                column: 0
            }, textOrLines);
            else this.insert({
                row: 0,
                column: 0
            }, textOrLines);
        }
        Document.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({
                row: 0,
                column: 0
            }, text || "");
        };
        Document.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
        };
        Document.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
        };
        Document.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match ? match[1] : "\n";
            this._signal("changeNewLineMode");
        };
        Document.prototype.getNewLineCharacter = function() {
            switch(this.$newLineMode){
                case "windows":
                    return "\r\n";
                case "unix":
                    return "\n";
                default:
                    return this.$autoNewLine || "\n";
            }
        };
        Document.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode) return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
        };
        Document.prototype.getNewLineMode = function() {
            return this.$newLineMode;
        };
        Document.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
        };
        Document.prototype.getLine = function(row) {
            return this.$lines[row] || "";
        };
        Document.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
        };
        Document.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
        };
        Document.prototype.getLength = function() {
            return this.$lines.length;
        };
        Document.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
        };
        Document.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) lines = [
                this.getLine(range.start.row).substring(range.start.column, range.end.column)
            ];
            else {
                lines = this.getLines(range.start.row, range.end.row);
                lines[0] = (lines[0] || "").substring(range.start.column);
                var l = lines.length - 1;
                if (range.end.row - range.start.row == l) lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
        };
        Document.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
        };
        Document.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
        };
        Document.prototype.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, [
                "",
                ""
            ]);
        };
        Document.prototype.insert = function(position, text) {
            if (this.getLength() <= 1) this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
        };
        Document.prototype.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: [
                    text
                ]
            }, true);
            return this.clonePos(end);
        };
        Document.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === undefined) row = length;
            else if (row < 0) row = 0;
            else if (row >= length) {
                row = length - 1;
                column = undefined;
            }
            var line = this.getLine(row);
            if (column == undefined) column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return {
                row: row,
                column: column
            };
        };
        Document.prototype.clonePos = function(pos) {
            return {
                row: pos.row,
                column: pos.column
            };
        };
        Document.prototype.pos = function(row, column) {
            return {
                row: row,
                column: column
            };
        };
        Document.prototype.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
                position.row = Math.max(0, length - 1);
                position.column = this.getLine(length - 1).length;
            } else {
                position.row = Math.max(0, position.row);
                position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
        };
        Document.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
                lines = lines.concat([
                    ""
                ]);
                column = 0;
            } else {
                lines = [
                    ""
                ].concat(lines);
                row--;
                column = this.$lines[row].length;
            }
            this.insertMergedLines({
                row: row,
                column: column
            }, lines);
        };
        Document.prototype.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
                row: start.row + lines.length - 1,
                column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
                start: start,
                end: end,
                action: "insert",
                lines: lines
            });
            return this.clonePos(end);
        };
        Document.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({
                    start: start,
                    end: end
                })
            });
            return this.clonePos(start);
        };
        Document.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
                start: start,
                end: end,
                action: "remove",
                lines: this.getLinesForRange({
                    start: start,
                    end: end
                })
            }, true);
            return this.clonePos(start);
        };
        Document.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
                start: range.start,
                end: range.end,
                action: "remove",
                lines: this.getLinesForRange(range)
            });
            return deletedLines;
        };
        Document.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: [
                    "",
                    ""
                ]
            });
        };
        Document.prototype.replace = function(range, text) {
            if (!(range instanceof Range)) range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty()) return range.start;
            if (text == this.getTextRange(range)) return range.end;
            this.remove(range);
            var end;
            if (text) end = this.insert(range.start, text);
            else end = range.start;
            return end;
        };
        Document.prototype.applyDeltas = function(deltas) {
            for(var i = 0; i < deltas.length; i++)this.applyDelta(deltas[i]);
        };
        Document.prototype.revertDeltas = function(deltas) {
            for(var i = deltas.length - 1; i >= 0; i--)this.revertDelta(deltas[i]);
        };
        Document.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) return;
            if (isInsert && delta.lines.length > 20000) this.$splitAndapplyLargeDelta(delta, 20000);
            else {
                applyDelta(this.$lines, delta, doNotValidate);
                this._signal("change", delta);
            }
        };
        Document.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) this.applyDelta(delta);
        };
        Document.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for(var from = 0, to = 0; from < l; from = to){
                to += MAX - 1;
                var chunk = lines.slice(from, to);
                chunk.push("");
                this.applyDelta({
                    start: this.pos(row + from, column),
                    end: this.pos(row + to, column = 0),
                    action: delta.action,
                    lines: chunk
                }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
        };
        Document.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
                start: this.clonePos(delta.start),
                end: this.clonePos(delta.end),
                action: delta.action == "insert" ? "remove" : "insert",
                lines: delta.lines.slice()
            });
        };
        Document.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for(var i = startRow || 0, l = lines.length; i < l; i++){
                index -= lines[i].length + newlineLength;
                if (index < 0) return {
                    row: i,
                    column: index + lines[i].length + newlineLength
                };
            }
            return {
                row: l - 1,
                column: index + lines[l - 1].length + newlineLength
            };
        };
        Document.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for(var i = startRow || 0; i < row; ++i)index += lines[i].length + newlineLength;
            return index + pos.column;
        };
        Document.prototype.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
        };
        return Document;
    }();
    Document.prototype.$autoNewLine = "";
    Document.prototype.$newLineMode = "auto";
    oop.implement(Document.prototype, EventEmitter);
    exports.Document = Document;
});
ace.define("ace/background_tokenizer", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var BackgroundTokenizer = /** @class */ function() {
        function BackgroundTokenizer(tokenizer, session) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self1 = this;
            this.$worker = function() {
                if (!self1.running) return;
                var workerStart = new Date();
                var currentLine = self1.currentLine;
                var endLine = -1;
                var doc = self1.doc;
                var startLine = currentLine;
                while(self1.lines[currentLine])currentLine++;
                var len = doc.getLength();
                var processedLines = 0;
                self1.running = false;
                while(currentLine < len){
                    self1.$tokenizeRow(currentLine);
                    endLine = currentLine;
                    do currentLine++;
                    while (self1.lines[currentLine]);
                    processedLines++;
                    if (processedLines % 5 === 0 && new Date() - workerStart > 20) {
                        self1.running = setTimeout(self1.$worker, 20);
                        break;
                    }
                }
                self1.currentLine = currentLine;
                if (endLine == -1) endLine = currentLine;
                if (startLine <= endLine) self1.fireUpdateEvent(startLine, endLine);
            };
        }
        BackgroundTokenizer.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
        };
        BackgroundTokenizer.prototype.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
        };
        BackgroundTokenizer.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
                first: firstRow,
                last: lastRow
            };
            this._signal("update", {
                data: data
            });
        };
        BackgroundTokenizer.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
        };
        BackgroundTokenizer.prototype.scheduleStart = function() {
            if (!this.running) this.running = setTimeout(this.$worker, 700);
        };
        BackgroundTokenizer.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) this.lines[startRow] = null;
            else if (delta.action == "remove") {
                this.lines.splice(startRow, len + 1, null);
                this.states.splice(startRow, len + 1, null);
            } else {
                var args = Array(len + 1);
                args.unshift(startRow, 1);
                this.lines.splice.apply(this.lines, args);
                this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
        };
        BackgroundTokenizer.prototype.stop = function() {
            if (this.running) clearTimeout(this.running);
            this.running = false;
        };
        BackgroundTokenizer.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
        };
        BackgroundTokenizer.prototype.getState = function(row) {
            if (this.currentLine == row) this.$tokenizeRow(row);
            return this.states[row] || "start";
        };
        BackgroundTokenizer.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
                this.states[row] = data.state;
                this.lines[row + 1] = null;
                if (this.currentLine > row + 1) this.currentLine = row + 1;
            } else if (this.currentLine == row) this.currentLine = row + 1;
            return this.lines[row] = data.tokens;
        };
        BackgroundTokenizer.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
        };
        return BackgroundTokenizer;
    }();
    oop.implement(BackgroundTokenizer.prototype, EventEmitter);
    exports.BackgroundTokenizer = BackgroundTokenizer;
});
ace.define("ace/search_highlight", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var lang = require("./lib/lang");
    var Range = require("./range").Range;
    var SearchHighlight = /** @class */ function() {
        function SearchHighlight(regExp, clazz, type) {
            if (type === void 0) type = "text";
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type;
            this.docLen = 0;
        }
        SearchHighlight.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "") return;
            this.regExp = regExp;
            this.cache = [];
        };
        SearchHighlight.prototype.update = function(html, markerLayer, session, config) {
            if (!this.regExp) return;
            var start = config.firstRow;
            var end = config.lastRow;
            var renderedMarkerRanges = {};
            var _search = session.$editor && session.$editor.$search;
            var mtSearch = _search && _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
            for(var i = start; i <= end; i++){
                var ranges = this.cache[i];
                if (ranges == null || session.getValue().length != this.docLen) {
                    if (mtSearch) {
                        ranges = [];
                        var match = _search.$multiLineForward(session, this.regExp, i, end);
                        if (match) {
                            var end_row = match.endRow <= end ? match.endRow - 1 : end;
                            if (end_row > i) i = end_row;
                            ranges.push(new Range(match.startRow, match.startCol, match.endRow, match.endCol));
                        }
                        if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                    } else {
                        ranges = lang.getMatchOffsets(session.getLine(i), this.regExp);
                        if (ranges.length > this.MAX_RANGES) ranges = ranges.slice(0, this.MAX_RANGES);
                        ranges = ranges.map(function(match) {
                            return new Range(i, match.offset, i, match.offset + match.length);
                        });
                    }
                    this.cache[i] = ranges.length ? ranges : "";
                }
                if (ranges.length === 0) continue;
                for(var j = ranges.length; j--;){
                    var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                    var rangeAsString = rangeToAddMarkerTo.toString();
                    if (renderedMarkerRanges[rangeAsString]) continue;
                    renderedMarkerRanges[rangeAsString] = true;
                    markerLayer.drawSingleLineMarker(html, rangeToAddMarkerTo, this.clazz, config);
                }
            }
            this.docLen = session.getValue().length;
        };
        return SearchHighlight;
    }();
    SearchHighlight.prototype.MAX_RANGES = 500;
    exports.SearchHighlight = SearchHighlight;
});
ace.define("ace/undomanager", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var UndoManager = /** @class */ function() {
        function UndoManager() {
            this.$keepRedoStack;
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
        }
        UndoManager.prototype.addSession = function(session) {
            this.$session = session;
        };
        UndoManager.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo) return;
            if (delta == this.$lastDelta) return;
            if (!this.$keepRedoStack) this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
                this.lastDeltas = [];
                var undoStackLength = this.$undoStack.length;
                if (undoStackLength > this.$undoDepth - 1) this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
                this.$undoStack.push(this.lastDeltas);
                delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert") this.$lastDelta = delta;
            this.lastDeltas.push(delta);
        };
        UndoManager.prototype.addSelection = function(selection, rev) {
            this.selections.push({
                value: selection,
                rev: rev || this.$rev
            });
        };
        UndoManager.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
        };
        UndoManager.prototype.markIgnored = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            for(var i = stack.length; i--;){
                var delta = stack[i][0];
                if (delta.id <= from) break;
                if (delta.id < to) delta.ignore = true;
            }
            this.lastDeltas = null;
        };
        UndoManager.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for(var i = stack.length; i--;){
                var selection = stack[i];
                if (selection.rev < rev) {
                    if (after) selection = stack[i + 1];
                    return selection;
                }
            }
        };
        UndoManager.prototype.getRevision = function() {
            return this.$rev;
        };
        UndoManager.prototype.getDeltas = function(from, to) {
            if (to == null) to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for(var i = stack.length; i--;){
                var delta = stack[i][0];
                if (delta.id < to && !end) end = i + 1;
                if (delta.id <= from) {
                    start = i + 1;
                    break;
                }
            }
            return stack.slice(start, end);
        };
        UndoManager.prototype.getChangedRanges = function(from, to) {
            if (to == null) to = this.$rev + 1;
        };
        UndoManager.prototype.getChangedLines = function(from, to) {
            if (to == null) to = this.$rev + 1;
        };
        UndoManager.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length)) return;
            if (!session) session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length) this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
                undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
                this.$redoStack.push(deltaSet);
                this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
        };
        UndoManager.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session) session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
                var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
                rebaseRedoStack(this.$redoStack, diff);
                this.$redoStackBaseRev = this.$rev;
                this.$redoStack.forEach(function(x) {
                    x[0].id = ++this.$maxRev;
                }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
                redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
                this.$undoStack.push(deltaSet);
                this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
        };
        UndoManager.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
        };
        UndoManager.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
        };
        UndoManager.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
        };
        UndoManager.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
        };
        UndoManager.prototype.bookmark = function(rev) {
            if (rev == undefined) rev = this.$rev;
            this.mark = rev;
        };
        UndoManager.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
        };
        UndoManager.prototype.toJSON = function() {
            return {
                $redoStack: this.$redoStack,
                $undoStack: this.$undoStack
            };
        };
        UndoManager.prototype.fromJSON = function(json) {
            this.reset();
            this.$undoStack = json.$undoStack;
            this.$redoStack = json.$redoStack;
        };
        UndoManager.prototype.$prettyPrint = function(delta) {
            if (delta) return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
        };
        return UndoManager;
    }();
    UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
    UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
    UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
    UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
    function rearrangeUndoStack(stack, pos) {
        for(var i = pos; i--;){
            var deltaSet = stack[i];
            if (deltaSet && !deltaSet[0].ignore) {
                while(i < pos - 1){
                    var swapped = swapGroups(stack[i], stack[i + 1]);
                    stack[i] = swapped[0];
                    stack[i + 1] = swapped[1];
                    i++;
                }
                return true;
            }
        }
    }
    var Range = require("./range").Range;
    var cmp = Range.comparePoints;
    var comparePoints = Range.comparePoints;
    function $updateMarkers(delta) {
        var isInsert = delta.action == "insert";
        var start = delta.start;
        var end = delta.end;
        var rowShift = (end.row - start.row) * (isInsert ? 1 : -1);
        var colShift = (end.column - start.column) * (isInsert ? 1 : -1);
        if (isInsert) end = start;
        for(var i in this.marks){
            var point = this.marks[i];
            var cmp = comparePoints(point, start);
            if (cmp < 0) continue; // delta starts after the range
            if (cmp === 0) {
                if (isInsert) {
                    if (point.bias == 1) cmp = 1;
                    else {
                        point.bias;
                        continue;
                    }
                }
            }
            var cmp2 = isInsert ? cmp : comparePoints(point, end);
            if (cmp2 > 0) {
                point.row += rowShift;
                point.column += point.row == end.row ? colShift : 0;
                continue;
            }
            if (!isInsert && cmp2 <= 0) {
                point.row = start.row;
                point.column = start.column;
                if (cmp2 === 0) point.bias = 1;
            }
        }
    }
    function clonePos(pos) {
        return {
            row: pos.row,
            column: pos.column
        };
    }
    function cloneDelta(d) {
        return {
            start: clonePos(d.start),
            end: clonePos(d.end),
            action: d.action,
            lines: d.lines.slice()
        };
    }
    function stringifyDelta(d) {
        d = d || this;
        if (Array.isArray(d)) return d.map(stringifyDelta).join("\n");
        var type = "";
        if (d.action) {
            type = d.action == "insert" ? "+" : "-";
            type += "[" + d.lines + "]";
        } else if (d.value) {
            if (Array.isArray(d.value)) type = d.value.map(stringifyRange).join("\n");
            else type = stringifyRange(d.value);
        }
        if (d.start) type += stringifyRange(d);
        if (d.id || d.rev) type += "	(" + (d.id || d.rev) + ")";
        return type;
    }
    function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
    }
    function swap(d1, d2) {
        var i1 = d1.action == "insert";
        var i2 = d2.action == "insert";
        if (i1 && i2) {
            if (cmp(d2.start, d1.end) >= 0) shift(d2, d1, -1);
            else if (cmp(d2.start, d1.start) <= 0) shift(d1, d2, 1);
            else return null;
        } else if (i1 && !i2) {
            if (cmp(d2.start, d1.end) >= 0) shift(d2, d1, -1);
            else if (cmp(d2.end, d1.start) <= 0) shift(d1, d2, -1);
            else return null;
        } else if (!i1 && i2) {
            if (cmp(d2.start, d1.start) >= 0) shift(d2, d1, 1);
            else if (cmp(d2.start, d1.start) <= 0) shift(d1, d2, 1);
            else return null;
        } else if (!i1 && !i2) {
            if (cmp(d2.start, d1.start) >= 0) shift(d2, d1, 1);
            else if (cmp(d2.end, d1.start) <= 0) shift(d1, d2, -1);
            else return null;
        }
        return [
            d2,
            d1
        ];
    }
    function swapGroups(ds1, ds2) {
        for(var i = ds1.length; i--;){
            for(var j = 0; j < ds2.length; j++)if (!swap(ds1[i], ds2[j])) {
                while(i < ds1.length){
                    while(j--)swap(ds2[j], ds1[i]);
                    j = ds2.length;
                    i++;
                }
                return [
                    ds1,
                    ds2
                ];
            }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [
            ds2,
            ds1
        ];
    }
    function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
            if (cmp(d1.start, c1.start) < 0) shift(c1, d1, 1);
            else shift(d1, c1, 1);
        } else if (i1 && !i2) {
            if (cmp(d1.start, c1.end) >= 0) shift(d1, c1, -1);
            else if (cmp(d1.start, c1.start) <= 0) shift(c1, d1, 1);
            else {
                shift(d1, Range.fromPoints(c1.start, d1.start), -1);
                shift(c1, d1, 1);
            }
        } else if (!i1 && i2) {
            if (cmp(c1.start, d1.end) >= 0) shift(c1, d1, -1);
            else if (cmp(c1.start, d1.start) <= 0) shift(d1, c1, 1);
            else {
                shift(c1, Range.fromPoints(d1.start, c1.start), -1);
                shift(d1, c1, 1);
            }
        } else if (!i1 && !i2) {
            if (cmp(c1.start, d1.end) >= 0) shift(c1, d1, -1);
            else if (cmp(c1.end, d1.start) <= 0) shift(d1, c1, -1);
            else {
                var before, after;
                if (cmp(d1.start, c1.start) < 0) {
                    before = d1;
                    d1 = splitDelta(d1, c1.start);
                }
                if (cmp(d1.end, c1.end) > 0) after = splitDelta(d1, c1.end);
                shiftPos(c1.end, d1.start, d1.end, -1);
                if (after && !before) {
                    d1.lines = after.lines;
                    d1.start = after.start;
                    d1.end = after.end;
                    after = d1;
                }
                return [
                    c1,
                    before,
                    after
                ].filter(Boolean);
            }
        }
        return [
            c1,
            d1
        ];
    }
    function shift(d1, d2, dir) {
        shiftPos(d1.start, d2.start, d2.end, dir);
        shiftPos(d1.end, d2.start, d2.end, dir);
    }
    function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) pos.column += dir * (end.column - start.column);
        pos.row += dir * (end.row - start.row);
    }
    function splitDelta(c, pos) {
        var lines = c.lines;
        var end = c.end;
        c.end = clonePos(pos);
        var rowsBefore = c.end.row - c.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
            start: clonePos(pos),
            end: end,
            lines: otherLines,
            action: c.action
        };
        return rest;
    }
    function moveDeltasByOne(redoStack, d) {
        d = cloneDelta(d);
        for(var j = redoStack.length; j--;){
            var deltaSet = redoStack[j];
            for(var i = 0; i < deltaSet.length; i++){
                var x = deltaSet[i];
                var xformed = xform(x, d);
                d = xformed[0];
                if (xformed.length != 2) {
                    if (xformed[2]) {
                        deltaSet.splice(i + 1, 1, xformed[1], xformed[2]);
                        i++;
                    } else if (!xformed[1]) {
                        deltaSet.splice(i, 1);
                        i--;
                    }
                }
            }
            if (!deltaSet.length) redoStack.splice(j, 1);
        }
        return redoStack;
    }
    function rebaseRedoStack(redoStack, deltaSets) {
        for(var i = 0; i < deltaSets.length; i++){
            var deltas = deltaSets[i];
            for(var j = 0; j < deltas.length; j++)moveDeltasByOne(redoStack, deltas[j]);
        }
    }
    exports.UndoManager = UndoManager;
});
ace.define("ace/edit_session/fold_line", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var Range = require("../range").Range;
    var FoldLine = /** @class */ function() {
        function FoldLine(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) this.folds = folds;
            else folds = this.folds = [
                folds
            ];
            var last = folds[folds.length - 1];
            this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold) {
                fold.setFoldLine(this);
            }, this);
        }
        FoldLine.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
                fold.start.row += shift;
                fold.end.row += shift;
            });
        };
        FoldLine.prototype.addFold = function(fold) {
            if (fold.sameRow) {
                if (fold.start.row < this.startRow || fold.endRow > this.endRow) throw new Error("Can't add a fold to this FoldLine as it has no connection");
                this.folds.push(fold);
                this.folds.sort(function(a, b) {
                    return -a.range.compareEnd(b.start.row, b.start.column);
                });
                if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                    this.end.row = fold.end.row;
                    this.end.column = fold.end.column;
                } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                    this.start.row = fold.start.row;
                    this.start.column = fold.start.column;
                }
            } else if (fold.start.row == this.end.row) {
                this.folds.push(fold);
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
                this.folds.unshift(fold);
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
            } else throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            fold.foldLine = this;
        };
        FoldLine.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
        };
        FoldLine.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
                endRow = this.end.row;
                endColumn = this.end.column;
            }
            for(var i = 0; i < folds.length; i++){
                fold = folds[i];
                cmp = fold.range.compareStart(endRow, endColumn);
                if (cmp == -1) {
                    callback(null, endRow, endColumn, lastEnd, isNewRow);
                    return;
                }
                stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
                stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
                if (stop || cmp === 0) return;
                isNewRow = !fold.sameRow;
                lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
        };
        FoldLine.prototype.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for(var i = 0; i < this.folds.length; i++){
                fold = this.folds[i];
                cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) return {
                    fold: fold,
                    kind: "after"
                };
                else if (cmp === 0) return {
                    fold: fold,
                    kind: "inside"
                };
            }
            return null;
        };
        FoldLine.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
                fold = ret.fold;
                if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) window.console && window.console.log(row, column, fold);
                else if (fold.start.row == row) {
                    folds = this.folds;
                    var i = folds.indexOf(fold);
                    if (i === 0) this.start.column += len;
                    for(i; i < folds.length; i++){
                        fold = folds[i];
                        fold.start.column += len;
                        if (!fold.sameRow) return;
                        fold.end.column += len;
                    }
                    this.end.column += len;
                }
            }
        };
        FoldLine.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside") return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i = folds.indexOf(fold);
            var foldBefore = folds[i - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i, folds.length - i);
            var newFoldLine = new FoldLine(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
        };
        FoldLine.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for(var i = 0; i < folds.length; i++)this.addFold(folds[i]);
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
        };
        FoldLine.prototype.toString = function() {
            var ret = [
                this.range.toString() + ": ["
            ];
            this.folds.forEach(function(fold) {
                ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
        };
        FoldLine.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for(var i = 0; i < this.folds.length; i++){
                var fold = this.folds[i];
                idx -= fold.start.column - lastFoldEndColumn;
                if (idx < 0) return {
                    row: fold.start.row,
                    column: fold.start.column + idx
                };
                idx -= fold.placeholder.length;
                if (idx < 0) return fold.start;
                lastFoldEndColumn = fold.end.column;
            }
            return {
                row: this.end.row,
                column: this.end.column + idx
            };
        };
        return FoldLine;
    }();
    exports.FoldLine = FoldLine;
});
ace.define("ace/range_list", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var Range = require("./range").Range;
    var comparePoints = Range.comparePoints;
    var RangeList = /** @class */ function() {
        function RangeList() {
            this.ranges = [];
            this.$bias = 1;
        }
        RangeList.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for(var i = startIndex || 0; i < list.length; i++){
                var range = list[i];
                var cmpEnd = comparePoints(pos, range.end);
                if (cmpEnd > 0) continue;
                var cmpStart = comparePoints(pos, range.start);
                if (cmpEnd === 0) return excludeEdges && cmpStart !== 0 ? -i - 2 : i;
                if (cmpStart > 0 || cmpStart === 0 && !excludeEdges) return i;
                return -i - 1;
            }
            return -i - 1;
        };
        RangeList.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0) startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0) endIndex = -endIndex - 1;
            else endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
        };
        RangeList.prototype.addList = function(list) {
            var removed = [];
            for(var i = list.length; i--;)removed.push.apply(removed, this.add(list[i]));
            return removed;
        };
        RangeList.prototype.substractPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0) return this.ranges.splice(i, 1);
        };
        RangeList.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a, b) {
                return comparePoints(a.start, b.start);
            });
            var next = list[0], range;
            for(var i = 1; i < list.length; i++){
                range = next;
                next = list[i];
                var cmp = comparePoints(range.end, next.start);
                if (cmp < 0) continue;
                if (cmp == 0 && !range.isEmpty() && !next.isEmpty()) continue;
                if (comparePoints(range.end, next.end) < 0) {
                    range.end.row = next.end.row;
                    range.end.column = next.end.column;
                }
                list.splice(i, 1);
                removed.push(next);
                next = range;
                i--;
            }
            this.ranges = list;
            return removed;
        };
        RangeList.prototype.contains = function(row, column) {
            return this.pointIndex({
                row: row,
                column: column
            }) >= 0;
        };
        RangeList.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
        };
        RangeList.prototype.rangeAtPoint = function(pos) {
            var i = this.pointIndex(pos);
            if (i >= 0) return this.ranges[i];
        };
        RangeList.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow) return [];
            var startIndex = this.pointIndex({
                row: startRow,
                column: 0
            });
            if (startIndex < 0) startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({
                row: endRow,
                column: 0
            }, startIndex);
            if (endIndex < 0) endIndex = -endIndex - 1;
            var clipped = [];
            for(var i = startIndex; i < endIndex; i++)clipped.push(list[i]);
            return clipped;
        };
        RangeList.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
        };
        RangeList.prototype.attach = function(session) {
            if (this.session) this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
        };
        RangeList.prototype.detach = function() {
            if (!this.session) return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
        };
        RangeList.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for(var i = 0, n = ranges.length; i < n; i++){
                var r = ranges[i];
                if (r.end.row >= startRow) break;
            }
            if (delta.action == "insert") {
                var lineDif = endRow - startRow;
                var colDiff = -start.column + end.column;
                for(; i < n; i++){
                    var r = ranges[i];
                    if (r.start.row > startRow) break;
                    if (r.start.row == startRow && r.start.column >= start.column) {
                        if (r.start.column == start.column && this.$bias <= 0) ;
                        else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    }
                    if (r.end.row == startRow && r.end.column >= start.column) {
                        if (r.end.column == start.column && this.$bias < 0) continue;
                        if (r.end.column == start.column && colDiff > 0 && i < n - 1) {
                            if (r.end.column > r.start.column && r.end.column == ranges[i + 1].start.column) r.end.column -= colDiff;
                        }
                        r.end.column += colDiff;
                        r.end.row += lineDif;
                    }
                }
            } else {
                var lineDif = startRow - endRow;
                var colDiff = start.column - end.column;
                for(; i < n; i++){
                    var r = ranges[i];
                    if (r.start.row > endRow) break;
                    if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                        r.end.row = startRow;
                        r.end.column = start.column;
                    } else if (r.end.row == endRow) {
                        if (r.end.column <= end.column) {
                            if (lineDif || r.end.column > start.column) {
                                r.end.column = start.column;
                                r.end.row = start.row;
                            }
                        } else {
                            r.end.column += colDiff;
                            r.end.row += lineDif;
                        }
                    } else if (r.end.row > endRow) r.end.row += lineDif;
                    if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                        r.start.row = startRow;
                        r.start.column = start.column;
                    } else if (r.start.row == endRow) {
                        if (r.start.column <= end.column) {
                            if (lineDif || r.start.column > start.column) {
                                r.start.column = start.column;
                                r.start.row = start.row;
                            }
                        } else {
                            r.start.column += colDiff;
                            r.start.row += lineDif;
                        }
                    } else if (r.start.row > endRow) r.start.row += lineDif;
                }
            }
            if (lineDif != 0 && i < n) for(; i < n; i++){
                var r = ranges[i];
                r.start.row += lineDif;
                r.end.row += lineDif;
            }
        };
        return RangeList;
    }();
    RangeList.prototype.comparePoints = comparePoints;
    exports.RangeList = RangeList;
});
ace.define("ace/edit_session/fold", [
    "require",
    "exports",
    "module",
    "ace/range_list"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var RangeList = require("../range_list").RangeList;
    var Fold = /** @class */ function(_super) {
        __extends(Fold, _super);
        function Fold(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
        }
        Fold.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
        };
        Fold.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
                fold.setFoldLine(foldLine);
            });
        };
        Fold.prototype.clone = function() {
            var range = this.range.clone();
            var fold = new Fold(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
                fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
        };
        Fold.prototype.addSubFold = function(fold) {
            if (this.range.isEqual(fold)) return;
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for(var i = 0, cmp = -1; i < this.subFolds.length; i++){
                cmp = this.subFolds[i].range.compare(row, column);
                if (cmp != 1) break;
            }
            var afterStart = this.subFolds[i];
            var firstConsumed = 0;
            if (cmp == 0) {
                if (afterStart.range.containsRange(fold)) return afterStart.addSubFold(fold);
                else firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for(var j = i, cmp = -1; j < this.subFolds.length; j++){
                cmp = this.subFolds[j].range.compare(row, column);
                if (cmp != 1) break;
            }
            if (cmp == 0) j++;
            var consumedFolds = this.subFolds.splice(i, j - i, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for(var k = firstConsumed; k < last; k++)fold.addSubFold(consumedFolds[k]);
            fold.setFoldLine(this.foldLine);
            return fold;
        };
        Fold.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
        };
        return Fold;
    }(RangeList);
    function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0) point.column -= anchor.column;
    }
    function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
    }
    function restorePoint(point, anchor) {
        if (point.row == 0) point.column += anchor.column;
        point.row += anchor.row;
    }
    function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
    }
    exports.Fold = Fold;
});
ace.define("ace/edit_session/folding", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/edit_session/fold_line",
    "ace/edit_session/fold",
    "ace/token_iterator",
    "ace/mouse/mouse_event"
], function(require, exports, module1) {
    "use strict";
    var Range = require("../range").Range;
    var FoldLine = require("./fold_line").FoldLine;
    var Fold = require("./fold").Fold;
    var TokenIterator = require("../token_iterator").TokenIterator;
    var MouseEvent = require("../mouse/mouse_event").MouseEvent;
    function Folding() {
        this.getFoldAt = function(row, column, side) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine) return null;
            var folds = foldLine.folds;
            for(var i = 0; i < folds.length; i++){
                var range = folds[i].range;
                if (range.contains(row, column)) {
                    if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) continue;
                    else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) continue;
                    return folds[i];
                }
            }
        };
        this.getFoldsInRange = function(range) {
            var start = range.start;
            var end = range.end;
            var foldLines = this.$foldData;
            var foundFolds = [];
            start.column += 1;
            end.column -= 1;
            for(var i = 0; i < foldLines.length; i++){
                var cmp = foldLines[i].range.compareRange(range);
                if (cmp == 2) continue;
                else if (cmp == -2) break;
                var folds = foldLines[i].folds;
                for(var j = 0; j < folds.length; j++){
                    var fold = folds[j];
                    cmp = fold.range.compareRange(range);
                    if (cmp == -2) break;
                    else if (cmp == 2) continue;
                    else if (cmp == 42) break;
                    foundFolds.push(fold);
                }
            }
            start.column -= 1;
            end.column += 1;
            return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
            if (Array.isArray(ranges)) {
                var folds = [];
                ranges.forEach(function(range) {
                    folds = folds.concat(this.getFoldsInRange(range));
                }, this);
            } else var folds = this.getFoldsInRange(ranges);
            return folds;
        };
        this.getAllFolds = function() {
            var folds = [];
            var foldLines = this.$foldData;
            for(var i = 0; i < foldLines.length; i++)for(var j = 0; j < foldLines[i].folds.length; j++)folds.push(foldLines[i].folds[j]);
            return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
            foldLine = foldLine || this.getFoldLine(row);
            if (!foldLine) return null;
            var lastFold = {
                end: {
                    column: 0
                }
            };
            var str, fold;
            for(var i = 0; i < foldLine.folds.length; i++){
                fold = foldLine.folds[i];
                var cmp = fold.range.compareEnd(row, column);
                if (cmp == -1) {
                    str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
                    break;
                } else if (cmp === 0) return null;
                lastFold = fold;
            }
            if (!str) str = this.getLine(fold.start.row).substring(lastFold.end.column);
            if (trim == -1) return str.substring(0, column - lastFold.end.column);
            else if (trim == 1) return str.substring(column - lastFold.end.column);
            else return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine) i = foldData.indexOf(startFoldLine);
            if (i == -1) i = 0;
            for(i; i < foldData.length; i++){
                var foldLine = foldData[i];
                if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) return foldLine;
                else if (foldLine.end.row > docRow) return null;
            }
            return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
            var foldData = this.$foldData;
            var i = 0;
            if (startFoldLine) i = foldData.indexOf(startFoldLine);
            if (i == -1) i = 0;
            for(i; i < foldData.length; i++){
                var foldLine = foldData[i];
                if (foldLine.end.row >= docRow) return foldLine;
            }
            return null;
        };
        this.getFoldedRowCount = function(first, last) {
            var foldData = this.$foldData, rowCount = last - first + 1;
            for(var i = 0; i < foldData.length; i++){
                var foldLine = foldData[i], end = foldLine.end.row, start = foldLine.start.row;
                if (end >= last) {
                    if (start < last) {
                        if (start >= first) rowCount -= last - start;
                        else rowCount = 0; // in one fold
                    }
                    break;
                } else if (end >= first) {
                    if (start >= first) rowCount -= end - start;
                    else rowCount -= end - first + 1;
                }
            }
            return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
            this.$foldData.push(foldLine);
            this.$foldData.sort(function(a, b) {
                return a.start.row - b.start.row;
            });
            return foldLine;
        };
        this.addFold = function(placeholder, range) {
            var foldData = this.$foldData;
            var added = false;
            var fold;
            if (placeholder instanceof Fold) fold = placeholder;
            else {
                fold = new Fold(range, placeholder);
                fold.collapseChildren = range.collapseChildren;
            }
            this.$clipRangeToDocument(fold.range);
            var startRow = fold.start.row;
            var startColumn = fold.start.column;
            var endRow = fold.end.row;
            var endColumn = fold.end.column;
            var startFold = this.getFoldAt(startRow, startColumn, 1);
            var endFold = this.getFoldAt(endRow, endColumn, -1);
            if (startFold && endFold == startFold) return startFold.addSubFold(fold);
            if (startFold && !startFold.range.isStart(startRow, startColumn)) this.removeFold(startFold);
            if (endFold && !endFold.range.isEnd(endRow, endColumn)) this.removeFold(endFold);
            var folds = this.getFoldsInRange(fold.range);
            if (folds.length > 0) {
                this.removeFolds(folds);
                if (!fold.collapseChildren) folds.forEach(function(subFold) {
                    fold.addSubFold(subFold);
                });
            }
            for(var i = 0; i < foldData.length; i++){
                var foldLine = foldData[i];
                if (endRow == foldLine.start.row) {
                    foldLine.addFold(fold);
                    added = true;
                    break;
                } else if (startRow == foldLine.end.row) {
                    foldLine.addFold(fold);
                    added = true;
                    if (!fold.sameRow) {
                        var foldLineNext = foldData[i + 1];
                        if (foldLineNext && foldLineNext.start.row == endRow) {
                            foldLine.merge(foldLineNext);
                            break;
                        }
                    }
                    break;
                } else if (endRow <= foldLine.start.row) break;
            }
            if (!added) foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
            if (this.$useWrapMode) this.$updateWrapData(foldLine.start.row, foldLine.start.row);
            else this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
            this.$modified = true;
            this._signal("changeFold", {
                data: fold,
                action: "add"
            });
            return fold;
        };
        this.addFolds = function(folds) {
            folds.forEach(function(fold) {
                this.addFold(fold);
            }, this);
        };
        this.removeFold = function(fold) {
            var foldLine = fold.foldLine;
            var startRow = foldLine.start.row;
            var endRow = foldLine.end.row;
            var foldLines = this.$foldData;
            var folds = foldLine.folds;
            if (folds.length == 1) foldLines.splice(foldLines.indexOf(foldLine), 1);
            else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
                folds.pop();
                foldLine.end.row = folds[folds.length - 1].end.row;
                foldLine.end.column = folds[folds.length - 1].end.column;
            } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
                folds.shift();
                foldLine.start.row = folds[0].start.row;
                foldLine.start.column = folds[0].start.column;
            } else if (fold.sameRow) folds.splice(folds.indexOf(fold), 1);
            else {
                var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
                folds = newFoldLine.folds;
                folds.shift();
                newFoldLine.start.row = folds[0].start.row;
                newFoldLine.start.column = folds[0].start.column;
            }
            if (!this.$updating) {
                if (this.$useWrapMode) this.$updateWrapData(startRow, endRow);
                else this.$updateRowLengthCache(startRow, endRow);
            }
            this.$modified = true;
            this._signal("changeFold", {
                data: fold,
                action: "remove"
            });
        };
        this.removeFolds = function(folds) {
            var cloneFolds = [];
            for(var i = 0; i < folds.length; i++)cloneFolds.push(folds[i]);
            cloneFolds.forEach(function(fold) {
                this.removeFold(fold);
            }, this);
            this.$modified = true;
        };
        this.expandFold = function(fold) {
            this.removeFold(fold);
            fold.subFolds.forEach(function(subFold) {
                fold.restoreRange(subFold);
                this.addFold(subFold);
            }, this);
            if (fold.collapseChildren > 0) this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
            fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
            folds.forEach(function(fold) {
                this.expandFold(fold);
            }, this);
        };
        this.unfold = function(location, expandInner) {
            var range, folds;
            if (location == null) {
                range = new Range(0, 0, this.getLength(), 0);
                if (expandInner == null) expandInner = true;
            } else if (typeof location == "number") range = new Range(location, 0, location, this.getLine(location).length);
            else if ("row" in location) range = Range.fromPoints(location, location);
            else if (Array.isArray(location)) {
                folds = [];
                location.forEach(function(range) {
                    folds = folds.concat(this.unfold(range));
                }, this);
                return folds;
            } else range = location;
            folds = this.getFoldsInRangeList(range);
            var outermostFolds = folds;
            while(folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0){
                this.expandFolds(folds);
                folds = this.getFoldsInRangeList(range);
            }
            if (expandInner != false) this.removeFolds(folds);
            else this.expandFolds(folds);
            if (outermostFolds.length) return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
            return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
            var foldLine = this.getFoldLine(docRow, startFoldRow);
            return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
            if (startRow == null) startRow = foldLine.start.row;
            if (startColumn == null) startColumn = 0;
            if (endRow == null) endRow = foldLine.end.row;
            if (endColumn == null) endColumn = this.getLine(endRow).length;
            var doc = this.doc;
            var textLine = "";
            foldLine.walk(function(placeholder, row, column, lastColumn) {
                if (row < startRow) return;
                if (row == startRow) {
                    if (column < startColumn) return;
                    lastColumn = Math.max(startColumn, lastColumn);
                }
                if (placeholder != null) textLine += placeholder;
                else textLine += doc.getLine(row).substring(lastColumn, column);
            }, endRow, endColumn);
            return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
            var foldLine = this.getFoldLine(row);
            if (!foldLine) {
                var line;
                line = this.doc.getLine(row);
                return line.substring(startColumn || 0, endColumn || line.length);
            } else return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
        };
        this.$cloneFoldData = function() {
            var fd = [];
            fd = this.$foldData.map(function(foldLine) {
                var folds = foldLine.folds.map(function(fold) {
                    return fold.clone();
                });
                return new FoldLine(fd, folds);
            });
            return fd;
        };
        this.toggleFold = function(tryToUnfold) {
            var selection = this.selection;
            var range = selection.getRange();
            var fold;
            var bracketPos;
            if (range.isEmpty()) {
                var cursor = range.start;
                fold = this.getFoldAt(cursor.row, cursor.column);
                if (fold) {
                    this.expandFold(fold);
                    return;
                } else if (tryToUnfold) {
                    var foldLine = this.getFoldLine(cursor.row);
                    if (foldLine) this.expandFolds(foldLine.folds);
                    return;
                } else if (bracketPos = this.findMatchingBracket(cursor)) {
                    if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;
                    else {
                        range.start = bracketPos;
                        range.start.column++;
                        range.end.column--;
                    }
                } else if (bracketPos = this.findMatchingBracket({
                    row: cursor.row,
                    column: cursor.column + 1
                })) {
                    if (range.comparePoint(bracketPos) == 1) range.end = bracketPos;
                    else range.start = bracketPos;
                    range.start.column++;
                } else range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            } else {
                var folds = this.getFoldsInRange(range);
                if (tryToUnfold && folds.length) {
                    this.expandFolds(folds);
                    return;
                } else if (folds.length == 1) fold = folds[0];
            }
            if (!fold) fold = this.getFoldAt(range.start.row, range.start.column);
            if (fold && fold.range.toString() == range.toString()) {
                this.expandFold(fold);
                return;
            }
            var placeholder = "...";
            if (!range.isMultiLine()) {
                placeholder = this.getTextRange(range);
                if (placeholder.length < 4) return;
                placeholder = placeholder.trim().substring(0, 2) + "..";
            }
            this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
            var iterator = new TokenIterator(this, row, column);
            var token = iterator.getCurrentToken();
            var type = token && token.type;
            if (token && /^comment|string/.test(type)) {
                type = type.match(/comment|string/)[0];
                if (type == "comment") type += "|doc-start|\\.doc";
                var re = new RegExp(type);
                var range = new Range();
                if (dir != 1) {
                    do token = iterator.stepBackward();
                    while (token && re.test(token.type));
                    token = iterator.stepForward();
                }
                range.start.row = iterator.getCurrentTokenRow();
                range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
                iterator = new TokenIterator(this, row, column);
                var initState = this.getState(iterator.$row);
                if (dir != -1) {
                    var lastRow = -1;
                    do {
                        token = iterator.stepForward();
                        if (lastRow == -1) {
                            var state = this.getState(iterator.$row);
                            if (initState.toString() !== state.toString()) lastRow = iterator.$row;
                        } else if (iterator.$row > lastRow) break;
                    }while (token && re.test(token.type));
                    token = iterator.stepBackward();
                } else token = iterator.getCurrentToken();
                range.end.row = iterator.getCurrentTokenRow();
                range.end.column = iterator.getCurrentTokenColumn();
                if (range.start.row == range.end.row && range.start.column > range.end.column) return;
                return range;
            }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
            if (depth == undefined) depth = 100000; // JSON.stringify doesn't hanle Infinity
            var foldWidgets = this.foldWidgets;
            if (!foldWidgets) return; // mode doesn't support folding
            endRow = endRow || this.getLength();
            startRow = startRow || 0;
            for(var row = startRow; row < endRow; row++){
                if (foldWidgets[row] == null) foldWidgets[row] = this.getFoldWidget(row);
                if (foldWidgets[row] != "start") continue;
                if (test && !test(row)) continue;
                var range = this.getFoldWidgetRange(row);
                if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
                    row = range.end.row;
                    range.collapseChildren = depth;
                    this.addFold("...", range);
                }
            }
        };
        this.foldToLevel = function(level) {
            this.foldAll();
            while(level-- > 0)this.unfold(null, false);
        };
        this.foldAllComments = function() {
            var session = this;
            this.foldAll(null, null, null, function(row) {
                var tokens = session.getTokens(row);
                for(var i = 0; i < tokens.length; i++){
                    var token = tokens[i];
                    if (token.type == "text" && /^\s+$/.test(token.value)) continue;
                    if (/comment/.test(token.type)) return true;
                    return false;
                }
            });
        };
        this.$foldStyles = {
            "manual": 1,
            "markbegin": 1,
            "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
            if (!this.$foldStyles[style]) throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
            if (this.$foldStyle == style) return;
            this.$foldStyle = style;
            if (style == "manual") this.unfold();
            var mode = this.$foldMode;
            this.$setFolding(null);
            this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
            if (this.$foldMode == foldMode) return;
            this.$foldMode = foldMode;
            this.off("change", this.$updateFoldWidgets);
            this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
            this._signal("changeAnnotation");
            if (!foldMode || this.$foldStyle == "manual") {
                this.foldWidgets = null;
                return;
            }
            this.foldWidgets = [];
            this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
            this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
            this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
            this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
            this.on("change", this.$updateFoldWidgets);
            this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
            var fw = this.foldWidgets;
            if (!fw || ignoreCurrent && fw[row]) return {};
            var i = row - 1, firstRange;
            while(i >= 0){
                var c = fw[i];
                if (c == null) c = fw[i] = this.getFoldWidget(i);
                if (c == "start") {
                    var range = this.getFoldWidgetRange(i);
                    if (!firstRange) firstRange = range;
                    if (range && range.end.row >= row) break;
                }
                i--;
            }
            return {
                range: i !== -1 && range,
                firstRange: firstRange
            };
        };
        this.onFoldWidgetClick = function(row, e) {
            if (e instanceof MouseEvent) e = e.domEvent;
            var options = {
                children: e.shiftKey,
                all: e.ctrlKey || e.metaKey,
                siblings: e.altKey
            };
            var range = this.$toggleFoldWidget(row, options);
            if (!range) {
                var el = e.target || e.srcElement;
                if (el && /ace_fold-widget/.test(el.className)) el.className += " ace_invalid";
            }
        };
        this.$toggleFoldWidget = function(row, options) {
            if (!this.getFoldWidget) return;
            var type = this.getFoldWidget(row);
            var line = this.getLine(row);
            var dir = type === "end" ? -1 : 1;
            var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
            if (fold) {
                if (options.children || options.all) this.removeFold(fold);
                else this.expandFold(fold);
                return fold;
            }
            var range = this.getFoldWidgetRange(row, true);
            if (range && !range.isMultiLine()) {
                fold = this.getFoldAt(range.start.row, range.start.column, 1);
                if (fold && range.isEqual(fold.range)) {
                    this.removeFold(fold);
                    return fold;
                }
            }
            if (options.siblings) {
                var data = this.getParentFoldRangeData(row);
                if (data.range) {
                    var startRow = data.range.start.row + 1;
                    var endRow = data.range.end.row;
                }
                this.foldAll(startRow, endRow, options.all ? 10000 : 0);
            } else if (options.children) {
                endRow = range ? range.end.row : this.getLength();
                this.foldAll(row + 1, endRow, options.all ? 10000 : 0);
            } else if (range) {
                if (options.all) range.collapseChildren = 10000;
                this.addFold("...", range);
            }
            return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
            var row = this.selection.getCursor().row;
            row = this.getRowFoldStart(row);
            var range = this.$toggleFoldWidget(row, {});
            if (range) return;
            var data = this.getParentFoldRangeData(row, true);
            range = data.range || data.firstRange;
            if (range) {
                row = range.start.row;
                var fold = this.getFoldAt(row, this.getLine(row).length, 1);
                if (fold) this.removeFold(fold);
                else this.addFold("...", range);
            }
        };
        this.updateFoldWidgets = function(delta) {
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) this.foldWidgets[firstRow] = null;
            else if (delta.action == "remove") this.foldWidgets.splice(firstRow, len + 1, null);
            else {
                var args = Array(len + 1);
                args.unshift(firstRow, 1);
                this.foldWidgets.splice.apply(this.foldWidgets, args);
            }
        };
        this.tokenizerUpdateFoldWidgets = function(e) {
            var rows = e.data;
            if (rows.first != rows.last) {
                if (this.foldWidgets.length > rows.first) this.foldWidgets.splice(rows.first, this.foldWidgets.length);
            }
        };
    }
    exports.Folding = Folding;
});
ace.define("ace/edit_session/bracket_match", [
    "require",
    "exports",
    "module",
    "ace/token_iterator",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var TokenIterator = require("../token_iterator").TokenIterator;
    var Range = require("../range").Range;
    function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
            if (position.column == 0) return null;
            var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
            if (charBeforeCursor == "") return null;
            var match = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) return null;
            if (match[1]) return this.$findClosingBracket(match[1], position);
            else return this.$findOpeningBracket(match[2], position);
        };
        this.getBracketRange = function(pos) {
            var line = this.getLine(pos.row);
            var before = true, range;
            var chr = line.charAt(pos.column - 1);
            var match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            if (!match) {
                chr = line.charAt(pos.column);
                pos = {
                    row: pos.row,
                    column: pos.column + 1
                };
                match = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
                before = false;
            }
            if (!match) return null;
            if (match[1]) {
                var bracketPos = this.$findClosingBracket(match[1], pos);
                if (!bracketPos) return null;
                range = Range.fromPoints(pos, bracketPos);
                if (!before) {
                    range.end.column++;
                    range.start.column--;
                }
                range.cursor = range.end;
            } else {
                var bracketPos = this.$findOpeningBracket(match[2], pos);
                if (!bracketPos) return null;
                range = Range.fromPoints(bracketPos, pos);
                if (!before) {
                    range.start.column++;
                    range.end.column--;
                }
                range.cursor = range.start;
            }
            return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
            var line = this.getLine(pos.row);
            var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
            var chr = !isBackwards && line.charAt(pos.column - 1);
            var match = chr && chr.match(bracketsRegExp);
            if (!match) {
                chr = (isBackwards === undefined || isBackwards) && line.charAt(pos.column);
                pos = {
                    row: pos.row,
                    column: pos.column + 1
                };
                match = chr && chr.match(bracketsRegExp);
            }
            if (!match) return null;
            var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
            var bracketPos = match[1] ? this.$findClosingBracket(match[1], pos) : this.$findOpeningBracket(match[2], pos);
            if (!bracketPos) return [
                startRange
            ];
            var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
            return [
                startRange,
                endRange
            ];
        };
        this.$brackets = {
            ")": "(",
            "(": ")",
            "]": "[",
            "[": "]",
            "{": "}",
            "}": "{",
            "<": ">",
            ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
            var openBracket = this.$brackets[bracket];
            var depth = 1;
            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token) token = iterator.stepForward();
            if (!token) return;
            if (!typeRe) typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
            var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
            var value = token.value;
            while(true){
                while(valueIndex >= 0){
                    var chr = value.charAt(valueIndex);
                    if (chr == openBracket) {
                        depth -= 1;
                        if (depth == 0) return {
                            row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()
                        };
                    } else if (chr == bracket) depth += 1;
                    valueIndex -= 1;
                }
                do token = iterator.stepBackward();
                while (token && !typeRe.test(token.type));
                if (token == null) break;
                value = token.value;
                valueIndex = value.length - 1;
            }
            return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
            var closingBracket = this.$brackets[bracket];
            var depth = 1;
            var iterator = new TokenIterator(this, position.row, position.column);
            var token = iterator.getCurrentToken();
            if (!token) token = iterator.stepForward();
            if (!token) return;
            if (!typeRe) typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
            var valueIndex = position.column - iterator.getCurrentTokenColumn();
            while(true){
                var value = token.value;
                var valueLength = value.length;
                while(valueIndex < valueLength){
                    var chr = value.charAt(valueIndex);
                    if (chr == closingBracket) {
                        depth -= 1;
                        if (depth == 0) return {
                            row: iterator.getCurrentTokenRow(),
                            column: valueIndex + iterator.getCurrentTokenColumn()
                        };
                    } else if (chr == bracket) depth += 1;
                    valueIndex += 1;
                }
                do token = iterator.stepForward();
                while (token && !typeRe.test(token.type));
                if (token == null) break;
                valueIndex = 0;
            }
            return null;
        };
        this.getMatchingTags = function(pos) {
            var iterator = new TokenIterator(this, pos.row, pos.column);
            var token = this.$findTagName(iterator);
            if (!token) return;
            var prevToken = iterator.stepBackward();
            if (prevToken.value === "<") return this.$findClosingTag(iterator, token);
            else return this.$findOpeningTag(iterator, token);
        };
        this.$findTagName = function(iterator) {
            var token = iterator.getCurrentToken();
            var found = false;
            var backward = false;
            if (token && token.type.indexOf("tag-name") === -1) do {
                if (backward) token = iterator.stepBackward();
                else token = iterator.stepForward();
                if (token) {
                    if (token.value === "/>") backward = true;
                    else if (token.type.indexOf("tag-name") !== -1) found = true;
                }
            }while (token && !found);
            return token;
        };
        this.$findClosingTag = function(iterator, token) {
            var prevToken;
            var currentTag = token.value;
            var tag = token.value;
            var depth = 0;
            var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
            token = iterator.stepForward();
            var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
            var foundOpenTagEnd = false;
            do {
                prevToken = token;
                if (prevToken.type.indexOf("tag-close") !== -1 && !foundOpenTagEnd) {
                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
                    foundOpenTagEnd = true;
                }
                token = iterator.stepForward();
                if (token) {
                    if (token.value === ">" && !foundOpenTagEnd) {
                        var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for `>`
                        foundOpenTagEnd = true;
                    }
                    if (token.type.indexOf("tag-name") !== -1) {
                        currentTag = token.value;
                        if (tag === currentTag) {
                            if (prevToken.value === "<") depth++;
                            else if (prevToken.value === "</") {
                                depth--;
                                if (depth < 0) {
                                    iterator.stepBackward();
                                    var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2); //Range for </
                                    token = iterator.stepForward();
                                    var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                                    if (token.type.indexOf("tag-close") === -1) token = iterator.stepForward();
                                    if (token && token.value === ">") var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                                    else return;
                                }
                            }
                        }
                    } else if (tag === currentTag && token.value === "/>") {
                        depth--;
                        if (depth < 0) {
                            var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                            var closeTagName = closeTagStart;
                            var closeTagEnd = closeTagName;
                            var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                        }
                    }
                }
            }while (token && depth >= 0);
            if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        };
        this.$findOpeningTag = function(iterator, token) {
            var prevToken = iterator.getCurrentToken();
            var tag = token.value;
            var depth = 0;
            var startRow = iterator.getCurrentTokenRow();
            var startColumn = iterator.getCurrentTokenColumn();
            var endColumn = startColumn + 2;
            var closeTagStart = new Range(startRow, startColumn, startRow, endColumn); //Range for </
            iterator.stepForward();
            var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
            if (token.type.indexOf("tag-close") === -1) token = iterator.stepForward();
            if (!token || token.value !== ">") return;
            var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
            iterator.stepBackward();
            iterator.stepBackward();
            do {
                token = prevToken;
                startRow = iterator.getCurrentTokenRow();
                startColumn = iterator.getCurrentTokenColumn();
                endColumn = startColumn + token.value.length;
                prevToken = iterator.stepBackward();
                if (token) {
                    if (token.type.indexOf("tag-name") !== -1) {
                        if (tag === token.value) {
                            if (prevToken.value === "<") {
                                depth++;
                                if (depth > 0) {
                                    var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                                    var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for <
                                    do token = iterator.stepForward();
                                    while (token && token.value !== ">");
                                    var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1); //Range for >
                                }
                            } else if (prevToken.value === "</") depth--;
                        }
                    } else if (token.value === "/>") {
                        var stepCount = 0;
                        var tmpToken = prevToken;
                        while(tmpToken){
                            if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                                depth--;
                                break;
                            } else if (tmpToken.value === "<") break;
                            tmpToken = iterator.stepBackward();
                            stepCount++;
                        }
                        for(var i = 0; i < stepCount; i++)iterator.stepForward();
                    }
                }
            }while (prevToken && depth <= 0);
            if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) return {
                openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
                closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
                openTagName: openTagName,
                closeTagName: closeTagName
            };
        };
    }
    exports.BracketMatch = BracketMatch;
});
ace.define("ace/edit_session", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/bidihandler",
    "ace/config",
    "ace/lib/event_emitter",
    "ace/selection",
    "ace/mode/text",
    "ace/range",
    "ace/line_widgets",
    "ace/document",
    "ace/background_tokenizer",
    "ace/search_highlight",
    "ace/undomanager",
    "ace/edit_session/folding",
    "ace/edit_session/bracket_match"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var lang = require("./lib/lang");
    var BidiHandler = require("./bidihandler").BidiHandler;
    var config = require("./config");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var Selection = require("./selection").Selection;
    var TextMode = require("./mode/text").Mode;
    var Range = require("./range").Range;
    var LineWidgets = require("./line_widgets").LineWidgets;
    var Document = require("./document").Document;
    var BackgroundTokenizer = require("./background_tokenizer").BackgroundTokenizer;
    var SearchHighlight = require("./search_highlight").SearchHighlight;
    var UndoManager = require("./undomanager").UndoManager;
    var EditSession = /** @class */ function() {
        function EditSession(text, mode) {
            this.doc;
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$editor = null;
            this.prevOp = {};
            this.$foldData = [];
            this.id = "session" + ++EditSession.$uid;
            this.$foldData.toString = function() {
                return this.join("\n");
            };
            this.$gutterCustomWidgets = {};
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e) {
                _self._signal("tokenizerUpdate", e);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine) text = new Document(/**@type{string}*/ text);
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.selection.on("changeCursor", this.$onSelectionChange);
            this.$bidiHandler = new BidiHandler(this);
            config.resetOptions(this);
            this.setMode(mode);
            config._signal("session", this);
            this.destroyed = false;
            this.$initOperationListeners();
        }
        EditSession.prototype.$initOperationListeners = function() {
            var _this = this;
            this.curOp = null;
            this.on("change", function() {
                if (!_this.curOp) {
                    _this.startOperation();
                    _this.curOp.selectionBefore = _this.$lastSel;
                }
                _this.curOp.docChanged = true;
            }, true);
            this.on("changeSelection", function() {
                if (!_this.curOp) {
                    _this.startOperation();
                    _this.curOp.selectionBefore = _this.$lastSel;
                }
                _this.curOp.selectionChanged = true;
            }, true);
            this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
        };
        EditSession.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
                if (!commandEvent || this.curOp.command) return;
                this.prevOp = this.curOp;
            }
            if (!commandEvent) commandEvent = {};
            this.$operationResetTimer.schedule();
            this.curOp = {
                command: commandEvent.command || {},
                args: commandEvent.args
            };
            this.curOp.selectionBefore = this.selection.toJSON();
            this._signal("startOperation", commandEvent);
        };
        EditSession.prototype.endOperation = function(e) {
            if (this.curOp) {
                if (e && e.returnValue === false) {
                    this.curOp = null;
                    this._signal("endOperation", e);
                    return;
                }
                if (e == true && this.curOp.command && this.curOp.command.name == "mouse") return;
                var currentSelection = this.selection.toJSON();
                this.curOp.selectionAfter = currentSelection;
                this.$lastSel = this.selection.toJSON();
                this.getUndoManager().addSelection(currentSelection);
                this._signal("beforeEndOperation");
                this.prevOp = this.curOp;
                this.curOp = null;
                this._signal("endOperation", e);
            }
        };
        EditSession.prototype.setDocument = function(doc) {
            if (this.doc) this.doc.off("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
        };
        EditSession.prototype.getDocument = function() {
            return this.doc;
        };
        Object.defineProperty(EditSession.prototype, "widgetManager", {
            get: function() {
                var widgetManager = new LineWidgets(this);
                this.widgetManager = widgetManager;
                if (this.$editor) widgetManager.attach(this.$editor);
                return widgetManager;
            },
            set: function(value) {
                Object.defineProperty(this, "widgetManager", {
                    writable: true,
                    enumerable: true,
                    configurable: true,
                    value: value
                });
            },
            enumerable: false,
            configurable: true
        });
        EditSession.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
                this.$docRowCache = [];
                this.$screenRowCache = [];
                return;
            }
            var l = this.$docRowCache.length;
            var i = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i) {
                this.$docRowCache.splice(i, l);
                this.$screenRowCache.splice(i, l);
            }
        };
        EditSession.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while(low <= hi){
                var mid = low + hi >> 1;
                var c = cacheArray[mid];
                if (val > c) low = mid + 1;
                else if (val < c) hi = mid - 1;
                else return mid;
            }
            return low - 1;
        };
        EditSession.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed) this.bgTokenizer.start(0);
        };
        EditSession.prototype.onChangeFold = function(e) {
            var fold = e.data;
            this.$resetRowCache(fold.start.row);
        };
        EditSession.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
                if (removedFolds && removedFolds.length) {
                    this.$undoManager.add({
                        action: "removeFolds",
                        folds: removedFolds
                    }, this.mergeUndoDeltas);
                    this.mergeUndoDeltas = true;
                }
                this.$undoManager.add(delta, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
                this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
        };
        EditSession.prototype.onSelectionChange = function() {
            this._signal("changeSelection");
        };
        EditSession.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
        };
        EditSession.fromJSON = function(session) {
            if (typeof session == "string") session = JSON.parse(session);
            var undoManager = new UndoManager();
            undoManager.$undoStack = session.history.undo;
            undoManager.$redoStack = session.history.redo;
            undoManager.mark = session.history.mark;
            undoManager.$rev = session.history.rev;
            var editSession = new EditSession(session.value);
            session.folds.forEach(function(fold) {
                editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
            });
            editSession.setAnnotations(session.annotations);
            editSession.setBreakpoints(session.breakpoints);
            editSession.setMode(session.mode);
            editSession.setScrollLeft(session.scrollLeft);
            editSession.setScrollTop(session.scrollTop);
            editSession.setUndoManager(undoManager);
            editSession.selection.fromJSON(session.selection);
            return editSession;
        };
        EditSession.prototype.toJSON = function() {
            return {
                annotations: this.$annotations,
                breakpoints: this.$breakpoints,
                folds: this.getAllFolds().map(function(fold) {
                    return fold.range;
                }),
                history: this.getUndoManager(),
                mode: this.$mode.$id,
                scrollLeft: this.$scrollLeft,
                scrollTop: this.$scrollTop,
                selection: this.selection.toJSON(),
                value: this.doc.getValue()
            };
        };
        EditSession.prototype.toString = function() {
            return this.doc.getValue();
        };
        EditSession.prototype.getSelection = function() {
            return this.selection;
        };
        EditSession.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
        };
        EditSession.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
        };
        EditSession.prototype.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c = 0;
            if (column == null) {
                var i = tokens.length - 1;
                c = this.getLine(row).length;
            } else for(var i = 0; i < tokens.length; i++){
                c += tokens[i].value.length;
                if (c >= column) break;
            }
            token = tokens[i];
            if (!token) return null;
            token.index = i;
            token.start = c - token.value.length;
            return token;
        };
        EditSession.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager) this.$informUndoManager.cancel();
            if (undoManager) {
                var self1 = this;
                undoManager.addSession(this);
                this.$syncInformUndoManager = function() {
                    self1.$informUndoManager.cancel();
                    self1.mergeUndoDeltas = false;
                };
                this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else this.$syncInformUndoManager = function() {};
        };
        EditSession.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager) this.$syncInformUndoManager();
        };
        EditSession.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
        };
        EditSession.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) return lang.stringRepeat(" ", this.getTabSize());
            else return "	";
        };
        EditSession.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
        };
        EditSession.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        };
        EditSession.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
        };
        EditSession.prototype.getTabSize = function() {
            return this.$tabSize;
        };
        EditSession.prototype.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
        };
        EditSession.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
        };
        EditSession.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
        };
        EditSession.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
        };
        EditSession.prototype.getOverwrite = function() {
            return this.$overwrite;
        };
        EditSession.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
        };
        EditSession.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row]) this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.removeGutterCustomWidget = function(row) {
            if (this.$editor) this.$editor.renderer.$gutterLayer.$removeCustomWidget(row);
        };
        EditSession.prototype.addGutterCustomWidget = function(row, attributes) {
            if (this.$editor) this.$editor.renderer.$gutterLayer.$addCustomWidget(row, attributes);
        };
        EditSession.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.getBreakpoints = function() {
            return this.$breakpoints;
        };
        EditSession.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for(var i = 0; i < rows.length; i++)this.$breakpoints[rows[i]] = "ace_breakpoint";
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.setBreakpoint = function(row, className) {
            if (className === undefined) className = "ace_breakpoint";
            if (className) this.$breakpoints[row] = className;
            else delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
        };
        EditSession.prototype.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
                range: range,
                type: type || "line",
                renderer: typeof type == "function" ? type : null,
                clazz: clazz,
                inFront: !!inFront,
                id: id
            };
            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }
            return id;
        };
        EditSession.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update) return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
                this.$frontMarkers[id] = marker;
                this._signal("changeFrontMarker");
            } else {
                this.$backMarkers[id] = marker;
                this._signal("changeBackMarker");
            }
            return marker;
        };
        EditSession.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker) return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
        };
        EditSession.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
        };
        EditSession.prototype.highlight = function(re) {
            if (!this.$searchHighlight) {
                var highlight = new SearchHighlight(null, "ace_selected-word", "text");
                this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re);
        };
        EditSession.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
                clazz = endRow;
                endRow = startRow;
            }
            if (!clazz) clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
        };
        EditSession.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
        };
        EditSession.prototype.getAnnotations = function() {
            return this.$annotations || [];
        };
        EditSession.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
        };
        EditSession.prototype.$detectNewLine = function(text) {
            var match = text.match(/^.*?(\r?\n)/m);
            if (match) this.$autoNewLine = match[1];
            else this.$autoNewLine = "\n";
        };
        EditSession.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0) inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken) inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken) var re = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1))) var re = /\s/;
            else var re = this.nonTokenRe;
            var start = column;
            if (start > 0) {
                do start--;
                while (start >= 0 && line.charAt(start).match(re));
                start++;
            }
            var end = column;
            while(end < line.length && line.charAt(end).match(re))end++;
            return new Range(row, start, row, end);
        };
        EditSession.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while(line.charAt(wordRange.end.column).match(/[ \t]/))wordRange.end.column += 1;
            return wordRange;
        };
        EditSession.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
        };
        EditSession.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
        };
        EditSession.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
        };
        EditSession.prototype.getUseWorker = function() {
            return this.$useWorker;
        };
        EditSession.prototype.onReloadTokenizer = function(e) {
            var rows = e.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e);
        };
        EditSession.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
                if (mode.getTokenizer) return this.$onChangeMode(mode);
                var options = mode;
                var path = options.path;
            } else path = /**@type{string}*/ mode || "ace/mode/text";
            if (!this.$modes["ace/mode/text"]) this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
                cb && cb();
                return;
            }
            this.$modeId = path;
            config.loadModule([
                "mode",
                path
            ], (function(m) {
                if (this.destroyed) return;
                if (this.$modeId !== path) return cb && cb();
                if (this.$modes[path] && !options) this.$onChangeMode(this.$modes[path]);
                else if (m && m.Mode) {
                    m = new m.Mode(options);
                    if (!options) {
                        this.$modes[path] = m;
                        m.$id = path;
                    }
                    this.$onChangeMode(m);
                }
                cb && cb();
            }).bind(this));
            if (!this.$mode) this.$onChangeMode(this.$modes["ace/mode/text"], true);
        };
        EditSession.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder) this.$modeId = mode.$id;
            if (this.$mode === mode) return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker) this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== undefined) {
                var onReloadTokenizer = this.onReloadTokenizer.bind(this);
                tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
                if (mode.attachToSession) mode.attachToSession(this);
                this.$options.wrapMethod.set.call(this, this.$wrapMethod);
                this.$setFolding(mode.foldingRules);
                this.bgTokenizer.start(0);
                this._emit("changeMode", {
                    oldMode: oldMode,
                    mode: mode
                });
            }
        };
        EditSession.prototype.$stopWorker = function() {
            if (this.$worker) {
                this.$worker.terminate();
                this.$worker = null;
            }
        };
        EditSession.prototype.$startWorker = function() {
            try {
                this.$worker = this.$mode.createWorker(this);
            } catch (e) {
                config.warn("Could not load worker", e);
                this.$worker = null;
            }
        };
        EditSession.prototype.getMode = function() {
            return this.$mode;
        };
        EditSession.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop)) return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
        };
        EditSession.prototype.getScrollTop = function() {
            return this.$scrollTop;
        };
        EditSession.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft)) return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
        };
        EditSession.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
        };
        EditSession.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets) return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
        };
        EditSession.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null) return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w) {
                if (w && w.screenWidth > width) width = w.screenWidth;
            });
            return this.lineWidgetWidth = width;
        };
        EditSession.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
                this.$modified = false;
                if (this.$useWrapMode) return this.screenWidth = this.$wrapLimit;
                var lines = this.doc.getAllLines();
                var cache = this.$rowLengthCache;
                var longestScreenLine = 0;
                var foldIndex = 0;
                var foldLine = this.$foldData[foldIndex];
                var foldStart = foldLine ? foldLine.start.row : Infinity;
                var len = lines.length;
                for(var i = 0; i < len; i++){
                    if (i > foldStart) {
                        i = foldLine.end.row + 1;
                        if (i >= len) break;
                        foldLine = this.$foldData[foldIndex++];
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }
                    if (cache[i] == null) cache[i] = this.$getStringScreenWidth(lines[i])[0];
                    if (cache[i] > longestScreenLine) longestScreenLine = cache[i];
                }
                this.screenWidth = longestScreenLine;
            }
        };
        EditSession.prototype.getLine = function(row) {
            return this.doc.getLine(row);
        };
        EditSession.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
        };
        EditSession.prototype.getLength = function() {
            return this.doc.getLength();
        };
        EditSession.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
        };
        EditSession.prototype.insert = function(position, text) {
            return this.doc.insert(position, text);
        };
        EditSession.prototype.remove = function(range) {
            return this.doc.remove(range);
        };
        EditSession.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
        };
        EditSession.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length) return;
            this.$fromUndo = true;
            for(var i = deltas.length - 1; i != -1; i--){
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") this.doc.revertDelta(delta);
                else if (delta.folds) this.addFolds(delta.folds);
            }
            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionBefore) this.selection.fromJSON(deltas.selectionBefore);
                else this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
        };
        EditSession.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length) return;
            this.$fromUndo = true;
            for(var i = 0; i < deltas.length; i++){
                var delta = deltas[i];
                if (delta.action == "insert" || delta.action == "remove") this.doc.$safeApplyDelta(delta);
            }
            if (!dontSelect && this.$undoSelect) {
                if (deltas.selectionAfter) this.selection.fromJSON(deltas.selectionAfter);
                else this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
        };
        EditSession.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
        };
        EditSession.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta) {
                return isUndo ? delta.action !== "insert" : delta.action === "insert";
            }
            var range, point;
            for(var i = 0; i < deltas.length; i++){
                var delta = deltas[i];
                if (!delta.start) continue; // skip folds
                if (!range) {
                    if (isInsert(delta)) range = Range.fromPoints(delta.start, delta.end);
                    else range = Range.fromPoints(delta.start, delta.start);
                    continue;
                }
                if (isInsert(delta)) {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) range.setStart(point);
                    point = delta.end;
                    if (range.compare(point.row, point.column) == 1) range.setEnd(point);
                } else {
                    point = delta.start;
                    if (range.compare(point.row, point.column) == -1) range = Range.fromPoints(delta.start, delta.start);
                }
            }
            return range;
        };
        EditSession.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
        };
        EditSession.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
                this.remove(fromRange);
                var rowDiff = fromRange.start.row - fromRange.end.row;
                var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
                if (collDiff) {
                    if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column) toRange.start.column += collDiff;
                    if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column) toRange.end.column += collDiff;
                }
                if (rowDiff && toRange.start.row >= fromRange.end.row) {
                    toRange.start.row += rowDiff;
                    toRange.end.row += rowDiff;
                }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
                var oldStart = fromRange.start;
                var newStart = toRange.start;
                var rowDiff = newStart.row - oldStart.row;
                var collDiff = newStart.column - oldStart.column;
                this.addFolds(folds.map(function(x) {
                    x = x.clone();
                    if (x.start.row == oldStart.row) x.start.column += collDiff;
                    if (x.end.row == oldStart.row) x.end.column += collDiff;
                    x.start.row += rowDiff;
                    x.end.row += rowDiff;
                    return x;
                }));
            }
            return toRange;
        };
        EditSession.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for(var row = startRow; row <= endRow; row++)this.doc.insertInLine({
                row: row,
                column: 0
            }, indentString);
        };
        EditSession.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for(var i = rowRange.start.row; i <= rowRange.end.row; ++i){
                var line = this.getLine(i);
                deleteRange.start.row = i;
                deleteRange.end.row = i;
                for(var j = 0; j < size; ++j)if (line.charAt(j) != " ") break;
                if (j < size && line.charAt(j) == "	") {
                    deleteRange.start.column = j;
                    deleteRange.end.column = j + 1;
                } else {
                    deleteRange.start.column = 0;
                    deleteRange.end.column = j;
                }
                this.remove(deleteRange);
            }
        };
        EditSession.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
                var row = this.getRowFoldStart(firstRow + dir);
                if (row < 0) return 0;
                var diff = row - firstRow;
            } else if (dir > 0) {
                var row = this.getRowFoldEnd(lastRow + dir);
                if (row > this.doc.getLength() - 1) return 0;
                var diff = row - lastRow;
            } else {
                firstRow = this.$clipRowToDocument(firstRow);
                lastRow = this.$clipRowToDocument(lastRow);
                var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x) {
                x = x.clone();
                x.start.row += diff;
                x.end.row += diff;
                return x;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
        };
        EditSession.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
        };
        EditSession.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
        };
        EditSession.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
        };
        EditSession.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
        };
        EditSession.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0) return 0;
            return Math.min(this.doc.getLine(row).length, column);
        };
        EditSession.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
                row = 0;
                column = 0;
            } else {
                var len = this.doc.getLength();
                if (row >= len) {
                    row = len - 1;
                    column = this.doc.getLine(len - 1).length;
                } else column = Math.min(this.doc.getLine(row).length, column);
            }
            return {
                row: row,
                column: column
            };
        };
        EditSession.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
                range.start.row = 0;
                range.start.column = 0;
            } else range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
                range.end.row = len;
                range.end.column = this.doc.getLine(len).length;
            } else range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            return range;
        };
        EditSession.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
                this.$useWrapMode = useWrapMode;
                this.$modified = true;
                this.$resetRowCache(0);
                if (useWrapMode) {
                    var len = this.getLength();
                    this.$wrapData = Array(len);
                    this.$updateWrapData(0, len - 1);
                }
                this._signal("changeWrapMode");
            }
        };
        EditSession.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
        };
        EditSession.prototype.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
                this.$wrapLimitRange = {
                    min: min,
                    max: max
                };
                this.$modified = true;
                this.$bidiHandler.markAsDirty();
                if (this.$useWrapMode) this._signal("changeWrapMode");
            }
        };
        EditSession.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0) limits = {
                min: $printMargin,
                max: $printMargin
            };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
                this.$wrapLimit = wrapLimit;
                this.$modified = true;
                if (this.$useWrapMode) {
                    this.$updateWrapData(0, this.getLength() - 1);
                    this.$resetRowCache(0);
                    this._signal("changeWrapLimit");
                }
                return true;
            }
            return false;
        };
        EditSession.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min) wrapLimit = Math.max(min, wrapLimit);
            if (max) wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
        };
        EditSession.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
        };
        EditSession.prototype.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
        };
        EditSession.prototype.getWrapLimitRange = function() {
            return {
                min: this.$wrapLimitRange.min,
                max: this.$wrapLimitRange.max
            };
        };
        EditSession.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
                if (action === "remove") {
                    this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                    var foldLines = this.$foldData;
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);
                    var foldLine = this.getFoldLine(end.row);
                    var idx = 0;
                    if (foldLine) {
                        foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                        foldLine.shiftRow(-len);
                        var foldLineBefore = this.getFoldLine(firstRow);
                        if (foldLineBefore && foldLineBefore !== foldLine) {
                            foldLineBefore.merge(foldLine);
                            foldLine = foldLineBefore;
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }
                    for(idx; idx < foldLines.length; idx++){
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= end.row) foldLine.shiftRow(-len);
                    }
                    lastRow = firstRow;
                } else {
                    var args = Array(len);
                    args.unshift(firstRow, 0);
                    var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                    arr.splice.apply(arr, args);
                    var foldLines = this.$foldData;
                    var foldLine = this.getFoldLine(firstRow);
                    var idx = 0;
                    if (foldLine) {
                        var cmp = foldLine.range.compareInside(start.row, start.column);
                        if (cmp == 0) {
                            foldLine = foldLine.split(start.row, start.column);
                            if (foldLine) {
                                foldLine.shiftRow(len);
                                foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                            }
                        } else if (cmp == -1) {
                            foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                            foldLine.shiftRow(len);
                        }
                        idx = foldLines.indexOf(foldLine) + 1;
                    }
                    for(idx; idx < foldLines.length; idx++){
                        var foldLine = foldLines[idx];
                        if (foldLine.start.row >= firstRow) foldLine.shiftRow(len);
                    }
                }
            } else {
                len = Math.abs(delta.start.column - delta.end.column);
                if (action === "remove") {
                    removedFolds = this.getFoldsInRange(delta);
                    this.removeFolds(removedFolds);
                    len = -len;
                }
                var foldLine = this.getFoldLine(firstRow);
                if (foldLine) foldLine.addRemoveChars(firstRow, start.column, len);
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) console.error("doc.getLength() and $wrapData.length have to be the same!");
            this.$updating = false;
            if (useWrapMode) this.$updateWrapData(firstRow, lastRow);
            else this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
        };
        EditSession.prototype.$updateRowLengthCache = function(firstRow, lastRow) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
        };
        EditSession.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while(row <= lastRow){
                foldLine = this.getFoldLine(row, foldLine);
                if (!foldLine) {
                    tokens = this.$getDisplayTokens(lines[row]);
                    wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row++;
                } else {
                    tokens = [];
                    foldLine.walk((function(placeholder, row, column, lastColumn) {
                        var walkTokens;
                        if (placeholder != null) {
                            walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                            walkTokens[0] = PLACEHOLDER_START;
                            for(var i = 1; i < walkTokens.length; i++)walkTokens[i] = PLACEHOLDER_BODY;
                        } else walkTokens = this.$getDisplayTokens(lines[row].substring(lastColumn, column), tokens.length);
                        tokens = tokens.concat(walkTokens);
                    }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                    wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                    row = foldLine.end.row + 1;
                }
            }
        };
        EditSession.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) return [];
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
                var indentation = 0;
                if (maxIndent === 0) return indentation;
                if (indentedSoftWrap) for(var i = 0; i < tokens.length; i++){
                    var token = tokens[i];
                    if (token == SPACE) indentation += 1;
                    else if (token == TAB) indentation += tabSize;
                    else if (token == TAB_SPACE) continue;
                    else break;
                }
                if (isCode && indentedSoftWrap !== false) indentation += tabSize;
                return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
                var len = screenPos - lastSplit;
                for(var i = lastSplit; i < screenPos; i++){
                    var ch = tokens[i];
                    if (ch === 12 || ch === 2) len -= 1;
                }
                if (!splits.length) {
                    indent = getWrapIndent();
                    splits.indent = indent;
                }
                lastDocSplit += len;
                splits.push(lastDocSplit);
                lastSplit = screenPos;
            }
            var indent = 0;
            while(displayLength - lastSplit > wrapLimit - indent){
                var split = lastSplit + wrapLimit - indent;
                if (tokens[split - 1] >= SPACE && tokens[split] >= SPACE) {
                    addSplit(split);
                    continue;
                }
                if (tokens[split] == PLACEHOLDER_START || tokens[split] == PLACEHOLDER_BODY) {
                    for(split; split != lastSplit - 1; split--){
                        if (tokens[split] == PLACEHOLDER_START) break;
                    }
                    if (split > lastSplit) {
                        addSplit(split);
                        continue;
                    }
                    split = lastSplit + wrapLimit;
                    for(split; split < tokens.length; split++){
                        if (tokens[split] != PLACEHOLDER_BODY) break;
                    }
                    if (split == tokens.length) break; // Breaks the while-loop.
                    addSplit(split);
                    continue;
                }
                var minSplit = Math.max(split - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
                while(split > minSplit && tokens[split] < PLACEHOLDER_START)split--;
                if (isCode) {
                    while(split > minSplit && tokens[split] < PLACEHOLDER_START)split--;
                    while(split > minSplit && tokens[split] == PUNCTUATION)split--;
                } else while(split > minSplit && tokens[split] < SPACE)split--;
                if (split > minSplit) {
                    addSplit(++split);
                    continue;
                }
                split = lastSplit + wrapLimit;
                if (tokens[split] == CHAR_EXT) split--;
                addSplit(split - indent);
            }
            return splits;
        };
        EditSession.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for(var i = 0; i < str.length; i++){
                var c = str.charCodeAt(i);
                if (c == 9) {
                    tabSize = this.getScreenTabSize(arr.length + offset);
                    arr.push(TAB);
                    for(var n = 1; n < tabSize; n++)arr.push(TAB_SPACE);
                } else if (c == 32) arr.push(SPACE);
                else if (c > 39 && c < 48 || c > 57 && c < 64) arr.push(PUNCTUATION);
                else if (c >= 0x1100 && isFullWidth(c)) arr.push(CHAR, CHAR_EXT);
                else arr.push(CHAR);
            }
            return arr;
        };
        EditSession.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0) return [
                0,
                0
            ];
            if (maxScreenColumn == null) maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c, column;
            for(column = 0; column < str.length; column++){
                c = str.charCodeAt(column);
                if (c == 9) screenColumn += this.getScreenTabSize(screenColumn);
                else if (c >= 0x1100 && isFullWidth(c)) screenColumn += 2;
                else screenColumn += 1;
                if (screenColumn > maxScreenColumn) break;
            }
            return [
                screenColumn,
                column
            ];
        };
        EditSession.prototype.getRowLength = function(row) {
            var h = 1;
            if (this.lineWidgets) h += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row]) return h;
            else return this.$wrapData[row].length + h;
        };
        EditSession.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) return 1;
            else return this.$wrapData[row].length + 1;
        };
        EditSession.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
                var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
                var splits = this.$wrapData[pos.row];
                return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else return 0;
        };
        EditSession.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
        };
        EditSession.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
        };
        EditSession.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
        };
        EditSession.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) return undefined;
            else return this.$wrapData[row];
        };
        EditSession.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
        };
        EditSession.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
        };
        EditSession.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
        };
        EditSession.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0) return {
                row: 0,
                column: 0
            };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var docRow = this.$docRowCache[i];
                var doCache = screenRow > rowCache[l - 1];
            } else var doCache = !l;
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while(row <= screenRow){
                rowLength = this.getRowLength(docRow);
                if (row + rowLength > screenRow || docRow >= maxRow) break;
                else {
                    row += rowLength;
                    docRow++;
                    if (docRow > foldStart) {
                        docRow = foldLine.end.row + 1;
                        foldLine = this.getNextFoldLine(docRow, foldLine);
                        foldStart = foldLine ? foldLine.start.row : Infinity;
                    }
                }
                if (doCache) {
                    this.$docRowCache.push(docRow);
                    this.$screenRowCache.push(row);
                }
            }
            if (foldLine && foldLine.start.row <= docRow) {
                line = this.getFoldDisplayLine(foldLine);
                docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) return {
                row: maxRow,
                column: this.getLine(maxRow).length
            };
            else {
                line = this.getLine(docRow);
                foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
                var splits = this.$wrapData[docRow];
                if (splits) {
                    column = splits[splitIndex];
                    if (splitIndex > 0 && splits.length) {
                        wrapIndent = splits.indent;
                        docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                        line = line.substring(docColumn);
                    }
                }
            }
            if (offsetX !== undefined && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex)) screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column) docColumn = column - 1;
            if (foldLine) return foldLine.idxToPosition(docColumn);
            return {
                row: docRow,
                column: docColumn
            };
        };
        EditSession.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined") var pos = this.$clipPositionToDocument(/**@type{Point}*/ docRow.row, /**@type{Point}*/ docRow.column);
            else pos = this.$clipPositionToDocument(/**@type{number}*/ docRow, docColumn);
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
                docRow = fold.start.row;
                docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i >= 0) {
                var row = rowCache[i];
                var screenRow = this.$screenRowCache[i];
                var doCache = docRow > rowCache[l - 1];
            } else var doCache = !l;
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while(row < docRow){
                if (row >= foldStart) {
                    rowEnd = foldLine.end.row + 1;
                    if (rowEnd > docRow) break;
                    foldLine = this.getNextFoldLine(rowEnd, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                } else rowEnd = row + 1;
                screenRow += this.getRowLength(row);
                row = rowEnd;
                if (doCache) {
                    this.$docRowCache.push(row);
                    this.$screenRowCache.push(screenRow);
                }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
                textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
                foldStartRow = foldLine.start.row;
            } else {
                textLine = this.getLine(docRow).substring(0, docColumn);
                foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
                var wrapRow = this.$wrapData[foldStartRow];
                if (wrapRow) {
                    var screenRowOffset = 0;
                    while(textLine.length >= wrapRow[screenRowOffset]){
                        screenRow++;
                        screenRowOffset++;
                    }
                    textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                    wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
                }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove) screenRow += this.lineWidgets[row].rowsAbove;
            return {
                row: screenRow,
                column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
        };
        EditSession.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
        };
        EditSession.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
        };
        EditSession.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
                screenRows = this.getLength();
                var foldData = this.$foldData;
                for(var i = 0; i < foldData.length; i++){
                    fold = foldData[i];
                    screenRows -= fold.end.row - fold.start.row;
                }
            } else {
                var lastRow = this.$wrapData.length;
                var row = 0, i = 0;
                var fold = this.$foldData[i++];
                var foldStart = fold ? fold.start.row : Infinity;
                while(row < lastRow){
                    var splits = this.$wrapData[row];
                    screenRows += splits ? splits.length + 1 : 1;
                    row++;
                    if (row > foldStart) {
                        row = fold.end.row + 1;
                        fold = this.$foldData[i++];
                        foldStart = fold ? fold.start.row : Infinity;
                    }
                }
            }
            if (this.lineWidgets) screenRows += this.$getWidgetScreenLength();
            return screenRows;
        };
        EditSession.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar) return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
                if (maxScreenColumn === 0) return [
                    0,
                    0
                ];
                if (!maxScreenColumn) maxScreenColumn = Infinity;
                screenColumn = screenColumn || 0;
                var c, column;
                for(column = 0; column < str.length; column++){
                    c = str.charAt(column);
                    if (c === "	") screenColumn += this.getScreenTabSize(screenColumn);
                    else screenColumn += fm.getCharacterWidth(c);
                    if (screenColumn > maxScreenColumn) break;
                }
                return [
                    screenColumn,
                    column
                ];
            };
        };
        EditSession.prototype.getPrecedingCharacter = function() {
            var pos = this.selection.getCursor();
            if (pos.column === 0) return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
            var currentLine = this.getLine(pos.row);
            return currentLine[pos.column - 1];
        };
        EditSession.prototype.destroy = function() {
            if (!this.destroyed) {
                this.bgTokenizer.setDocument(null);
                this.bgTokenizer.cleanup();
                this.destroyed = true;
            }
            this.endOperation();
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) this.doc.off("change", this.$onChange);
            if (this.selection) {
                this.selection.off("changeCursor", this.$onSelectionChange);
                this.selection.off("changeSelection", this.$onSelectionChange);
            }
            this.selection.detach();
        };
        return EditSession;
    }();
    EditSession.$uid = 0;
    EditSession.prototype.$modes = config.$modes;
    EditSession.prototype.getValue = EditSession.prototype.toString;
    EditSession.prototype.$defaultUndoManager = {
        undo: function() {},
        redo: function() {},
        hasUndo: function() {},
        hasRedo: function() {},
        reset: function() {},
        add: function() {},
        addSelection: function() {},
        startNewGroup: function() {},
        addSession: function() {}
    };
    EditSession.prototype.$overwrite = false;
    EditSession.prototype.$mode = null;
    EditSession.prototype.$modeId = null;
    EditSession.prototype.$scrollTop = 0;
    EditSession.prototype.$scrollLeft = 0;
    EditSession.prototype.$wrapLimit = 80;
    EditSession.prototype.$useWrapMode = false;
    EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
    };
    EditSession.prototype.lineWidgets = null;
    EditSession.prototype.isFullWidth = isFullWidth;
    oop.implement(EditSession.prototype, EventEmitter);
    var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
    function isFullWidth(c) {
        if (c < 0x1100) return false;
        return c >= 0x1100 && c <= 0x115F || c >= 0x11A3 && c <= 0x11A7 || c >= 0x11FA && c <= 0x11FF || c >= 0x2329 && c <= 0x232A || c >= 0x2E80 && c <= 0x2E99 || c >= 0x2E9B && c <= 0x2EF3 || c >= 0x2F00 && c <= 0x2FD5 || c >= 0x2FF0 && c <= 0x2FFB || c >= 0x3000 && c <= 0x303E || c >= 0x3041 && c <= 0x3096 || c >= 0x3099 && c <= 0x30FF || c >= 0x3105 && c <= 0x312D || c >= 0x3131 && c <= 0x318E || c >= 0x3190 && c <= 0x31BA || c >= 0x31C0 && c <= 0x31E3 || c >= 0x31F0 && c <= 0x321E || c >= 0x3220 && c <= 0x3247 || c >= 0x3250 && c <= 0x32FE || c >= 0x3300 && c <= 0x4DBF || c >= 0x4E00 && c <= 0xA48C || c >= 0xA490 && c <= 0xA4C6 || c >= 0xA960 && c <= 0xA97C || c >= 0xAC00 && c <= 0xD7A3 || c >= 0xD7B0 && c <= 0xD7C6 || c >= 0xD7CB && c <= 0xD7FB || c >= 0xF900 && c <= 0xFAFF || c >= 0xFE10 && c <= 0xFE19 || c >= 0xFE30 && c <= 0xFE52 || c >= 0xFE54 && c <= 0xFE66 || c >= 0xFE68 && c <= 0xFE6B || c >= 0xFF01 && c <= 0xFF60 || c >= 0xFFE0 && c <= 0xFFE6;
    }
    require("./edit_session/folding").Folding.call(EditSession.prototype);
    require("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
    config.defineOptions(EditSession.prototype, "session", {
        wrap: {
            set: function(value) {
                if (!value || value == "off") value = false;
                else if (value == "free") value = true;
                else if (value == "printMargin") value = -1;
                else if (typeof value == "string") value = parseInt(value, 10) || false;
                if (this.$wrap == value) return;
                this.$wrap = value;
                if (!value) this.setUseWrapMode(false);
                else {
                    var col = typeof value == "number" ? value : null;
                    this.setWrapLimitRange(col, col);
                    this.setUseWrapMode(true);
                }
            },
            get: function() {
                if (this.getUseWrapMode()) {
                    if (this.$wrap == -1) return "printMargin";
                    if (!this.getWrapLimitRange().min) return "free";
                    return this.$wrap;
                }
                return "off";
            },
            handlesSet: true
        },
        wrapMethod: {
            set: function(val) {
                val = val == "auto" ? this.$mode.type != "text" : val != "text";
                if (val != this.$wrapAsCode) {
                    this.$wrapAsCode = val;
                    if (this.$useWrapMode) {
                        this.$useWrapMode = false;
                        this.setUseWrapMode(true);
                    }
                }
            },
            initialValue: "auto"
        },
        indentedSoftWrap: {
            set: function() {
                if (this.$useWrapMode) {
                    this.$useWrapMode = false;
                    this.setUseWrapMode(true);
                }
            },
            initialValue: true
        },
        firstLineNumber: {
            set: function() {
                this._signal("changeBreakpoint");
            },
            initialValue: 1
        },
        useWorker: {
            set: function(useWorker) {
                this.$useWorker = useWorker;
                this.$stopWorker();
                if (useWorker) this.$startWorker();
            },
            initialValue: true
        },
        useSoftTabs: {
            initialValue: true
        },
        tabSize: {
            set: function(tabSize) {
                tabSize = parseInt(tabSize);
                if (tabSize > 0 && this.$tabSize !== tabSize) {
                    this.$modified = true;
                    this.$rowLengthCache = [];
                    this.$tabSize = tabSize;
                    this._signal("changeTabSize");
                }
            },
            initialValue: 4,
            handlesSet: true
        },
        navigateWithinSoftTabs: {
            initialValue: false
        },
        foldStyle: {
            set: function(val) {
                this.setFoldStyle(val);
            },
            handlesSet: true
        },
        overwrite: {
            set: function(val) {
                this._signal("changeOverwrite");
            },
            initialValue: false
        },
        newLineMode: {
            set: function(val) {
                this.doc.setNewLineMode(val);
            },
            get: function() {
                return this.doc.getNewLineMode();
            },
            handlesSet: true
        },
        mode: {
            set: function(val) {
                this.setMode(val);
            },
            get: function() {
                return this.$modeId;
            },
            handlesSet: true
        }
    });
    exports.EditSession = EditSession;
});
ace.define("ace/search", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/lib/oop",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var lang = require("./lib/lang");
    var oop = require("./lib/oop");
    var Range = require("./range").Range;
    var Search = /** @class */ function() {
        function Search() {
            this.$options = {};
        }
        Search.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
        };
        Search.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
        };
        Search.prototype.setOptions = function(options) {
            this.$options = options;
        };
        Search.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator) return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
                firstRange = new Range(sr, sc, er, ec);
                if (sc == ec && options.start && /**@type{Range}*/ options.start.start && options.skipCurrent != false && firstRange.isEqual(/**@type{Range}*/ options.start)) {
                    firstRange = null;
                    return false;
                }
                return true;
            });
            return firstRange;
        };
        Search.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle) return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re = options.re;
            if (options.$isMultiLine) {
                var len = re.length;
                var maxRow = lines.length - len;
                var prevRange;
                outer: for(var row = re.offset || 0; row <= maxRow; row++){
                    for(var j = 0; j < len; j++)if (lines[row + j].search(re[j]) == -1) continue outer;
                    var startLine = lines[row];
                    var line = lines[row + len - 1];
                    var startIndex = startLine.length - startLine.match(re[0])[0].length;
                    var endIndex = line.match(re[len - 1])[0].length;
                    if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) continue;
                    ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                    if (len > 2) row = row + len - 2;
                }
            } else {
                for(var matches, i = 0; i < lines.length; i++)if (this.$isMultilineSearch(options)) {
                    var lng = lines.length - 1;
                    matches = this.$multiLineForward(session, re, i, lng);
                    if (matches) {
                        var end_row = matches.endRow <= lng ? matches.endRow - 1 : lng;
                        if (end_row > i) i = end_row;
                        ranges.push(new Range(matches.startRow, matches.startCol, matches.endRow, matches.endCol));
                    }
                } else {
                    matches = lang.getMatchOffsets(lines[i], re);
                    for(var j = 0; j < matches.length; j++){
                        var match = matches[j];
                        ranges.push(new Range(i, match.offset, i, match.offset + match.length));
                    }
                }
            }
            if (range) {
                var startColumn = range.start.column;
                var endColumn = range.end.column;
                var i = 0, j = ranges.length - 1;
                while(i < j && ranges[i].start.column < startColumn && ranges[i].start.row == 0)i++;
                var endRow = range.end.row - range.start.row;
                while(i < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)j--;
                ranges = ranges.slice(i, j + 1);
                for(i = 0, j = ranges.length; i < j; i++){
                    ranges[i].start.row += range.start.row;
                    ranges[i].end.row += range.start.row;
                }
            }
            return ranges;
        };
        Search.prototype.parseReplaceString = function(replaceString) {
            var CharCode = {
                DollarSign: 36,
                Ampersand: 38,
                Digit0: 48,
                Digit1: 49,
                Digit9: 57,
                Backslash: 92,
                n: 110,
                t: 116
            };
            var replacement = "";
            for(var i = 0, len = replaceString.length; i < len; i++){
                var chCode = replaceString.charCodeAt(i);
                if (chCode === CharCode.Backslash) {
                    i++;
                    if (i >= len) {
                        replacement += "\\";
                        break;
                    }
                    var nextChCode = replaceString.charCodeAt(i);
                    switch(nextChCode){
                        case CharCode.Backslash:
                            replacement += "\\";
                            break;
                        case CharCode.n:
                            replacement += "\n";
                            break;
                        case CharCode.t:
                            replacement += "	";
                            break;
                    }
                    continue;
                }
                if (chCode === CharCode.DollarSign) {
                    i++;
                    if (i >= len) {
                        replacement += "$";
                        break;
                    }
                    var nextChCode_1 = replaceString.charCodeAt(i);
                    if (nextChCode_1 === CharCode.DollarSign) {
                        replacement += "$$";
                        continue;
                    }
                    if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
                        replacement += "$&";
                        continue;
                    }
                    if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
                        replacement += "$" + replaceString[i];
                        continue;
                    }
                }
                replacement += replaceString[i];
            }
            return replacement || replaceString;
        };
        Search.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re = this.$assembleRegExp(options);
            if (options.$isMultiLine) return replacement;
            if (!re) return;
            var mtSearch = this.$isMultilineSearch(options);
            if (mtSearch) input = input.replace(/\r\n|\r|\n/g, "\n");
            var match = re.exec(input);
            if (!match || !mtSearch && match[0].length != input.length) return null;
            replacement = options.regExp ? this.parseReplaceString(replacement) : replacement.replace(/\$/g, "$$$$");
            replacement = input.replace(re, replacement);
            if (options.preserveCase) {
                replacement = replacement.split("");
                for(var i = Math.min(input.length, input.length); i--;){
                    var ch = input[i];
                    if (ch && ch.toLowerCase() != ch) replacement[i] = replacement[i].toUpperCase();
                    else replacement[i] = replacement[i].toLowerCase();
                }
                replacement = replacement.join("");
            }
            return replacement;
        };
        Search.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp) return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle) return options.re = false;
            if (!options.regExp) needle = lang.escapeRegExp(needle);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            try {
                new RegExp(needle, "u");
                options.$supportsUnicodeFlag = true;
                modifier += "u";
            } catch (e) {
                options.$supportsUnicodeFlag = false; //left for backward compatibility with previous versions for cases like /ab\{2}/gu
            }
            if (options.wholeWord) needle = addWordBoundary(needle, options);
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine) return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
                var re = new RegExp(needle, modifier);
            } catch (e) {
                re = false;
            }
            return options.re = re;
        };
        Search.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re = [];
            for(var i = 0; i < parts.length; i++)try {
                re.push(new RegExp(parts[i], modifier));
            } catch (e) {
                return false;
            }
            return re;
        };
        Search.prototype.$isMultilineSearch = function(options) {
            return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
        };
        Search.prototype.$multiLineForward = function(session, re, start, last) {
            var line, chunk = chunkEnd(session, start);
            for(var row = start; row <= last;){
                for(var i = 0; i < chunk; i++){
                    if (row > last) break;
                    var next = session.getLine(row++);
                    line = line == null ? next : line + "\n" + next;
                }
                var match = re.exec(line);
                re.lastIndex = 0;
                if (match) {
                    var beforeMatch = line.slice(0, match.index).split("\n");
                    var matchedText = match[0].split("\n");
                    var startRow = start + beforeMatch.length - 1;
                    var startCol = beforeMatch[beforeMatch.length - 1].length;
                    var endRow = startRow + matchedText.length - 1;
                    var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                    return {
                        startRow: startRow,
                        startCol: startCol,
                        endRow: endRow,
                        endCol: endCol
                    };
                }
            }
            return null;
        };
        Search.prototype.$multiLineBackward = function(session, re, endIndex, start, first) {
            var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
            for(var row = start; row >= first;){
                for(var i = 0; i < chunk && row >= first; i++){
                    var next = session.getLine(row--);
                    line = line == null ? next : next + "\n" + line;
                }
                var match = multiLineBackwardMatch(line, re, endMargin);
                if (match) {
                    var beforeMatch = line.slice(0, match.index).split("\n");
                    var matchedText = match[0].split("\n");
                    var startRow = row + beforeMatch.length;
                    var startCol = beforeMatch[beforeMatch.length - 1].length;
                    var endRow = startRow + matchedText.length - 1;
                    var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                    return {
                        startRow: startRow,
                        startCol: startCol,
                        endRow: endRow,
                        endCol: endCol
                    };
                }
            }
            return null;
        };
        Search.prototype.$matchIterator = function(session, options) {
            var re = this.$assembleRegExp(options);
            if (!re) return false;
            var mtSearch = this.$isMultilineSearch(options);
            var mtForward = this.$multiLineForward;
            var mtBackward = this.$multiLineBackward;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var supportsUnicodeFlag = re.unicode;
            var range = options.range;
            var start = options.start;
            if (!start) start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start) start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback)) return;
                for(row--; row >= firstRow; row--)if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
                if (options.wrap == false) return;
                for(row = lastRow, firstRow = start.row; row >= firstRow; row--)if (forEachInLine(row, Number.MAX_VALUE, callback)) return;
            };
            else var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback)) return;
                for(row = row + 1; row <= lastRow; row++)if (forEachInLine(row, 0, callback)) return;
                if (options.wrap == false) return;
                for(row = firstRow, lastRow = start.row; row <= lastRow; row++)if (forEachInLine(row, 0, callback)) return;
            };
            if (options.$isMultiLine) {
                var len = re.length;
                var forEachInLine = function(row, offset, callback) {
                    var startRow = backwards ? row - len + 1 : row;
                    if (startRow < 0 || startRow + len > session.getLength()) return;
                    var line = session.getLine(startRow);
                    var startIndex = line.search(re[0]);
                    if (!backwards && startIndex < offset || startIndex === -1) return;
                    for(var i = 1; i < len; i++){
                        line = session.getLine(startRow + i);
                        if (line.search(re[i]) == -1) return;
                    }
                    var endIndex = line.match(re[len - 1])[0].length;
                    if (backwards && endIndex > offset) return;
                    if (callback(startRow, startIndex, startRow + len - 1, endIndex)) return true;
                };
            } else if (backwards) var forEachInLine = function(row, endIndex, callback) {
                if (mtSearch) {
                    var pos = mtBackward(session, re, endIndex, row, firstRow);
                    if (!pos) return false;
                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol)) return true;
                } else {
                    var line = session.getLine(row);
                    var matches = [];
                    var m, last = 0;
                    re.lastIndex = 0;
                    while(m = re.exec(line)){
                        var length = m[0].length;
                        last = m.index;
                        if (!length) {
                            if (last >= line.length) break;
                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                        }
                        if (m.index + length > endIndex) break;
                        matches.push(m.index, length);
                    }
                    for(var i = matches.length - 1; i >= 0; i -= 2){
                        var column = matches[i - 1];
                        var length = matches[i];
                        if (callback(row, column, row, column + length)) return true;
                    }
                }
            };
            else var forEachInLine = function(row, startIndex, callback) {
                re.lastIndex = startIndex;
                if (mtSearch) {
                    var pos = mtForward(session, re, row, lastRow);
                    if (pos) {
                        var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                        if (end_row > row) row = end_row;
                    }
                    if (!pos) return false;
                    if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol)) return true;
                } else {
                    var line = session.getLine(row);
                    var last;
                    var m;
                    while(m = re.exec(line)){
                        var length = m[0].length;
                        last = m.index;
                        if (callback(row, last, row, last + length)) return true;
                        if (!length) {
                            re.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                            if (last >= line.length) return false;
                        }
                    }
                }
            };
            return {
                forEach: forEach
            };
        };
        return Search;
    }();
    function addWordBoundary(needle, options) {
        var supportsLookbehind = lang.supportsLookbehind();
        function wordBoundary(c, firstChar) {
            if (firstChar === void 0) firstChar = true;
            var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
            if (wordRegExp.test(c) || options.regExp) {
                if (supportsLookbehind && options.$supportsUnicodeFlag) {
                    if (firstChar) return "(?<=^|[^\\p{L}\\p{N}_])";
                    return "(?=[^\\p{L}\\p{N}_]|$)";
                }
                return "\\b";
            }
            return "";
        }
        var needleArray = Array.from(needle);
        var firstChar = needleArray[0];
        var lastChar = needleArray[needleArray.length - 1];
        return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
    }
    function multiLineBackwardMatch(line, re, endMargin) {
        var match = null;
        var from = 0;
        while(from <= line.length){
            re.lastIndex = from;
            var newMatch = re.exec(line);
            if (!newMatch) break;
            var end = newMatch.index + newMatch[0].length;
            if (end > line.length - endMargin) break;
            if (!match || end > match.index + match[0].length) match = newMatch;
            from = newMatch.index + 1;
        }
        return match;
    }
    function chunkEnd(session, start) {
        var base = 5000, startPosition = {
            row: start,
            column: 0
        }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
        return targetLine + 1;
    }
    exports.Search = Search;
});
ace.define("ace/keyboard/hash_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/lib/useragent"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var keyUtil = require("../lib/keys");
    var useragent = require("../lib/useragent");
    var KEY_MODS = keyUtil.KEY_MODS;
    var MultiHashHandler = /** @class */ function() {
        function MultiHashHandler(config, platform) {
            this.$init(config, platform, false);
        }
        MultiHashHandler.prototype.$init = function(config, platform, $singleCommand) {
            this.platform = platform || (useragent.isMac ? "mac" : "win");
            this.commands = {};
            this.commandKeyBinding = {};
            this.addCommands(config);
            this.$singleCommand = $singleCommand;
        };
        MultiHashHandler.prototype.addCommand = function(command) {
            if (this.commands[command.name]) this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey) this._buildKeyHash(command);
        };
        MultiHashHandler.prototype.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand) delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for(var keyId in ckb){
                var cmdGroup = ckb[keyId];
                if (cmdGroup == command) delete ckb[keyId];
                else if (Array.isArray(cmdGroup)) {
                    var i = cmdGroup.indexOf(command);
                    if (i != -1) {
                        cmdGroup.splice(i, 1);
                        if (cmdGroup.length == 1) ckb[keyId] = cmdGroup[0];
                    }
                }
            }
        };
        MultiHashHandler.prototype.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
                if (position == undefined) position = key.position;
                key = key[this.platform];
            }
            if (!key) return;
            if (typeof command == "function") return this.addCommand({
                exec: command,
                bindKey: key,
                name: command.name || /**@type{string}*/ key
            });
            key.split("|").forEach(function(keyPart) {
                var chain = "";
                if (keyPart.indexOf(" ") != -1) {
                    var parts = keyPart.split(/\s+/);
                    keyPart = parts.pop();
                    parts.forEach(function(keyPart) {
                        var binding = this.parseKeys(keyPart);
                        var id = KEY_MODS[binding.hashId] + binding.key;
                        chain += (chain ? " " : "") + id;
                        this._addCommandToBinding(chain, "chainKeys");
                    }, this);
                    chain += " ";
                }
                var binding = this.parseKeys(keyPart);
                var id = KEY_MODS[binding.hashId] + binding.key;
                this._addCommandToBinding(chain + id, command, position);
            }, this);
        };
        MultiHashHandler.prototype._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i;
            if (!command) delete ckb[keyId];
            else if (!ckb[keyId] || this.$singleCommand) ckb[keyId] = command;
            else {
                if (!Array.isArray(ckb[keyId])) ckb[keyId] = [
                    ckb[keyId]
                ];
                else if ((i = ckb[keyId].indexOf(command)) != -1) ckb[keyId].splice(i, 1);
                if (typeof position != "number") position = getPosition(command);
                var commands = ckb[keyId];
                for(i = 0; i < commands.length; i++){
                    var other = commands[i];
                    var otherPos = getPosition(other);
                    if (otherPos > position) break;
                }
                commands.splice(i, 0, command);
            }
        };
        MultiHashHandler.prototype.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
                var command = commands[name];
                if (!command) return;
                if (typeof command === "string") return this.bindKey(command, name);
                if (typeof command === "function") command = {
                    exec: command
                };
                if (typeof command !== "object") return;
                if (!command.name) command.name = name;
                this.addCommand(command);
            }, this);
        };
        MultiHashHandler.prototype.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
                this.removeCommand(commands[name]);
            }, this);
        };
        MultiHashHandler.prototype.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
                this.bindKey(key, keyList[key]);
            }, this);
        };
        MultiHashHandler.prototype._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
        };
        MultiHashHandler.prototype.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x) {
                return x;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode]) key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length) return {
                key: key,
                hashId: -1
            };
            else if (parts.length == 1 && parts[0] == "shift") return {
                key: key.toUpperCase(),
                hashId: -1
            };
            var hashId = 0;
            for(var i = parts.length; i--;){
                var modifier = keyUtil.KEY_MODS[parts[i]];
                if (modifier == null) {
                    if (typeof console != "undefined") console.error("invalid modifier " + parts[i] + " in " + keys);
                    return false;
                }
                hashId |= modifier;
            }
            return {
                key: key,
                hashId: hashId
            };
        };
        MultiHashHandler.prototype.findKeyCommand = function(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
        };
        MultiHashHandler.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0) return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
                data.$keyChain += " " + key;
                command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
                if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                    data.$keyChain = data.$keyChain || key;
                    return {
                        command: "null"
                    };
                }
            }
            if (data.$keyChain) {
                if ((!hashId || hashId == 4) && keyString.length == 1) data.$keyChain = data.$keyChain.slice(0, -key.length - 1); // wait for input
                else if (hashId == -1 || keyCode > 0) data.$keyChain = ""; // reset keyChain
            }
            return {
                command: command
            };
        };
        MultiHashHandler.prototype.getStatusText = function(editor, data) {
            return data.$keyChain || "";
        };
        return MultiHashHandler;
    }();
    function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
    }
    var HashHandler = /** @class */ function(_super) {
        __extends(HashHandler, _super);
        function HashHandler(config, platform) {
            var _this = _super.call(this, config, platform) || this;
            _this.$singleCommand = true;
            return _this;
        }
        return HashHandler;
    }(MultiHashHandler);
    HashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
    };
    MultiHashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
    };
    exports.HashHandler = HashHandler;
    exports.MultiHashHandler = MultiHashHandler;
});
ace.define("ace/commands/command_manager", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/keyboard/hash_handler",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var oop = require("../lib/oop");
    var MultiHashHandler = require("../keyboard/hash_handler").MultiHashHandler;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var CommandManager = /** @class */ function(_super) {
        __extends(CommandManager, _super);
        function CommandManager(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e) {
                if (!e.args) return e.command.exec(e.editor, {}, e.event, true);
                return e.command.exec(e.editor, e.args, e.event, false);
            });
            return _this;
        }
        CommandManager.prototype.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
                for(var i = command.length; i--;){
                    if (this.exec(command[i], editor, args)) return true;
                }
                return false;
            }
            if (typeof command === "string") command = this.commands[command];
            var e = {
                editor: editor,
                command: command,
                args: args
            };
            if (!this.canExecute(command, editor)) {
                this._signal("commandUnavailable", e);
                return false;
            }
            e.returnValue = this._emit("exec", e);
            this._signal("afterExec", e);
            return e.returnValue === false ? false : true;
        };
        CommandManager.prototype.canExecute = function(command, editor) {
            if (typeof command === "string") command = this.commands[command];
            if (!command) return false;
            if (editor && editor.$readOnly && !command.readOnly) return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor)) return false;
            return true;
        };
        CommandManager.prototype.toggleRecording = function(editor) {
            if (this.$inReplay) return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
                this.macro.pop();
                this.off("exec", this.$addCommandToMacro);
                if (!this.macro.length) this.macro = this.oldMacro;
                return this.recording = false;
            }
            if (!this.$addCommandToMacro) this.$addCommandToMacro = (function(e) {
                this.macro.push([
                    e.command,
                    e.args
                ]);
            }).bind(this);
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
        };
        CommandManager.prototype.replay = function(editor) {
            if (this.$inReplay || !this.macro) return;
            if (this.recording) return this.toggleRecording(editor);
            try {
                this.$inReplay = true;
                this.macro.forEach(function(x) {
                    if (typeof x == "string") this.exec(x, editor);
                    else this.exec(x[0], editor, x[1]);
                }, this);
            } finally{
                this.$inReplay = false;
            }
        };
        CommandManager.prototype.trimMacro = function(m) {
            return m.map(function(x) {
                if (typeof x[0] != "string") x[0] = x[0].name;
                if (!x[1]) x = x[0];
                return x;
            });
        };
        return CommandManager;
    }(MultiHashHandler);
    oop.implement(CommandManager.prototype, EventEmitter);
    exports.CommandManager = CommandManager;
});
ace.define("ace/commands/default_commands", [
    "require",
    "exports",
    "module",
    "ace/lib/lang",
    "ace/config",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var lang = require("../lib/lang");
    var config = require("../config");
    var Range = require("../range").Range;
    function bindKey(win, mac) {
        return {
            win: win,
            mac: mac
        };
    }
    exports.commands = [
        {
            name: "showSettingsMenu",
            description: "Show settings menu",
            bindKey: bindKey("Ctrl-,", "Command-,"),
            exec: function(editor) {
                config.loadModule("ace/ext/settings_menu", function(module1) {
                    module1.init(editor);
                    editor.showSettingsMenu();
                });
            },
            readOnly: true
        },
        {
            name: "goToNextError",
            description: "Go to next error",
            bindKey: bindKey("Alt-E", "F4"),
            exec: function(editor) {
                config.loadModule("ace/ext/error_marker", function(module1) {
                    module1.showErrorMarker(editor, 1);
                });
            },
            scrollIntoView: "animate",
            readOnly: true
        },
        {
            name: "goToPreviousError",
            description: "Go to previous error",
            bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
            exec: function(editor) {
                config.loadModule("ace/ext/error_marker", function(module1) {
                    module1.showErrorMarker(editor, -1);
                });
            },
            scrollIntoView: "animate",
            readOnly: true
        },
        {
            name: "selectall",
            description: "Select all",
            bindKey: bindKey("Ctrl-A", "Command-A"),
            exec: function(editor) {
                editor.selectAll();
            },
            readOnly: true
        },
        {
            name: "centerselection",
            description: "Center selection",
            bindKey: bindKey(null, "Ctrl-L"),
            exec: function(editor) {
                editor.centerSelection();
            },
            readOnly: true
        },
        {
            name: "gotoline",
            description: "Go to line...",
            bindKey: bindKey("Ctrl-L", "Command-L"),
            exec: function(editor, line) {
                if (typeof line === "number" && !isNaN(line)) editor.gotoLine(line);
                editor.prompt({
                    $type: "gotoLine"
                });
            },
            readOnly: true
        },
        {
            name: "fold",
            bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
            exec: function(editor) {
                editor.session.toggleFold(false);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "unfold",
            bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
            exec: function(editor) {
                editor.session.toggleFold(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "toggleFoldWidget",
            description: "Toggle fold widget",
            bindKey: bindKey("F2", "F2"),
            exec: function(editor) {
                editor.session.toggleFoldWidget();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "toggleParentFoldWidget",
            description: "Toggle parent fold widget",
            bindKey: bindKey("Alt-F2", "Alt-F2"),
            exec: function(editor) {
                editor.session.toggleFoldWidget(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "foldall",
            description: "Fold all",
            bindKey: bindKey(null, "Ctrl-Command-Option-0"),
            exec: function(editor) {
                editor.session.foldAll();
            },
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "foldAllComments",
            description: "Fold all comments",
            bindKey: bindKey(null, "Ctrl-Command-Option-0"),
            exec: function(editor) {
                editor.session.foldAllComments();
            },
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "foldOther",
            description: "Fold other",
            bindKey: bindKey("Alt-0", "Command-Option-0"),
            exec: function(editor) {
                editor.session.foldAll();
                editor.session.unfold(editor.selection.getAllRanges());
            },
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "unfoldall",
            description: "Unfold all",
            bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
            exec: function(editor) {
                editor.session.unfold();
            },
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "findnext",
            description: "Find next",
            bindKey: bindKey("Ctrl-K", "Command-G"),
            exec: function(editor) {
                editor.findNext();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "findprevious",
            description: "Find previous",
            bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
            exec: function(editor) {
                editor.findPrevious();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "center",
            readOnly: true
        },
        {
            name: "selectOrFindNext",
            description: "Select or find next",
            bindKey: bindKey("Alt-K", "Ctrl-G"),
            exec: function(editor) {
                if (editor.selection.isEmpty()) editor.selection.selectWord();
                else editor.findNext();
            },
            readOnly: true
        },
        {
            name: "selectOrFindPrevious",
            description: "Select or find previous",
            bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
            exec: function(editor) {
                if (editor.selection.isEmpty()) editor.selection.selectWord();
                else editor.findPrevious();
            },
            readOnly: true
        },
        {
            name: "find",
            description: "Find",
            bindKey: bindKey("Ctrl-F", "Command-F"),
            exec: function(editor) {
                config.loadModule("ace/ext/searchbox", function(e) {
                    e.Search(editor);
                });
            },
            readOnly: true
        },
        {
            name: "overwrite",
            description: "Overwrite",
            bindKey: "Insert",
            exec: function(editor) {
                editor.toggleOverwrite();
            },
            readOnly: true
        },
        {
            name: "selecttostart",
            description: "Select to start",
            bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
            exec: function(editor) {
                editor.getSelection().selectFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "gotostart",
            description: "Go to start",
            bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
            exec: function(editor) {
                editor.navigateFileStart();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "selectup",
            description: "Select up",
            bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
            exec: function(editor) {
                editor.getSelection().selectUp();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "golineup",
            description: "Go line up",
            bindKey: bindKey("Up", "Up|Ctrl-P"),
            exec: function(editor, args) {
                editor.navigateUp(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selecttoend",
            description: "Select to end",
            bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
            exec: function(editor) {
                editor.getSelection().selectFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "gotoend",
            description: "Go to end",
            bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
            exec: function(editor) {
                editor.navigateFileEnd();
            },
            multiSelectAction: "forEach",
            readOnly: true,
            scrollIntoView: "animate",
            aceCommandGroup: "fileJump"
        },
        {
            name: "selectdown",
            description: "Select down",
            bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
            exec: function(editor) {
                editor.getSelection().selectDown();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "golinedown",
            description: "Go line down",
            bindKey: bindKey("Down", "Down|Ctrl-N"),
            exec: function(editor, args) {
                editor.navigateDown(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectwordleft",
            description: "Select word left",
            bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
            exec: function(editor) {
                editor.getSelection().selectWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotowordleft",
            description: "Go to word left",
            bindKey: bindKey("Ctrl-Left", "Option-Left"),
            exec: function(editor) {
                editor.navigateWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selecttolinestart",
            description: "Select to line start",
            bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
            exec: function(editor) {
                editor.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotolinestart",
            description: "Go to line start",
            bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
            exec: function(editor) {
                editor.navigateLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectleft",
            description: "Select left",
            bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
            exec: function(editor) {
                editor.getSelection().selectLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotoleft",
            description: "Go to left",
            bindKey: bindKey("Left", "Left|Ctrl-B"),
            exec: function(editor, args) {
                editor.navigateLeft(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectwordright",
            description: "Select word right",
            bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
            exec: function(editor) {
                editor.getSelection().selectWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotowordright",
            description: "Go to word right",
            bindKey: bindKey("Ctrl-Right", "Option-Right"),
            exec: function(editor) {
                editor.navigateWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selecttolineend",
            description: "Select to line end",
            bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
            exec: function(editor) {
                editor.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotolineend",
            description: "Go to line end",
            bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
            exec: function(editor) {
                editor.navigateLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectright",
            description: "Select right",
            bindKey: bindKey("Shift-Right", "Shift-Right"),
            exec: function(editor) {
                editor.getSelection().selectRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "gotoright",
            description: "Go to right",
            bindKey: bindKey("Right", "Right|Ctrl-F"),
            exec: function(editor, args) {
                editor.navigateRight(args.times);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectpagedown",
            description: "Select page down",
            bindKey: "Shift-PageDown",
            exec: function(editor) {
                editor.selectPageDown();
            },
            readOnly: true
        },
        {
            name: "pagedown",
            description: "Page down",
            bindKey: bindKey(null, "Option-PageDown"),
            exec: function(editor) {
                editor.scrollPageDown();
            },
            readOnly: true
        },
        {
            name: "gotopagedown",
            description: "Go to page down",
            bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
            exec: function(editor) {
                editor.gotoPageDown();
            },
            readOnly: true
        },
        {
            name: "selectpageup",
            description: "Select page up",
            bindKey: "Shift-PageUp",
            exec: function(editor) {
                editor.selectPageUp();
            },
            readOnly: true
        },
        {
            name: "pageup",
            description: "Page up",
            bindKey: bindKey(null, "Option-PageUp"),
            exec: function(editor) {
                editor.scrollPageUp();
            },
            readOnly: true
        },
        {
            name: "gotopageup",
            description: "Go to page up",
            bindKey: "PageUp",
            exec: function(editor) {
                editor.gotoPageUp();
            },
            readOnly: true
        },
        {
            name: "scrollup",
            description: "Scroll up",
            bindKey: bindKey("Ctrl-Up", null),
            exec: function(e) {
                e.renderer.scrollBy(0, -2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: true
        },
        {
            name: "scrolldown",
            description: "Scroll down",
            bindKey: bindKey("Ctrl-Down", null),
            exec: function(e) {
                e.renderer.scrollBy(0, 2 * e.renderer.layerConfig.lineHeight);
            },
            readOnly: true
        },
        {
            name: "selectlinestart",
            description: "Select line start",
            bindKey: "Shift-Home",
            exec: function(editor) {
                editor.getSelection().selectLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectlineend",
            description: "Select line end",
            bindKey: "Shift-End",
            exec: function(editor) {
                editor.getSelection().selectLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "togglerecording",
            description: "Toggle recording",
            bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
            exec: function(editor) {
                editor.commands.toggleRecording(editor);
            },
            readOnly: true
        },
        {
            name: "replaymacro",
            description: "Replay macro",
            bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
            exec: function(editor) {
                editor.commands.replay(editor);
            },
            readOnly: true
        },
        {
            name: "jumptomatching",
            description: "Jump to matching",
            bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
            exec: function(editor) {
                editor.jumpToMatching();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
        },
        {
            name: "selecttomatching",
            description: "Select to matching",
            bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
            exec: function(editor) {
                editor.jumpToMatching(true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
        },
        {
            name: "expandToMatching",
            description: "Expand to matching",
            bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
            exec: function(editor) {
                editor.jumpToMatching(true, true);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "animate",
            readOnly: true
        },
        {
            name: "passKeysToBrowser",
            description: "Pass keys to browser",
            bindKey: bindKey(null, null),
            exec: function() {},
            passEvent: true,
            readOnly: true
        },
        {
            name: "copy",
            description: "Copy",
            exec: function(editor) {},
            readOnly: true
        },
        {
            name: "cut",
            description: "Cut",
            exec: function(editor) {
                var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
                var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
                editor._emit("cut", range);
                if (!range.isEmpty()) editor.session.remove(range);
                editor.clearSelection();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "paste",
            description: "Paste",
            exec: function(editor, args) {
                editor.$handlePaste(args);
            },
            scrollIntoView: "cursor"
        },
        {
            name: "removeline",
            description: "Remove line",
            bindKey: bindKey("Ctrl-D", "Command-D"),
            exec: function(editor) {
                editor.removeLines();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEachLine"
        },
        {
            name: "duplicateSelection",
            description: "Duplicate selection",
            bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
            exec: function(editor) {
                editor.duplicateSelection();
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "sortlines",
            description: "Sort lines",
            bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
            exec: function(editor) {
                editor.sortLines();
            },
            scrollIntoView: "selection",
            multiSelectAction: "forEachLine"
        },
        {
            name: "togglecomment",
            description: "Toggle comment",
            bindKey: bindKey("Ctrl-/", "Command-/"),
            exec: function(editor) {
                editor.toggleCommentLines();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "toggleBlockComment",
            description: "Toggle block comment",
            bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
            exec: function(editor) {
                editor.toggleBlockComment();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "modifyNumberUp",
            description: "Modify number up",
            bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
            exec: function(editor) {
                editor.modifyNumber(1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "modifyNumberDown",
            description: "Modify number down",
            bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
            exec: function(editor) {
                editor.modifyNumber(-1);
            },
            scrollIntoView: "cursor",
            multiSelectAction: "forEach"
        },
        {
            name: "replace",
            description: "Replace",
            bindKey: bindKey("Ctrl-H", "Command-Option-F"),
            exec: function(editor) {
                config.loadModule("ace/ext/searchbox", function(e) {
                    e.Search(editor, true);
                });
            }
        },
        {
            name: "undo",
            description: "Undo",
            bindKey: bindKey("Ctrl-Z", "Command-Z"),
            exec: function(editor) {
                editor.undo();
            }
        },
        {
            name: "redo",
            description: "Redo",
            bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
            exec: function(editor) {
                editor.redo();
            }
        },
        {
            name: "copylinesup",
            description: "Copy lines up",
            bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
            exec: function(editor) {
                editor.copyLinesUp();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "movelinesup",
            description: "Move lines up",
            bindKey: bindKey("Alt-Up", "Option-Up"),
            exec: function(editor) {
                editor.moveLinesUp();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "copylinesdown",
            description: "Copy lines down",
            bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
            exec: function(editor) {
                editor.copyLinesDown();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "movelinesdown",
            description: "Move lines down",
            bindKey: bindKey("Alt-Down", "Option-Down"),
            exec: function(editor) {
                editor.moveLinesDown();
            },
            scrollIntoView: "cursor"
        },
        {
            name: "del",
            description: "Delete",
            bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
            exec: function(editor) {
                editor.remove("right");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "backspace",
            description: "Backspace",
            bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
            exec: function(editor) {
                editor.remove("left");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "cut_or_delete",
            description: "Cut or delete",
            bindKey: bindKey("Shift-Delete", null),
            exec: function(editor) {
                if (editor.selection.isEmpty()) editor.remove("left");
                else return false;
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolinestart",
            description: "Remove to line start",
            bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
            exec: function(editor) {
                editor.removeToLineStart();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolineend",
            description: "Remove to line end",
            bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
            exec: function(editor) {
                editor.removeToLineEnd();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolinestarthard",
            description: "Remove to line start hard",
            bindKey: bindKey("Ctrl-Shift-Backspace", null),
            exec: function(editor) {
                var range = editor.selection.getRange();
                range.start.column = 0;
                editor.session.remove(range);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removetolineendhard",
            description: "Remove to line end hard",
            bindKey: bindKey("Ctrl-Shift-Delete", null),
            exec: function(editor) {
                var range = editor.selection.getRange();
                range.end.column = Number.MAX_VALUE;
                editor.session.remove(range);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removewordleft",
            description: "Remove word left",
            bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
            exec: function(editor) {
                editor.removeWordLeft();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "removewordright",
            description: "Remove word right",
            bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
            exec: function(editor) {
                editor.removeWordRight();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "outdent",
            description: "Outdent",
            bindKey: bindKey("Shift-Tab", "Shift-Tab"),
            exec: function(editor) {
                editor.blockOutdent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "indent",
            description: "Indent",
            bindKey: bindKey("Tab", "Tab"),
            exec: function(editor) {
                editor.indent();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "selectionPart"
        },
        {
            name: "blockoutdent",
            description: "Block outdent",
            bindKey: bindKey("Ctrl-[", "Ctrl-["),
            exec: function(editor) {
                editor.blockOutdent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "blockindent",
            description: "Block indent",
            bindKey: bindKey("Ctrl-]", "Ctrl-]"),
            exec: function(editor) {
                editor.blockIndent();
            },
            multiSelectAction: "forEachLine",
            scrollIntoView: "selectionPart"
        },
        {
            name: "insertstring",
            description: "Insert string",
            exec: function(editor, str) {
                editor.insert(str);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "inserttext",
            description: "Insert text",
            exec: function(editor, args) {
                editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "splitline",
            description: "Split line",
            bindKey: bindKey(null, "Ctrl-O"),
            exec: function(editor) {
                editor.splitLine();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "transposeletters",
            description: "Transpose letters",
            bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
            exec: function(editor) {
                editor.transposeLetters();
            },
            multiSelectAction: function(editor) {
                editor.transposeSelections(1);
            },
            scrollIntoView: "cursor"
        },
        {
            name: "touppercase",
            description: "To uppercase",
            bindKey: bindKey("Ctrl-U", "Ctrl-U"),
            exec: function(editor) {
                editor.toUpperCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "tolowercase",
            description: "To lowercase",
            bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
            exec: function(editor) {
                editor.toLowerCase();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "autoindent",
            description: "Auto Indent",
            bindKey: bindKey(null, null),
            exec: function(editor) {
                editor.autoIndent();
            },
            scrollIntoView: "animate"
        },
        {
            name: "expandtoline",
            description: "Expand to line",
            bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
            exec: function(editor) {
                var range = editor.selection.getRange();
                range.start.column = range.end.column = 0;
                range.end.row++;
                editor.selection.setRange(range, false);
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "openlink",
            bindKey: bindKey("Ctrl+F3", "F3"),
            exec: function(editor) {
                editor.openLink();
            }
        },
        {
            name: "joinlines",
            description: "Join lines",
            bindKey: bindKey(null, null),
            exec: function(editor) {
                var isBackwards = editor.selection.isBackwards();
                var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
                var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
                var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
                var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
                var selectedCount = selectedText.replace(/\n\s*/, " ").length;
                var insertLine = editor.session.doc.getLine(selectionStart.row);
                for(var i = selectionStart.row + 1; i <= selectionEnd.row + 1; i++){
                    var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i)));
                    if (curLine.length !== 0) curLine = " " + curLine;
                    insertLine += curLine;
                }
                if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) insertLine += editor.session.doc.getNewLineCharacter();
                editor.clearSelection();
                editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
                if (selectedCount > 0) {
                    editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
                    editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
                } else {
                    firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
                    editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
                }
            },
            multiSelectAction: "forEach",
            readOnly: true
        },
        {
            name: "invertSelection",
            description: "Invert selection",
            bindKey: bindKey(null, null),
            exec: function(editor) {
                var endRow = editor.session.doc.getLength() - 1;
                var endCol = editor.session.doc.getLine(endRow).length;
                var ranges = editor.selection.rangeList.ranges;
                var newRanges = [];
                if (ranges.length < 1) ranges = [
                    editor.selection.getRange()
                ];
                for(var i = 0; i < ranges.length; i++){
                    if (i == ranges.length - 1) {
                        if (!(ranges[i].end.row === endRow && ranges[i].end.column === endCol)) newRanges.push(new Range(ranges[i].end.row, ranges[i].end.column, endRow, endCol));
                    }
                    if (i === 0) {
                        if (!(ranges[i].start.row === 0 && ranges[i].start.column === 0)) newRanges.push(new Range(0, 0, ranges[i].start.row, ranges[i].start.column));
                    } else newRanges.push(new Range(ranges[i - 1].end.row, ranges[i - 1].end.column, ranges[i].start.row, ranges[i].start.column));
                }
                editor.exitMultiSelectMode();
                editor.clearSelection();
                for(var i = 0; i < newRanges.length; i++)editor.selection.addRange(newRanges[i], false);
            },
            readOnly: true,
            scrollIntoView: "none"
        },
        {
            name: "addLineAfter",
            description: "Add new line after the current line",
            exec: function(editor) {
                editor.selection.clearSelection();
                editor.navigateLineEnd();
                editor.insert("\n");
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "addLineBefore",
            description: "Add new line before the current line",
            exec: function(editor) {
                editor.selection.clearSelection();
                var cursor = editor.getCursorPosition();
                editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
                editor.insert("\n");
                if (cursor.row === 0) editor.navigateUp();
            },
            multiSelectAction: "forEach",
            scrollIntoView: "cursor"
        },
        {
            name: "openCommandPallete",
            exec: function(editor) {
                console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
                editor.prompt({
                    $type: "commands"
                });
            },
            readOnly: true
        },
        {
            name: "openCommandPalette",
            description: "Open command palette",
            bindKey: bindKey("F1", "F1"),
            exec: function(editor) {
                editor.prompt({
                    $type: "commands"
                });
            },
            readOnly: true
        },
        {
            name: "modeSelect",
            description: "Change language mode...",
            bindKey: bindKey(null, null),
            exec: function(editor) {
                editor.prompt({
                    $type: "modes"
                });
            },
            readOnly: true
        }
    ];
    for(var i = 1; i < 9; i++)exports.commands.push({
        name: "foldToLevel" + i,
        description: "Fold To Level " + i,
        level: i,
        exec: function(editor) {
            editor.session.foldToLevel(this.level);
        },
        scrollIntoView: "center",
        readOnly: true
    });
});
ace.define("ace/keyboard/gutter_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/keys",
    "ace/mouse/default_gutter_handler"
], function(require, exports, module1) {
    "use strict";
    var keys = require("../lib/keys");
    var GutterTooltip = require("../mouse/default_gutter_handler").GutterTooltip;
    var GutterKeyboardHandler = /** @class */ function() {
        function GutterKeyboardHandler(editor) {
            this.editor = editor;
            this.gutterLayer = editor.renderer.$gutterLayer;
            this.element = editor.renderer.$gutter;
            this.lines = editor.renderer.$gutterLayer.$lines;
            this.activeRowIndex = null;
            this.activeLane = null;
            this.annotationTooltip = new GutterTooltip(this.editor);
        }
        GutterKeyboardHandler.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.addEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.on("mousewheel", this.$blurGutter.bind(this));
        };
        GutterKeyboardHandler.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.off("mousewheel", this.$blurGutter.bind(this));
        };
        GutterKeyboardHandler.prototype.$onGutterKeyDown = function(e) {
            if (this.annotationTooltip.isOpen) {
                e.preventDefault();
                if (e.keyCode === keys["escape"]) this.annotationTooltip.hideTooltip();
                return;
            }
            if (e.target === this.element) {
                if (e.keyCode != keys["enter"]) return;
                e.preventDefault();
                var row = this.editor.getCursorPosition().row;
                if (!this.editor.isRowVisible(row)) this.editor.scrollToLine(row, true, true);
                setTimeout((function() {
                    var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                    var nearestFoldLaneWidgetIndex = this.$findNearestFoldLaneWidget(index);
                    var nearestAnnotationIndex = this.$findNearestAnnotation(index);
                    if (nearestFoldLaneWidgetIndex === null && nearestAnnotationIndex === null) return;
                    var futureActiveRowIndex = this.$findClosestNumber(nearestFoldLaneWidgetIndex, nearestAnnotationIndex, index);
                    if (futureActiveRowIndex === nearestFoldLaneWidgetIndex) {
                        this.activeLane = "fold";
                        this.activeRowIndex = nearestFoldLaneWidgetIndex;
                        if (this.$isCustomWidgetVisible(nearestFoldLaneWidgetIndex)) {
                            this.$focusCustomWidget(this.activeRowIndex);
                            return;
                        } else {
                            this.$focusFoldWidget(this.activeRowIndex);
                            return;
                        }
                    } else {
                        this.activeRowIndex = nearestAnnotationIndex;
                        this.activeLane = "annotation";
                        this.$focusAnnotation(this.activeRowIndex);
                        return;
                    }
                }).bind(this), 10);
                return;
            }
            this.$handleGutterKeyboardInteraction(e);
            setTimeout((function() {
                this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e, this));
            }).bind(this), 10);
        };
        GutterKeyboardHandler.prototype.$handleGutterKeyboardInteraction = function(e) {
            if (e.keyCode === keys["tab"]) {
                e.preventDefault();
                return;
            }
            if (e.keyCode === keys["escape"]) {
                e.preventDefault();
                this.$blurGutter();
                this.element.focus();
                this.lane = null;
                return;
            }
            if (e.keyCode === keys["up"]) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        this.$moveFoldWidgetUp();
                        break;
                    case "annotation":
                        this.$moveAnnotationUp();
                        break;
                }
                return;
            }
            if (e.keyCode === keys["down"]) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        this.$moveFoldWidgetDown();
                        break;
                    case "annotation":
                        this.$moveAnnotationDown();
                        break;
                }
                return;
            }
            if (e.keyCode === keys["left"]) {
                e.preventDefault();
                this.$switchLane("annotation");
                return;
            }
            if (e.keyCode === keys["right"]) {
                e.preventDefault();
                this.$switchLane("fold");
                return;
            }
            if (e.keyCode === keys["enter"] || e.keyCode === keys["space"]) {
                e.preventDefault();
                switch(this.activeLane){
                    case "fold":
                        var row = this.$rowIndexToRow(this.activeRowIndex);
                        var customWidget = this.editor.session.$gutterCustomWidgets[row];
                        if (customWidget) {
                            if (customWidget.callbacks && customWidget.callbacks.onClick) customWidget.callbacks.onClick(e, row);
                        } else if (this.gutterLayer.session.foldWidgets[row] === "start") {
                            this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e);
                            setTimeout((function() {
                                if (this.$rowIndexToRow(this.activeRowIndex) !== row) {
                                    this.$blurFoldWidget(this.activeRowIndex);
                                    this.activeRowIndex = this.$rowToRowIndex(row);
                                    this.$focusFoldWidget(this.activeRowIndex);
                                }
                            }).bind(this), 10);
                            break;
                        } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") break;
                        return;
                    case "annotation":
                        var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                        var rect = gutterElement.getBoundingClientRect();
                        var style = this.annotationTooltip.getElement().style;
                        style.left = rect.right + "px";
                        style.top = rect.bottom + "px";
                        this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                        break;
                }
                return;
            }
        };
        GutterKeyboardHandler.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) switch(this.activeLane){
                case "fold":
                    this.$blurFoldWidget(this.activeRowIndex);
                    this.$blurCustomWidget(this.activeRowIndex);
                    break;
                case "annotation":
                    this.$blurAnnotation(this.activeRowIndex);
                    break;
            }
            if (this.annotationTooltip.isOpen) this.annotationTooltip.hideTooltip();
            return;
        };
        GutterKeyboardHandler.prototype.$isFoldWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler.prototype.$isCustomWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = !!this.$getCustomWidget(index);
            return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler.prototype.$isAnnotationVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getAnnotation(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
        };
        GutterKeyboardHandler.prototype.$getFoldWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[1];
        };
        GutterKeyboardHandler.prototype.$getCustomWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[3];
        };
        GutterKeyboardHandler.prototype.$getAnnotation = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[2];
        };
        GutterKeyboardHandler.prototype.$findNearestFoldLaneWidget = function(index) {
            if (this.$isCustomWidgetVisible(index)) return index;
            if (this.$isFoldWidgetVisible(index)) return index;
            var i = 0;
            while(index - i > 0 || index + i < this.lines.getLength() - 1){
                i++;
                if (index - i >= 0 && this.$isCustomWidgetVisible(index - i)) return index - i;
                if (index + i <= this.lines.getLength() - 1 && this.$isCustomWidgetVisible(index + i)) return index + i;
                if (index - i >= 0 && this.$isFoldWidgetVisible(index - i)) return index - i;
                if (index + i <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i)) return index + i;
            }
            return null;
        };
        GutterKeyboardHandler.prototype.$findNearestAnnotation = function(index) {
            if (this.$isAnnotationVisible(index)) return index;
            var i = 0;
            while(index - i > 0 || index + i < this.lines.getLength() - 1){
                i++;
                if (index - i >= 0 && this.$isAnnotationVisible(index - i)) return index - i;
                if (index + i <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i)) return index + i;
            }
            return null;
        };
        GutterKeyboardHandler.prototype.$focusFoldWidget = function(index) {
            if (index == null) return;
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            foldWidget.focus();
        };
        GutterKeyboardHandler.prototype.$focusCustomWidget = function(index) {
            if (index == null) return;
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
                customWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
                customWidget.focus();
            }
        };
        GutterKeyboardHandler.prototype.$focusAnnotation = function(index) {
            if (index == null) return;
            var annotation = this.$getAnnotation(index);
            annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
            annotation.focus();
        };
        GutterKeyboardHandler.prototype.$blurFoldWidget = function(index) {
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            foldWidget.blur();
        };
        GutterKeyboardHandler.prototype.$blurCustomWidget = function(index) {
            var customWidget = this.$getCustomWidget(index);
            if (customWidget) {
                customWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
                customWidget.blur();
            }
        };
        GutterKeyboardHandler.prototype.$blurAnnotation = function(index) {
            var annotation = this.$getAnnotation(index);
            annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
            annotation.blur();
        };
        GutterKeyboardHandler.prototype.$moveFoldWidgetUp = function() {
            var index = this.activeRowIndex;
            while(index > 0){
                index--;
                if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                    this.$blurFoldWidget(this.activeRowIndex);
                    this.$blurCustomWidget(this.activeRowIndex);
                    this.activeRowIndex = index;
                    if (this.$isFoldWidgetVisible(index)) this.$focusFoldWidget(this.activeRowIndex);
                    else this.$focusCustomWidget(this.activeRowIndex);
                    return;
                }
            }
            return;
        };
        GutterKeyboardHandler.prototype.$moveFoldWidgetDown = function() {
            var index = this.activeRowIndex;
            while(index < this.lines.getLength() - 1){
                index++;
                if (this.$isFoldWidgetVisible(index) || this.$isCustomWidgetVisible(index)) {
                    this.$blurFoldWidget(this.activeRowIndex);
                    this.$blurCustomWidget(this.activeRowIndex);
                    this.activeRowIndex = index;
                    if (this.$isFoldWidgetVisible(index)) this.$focusFoldWidget(this.activeRowIndex);
                    else this.$focusCustomWidget(this.activeRowIndex);
                    return;
                }
            }
            return;
        };
        GutterKeyboardHandler.prototype.$moveAnnotationUp = function() {
            var index = this.activeRowIndex;
            while(index > 0){
                index--;
                if (this.$isAnnotationVisible(index)) {
                    this.$blurAnnotation(this.activeRowIndex);
                    this.activeRowIndex = index;
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                }
            }
            return;
        };
        GutterKeyboardHandler.prototype.$moveAnnotationDown = function() {
            var index = this.activeRowIndex;
            while(index < this.lines.getLength() - 1){
                index++;
                if (this.$isAnnotationVisible(index)) {
                    this.$blurAnnotation(this.activeRowIndex);
                    this.activeRowIndex = index;
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                }
            }
            return;
        };
        GutterKeyboardHandler.prototype.$findClosestNumber = function(num1, num2, target) {
            if (num1 === null) return num2;
            if (num2 === null) return num1;
            return Math.abs(target - num1) <= Math.abs(target - num2) ? num1 : num2;
        };
        GutterKeyboardHandler.prototype.$switchLane = function(desinationLane) {
            switch(desinationLane){
                case "annotation":
                    if (this.activeLane === "annotation") break;
                    var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                    if (annotationIndex == null) break;
                    this.activeLane = "annotation";
                    this.$blurFoldWidget(this.activeRowIndex);
                    this.$blurCustomWidget(this.activeRowIndex);
                    this.activeRowIndex = annotationIndex;
                    this.$focusAnnotation(this.activeRowIndex);
                    break;
                case "fold":
                    if (this.activeLane === "fold") break;
                    var foldLaneWidgetIndex = this.$findNearestFoldLaneWidget(this.activeRowIndex);
                    if (foldLaneWidgetIndex === null) break;
                    this.activeLane = "fold";
                    this.$blurAnnotation(this.activeRowIndex);
                    this.activeRowIndex = foldLaneWidgetIndex;
                    if (this.$isCustomWidgetVisible(foldLaneWidgetIndex)) this.$focusCustomWidget(this.activeRowIndex);
                    else this.$focusFoldWidget(this.activeRowIndex);
                    break;
            }
            return;
        };
        GutterKeyboardHandler.prototype.$rowIndexToRow = function(index) {
            var cell = this.lines.get(index);
            if (cell) return cell.row;
            return null;
        };
        GutterKeyboardHandler.prototype.$rowToRowIndex = function(row) {
            for(var i = 0; i < this.lines.getLength(); i++){
                var cell = this.lines.get(i);
                if (cell.row == row) return i;
            }
            return null;
        };
        return GutterKeyboardHandler;
    }();
    exports.GutterKeyboardHandler = GutterKeyboardHandler;
    var GutterKeyboardEvent = /** @class */ function() {
        function GutterKeyboardEvent(domEvent, gutterKeyboardHandler) {
            this.gutterKeyboardHandler = gutterKeyboardHandler;
            this.domEvent = domEvent;
        }
        GutterKeyboardEvent.prototype.getKey = function() {
            return keys.keyCodeToString(this.domEvent.keyCode);
        };
        GutterKeyboardEvent.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
        };
        GutterKeyboardEvent.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
        };
        GutterKeyboardEvent.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
        };
        return GutterKeyboardEvent;
    }();
    exports.GutterKeyboardEvent = GutterKeyboardEvent;
});
ace.define("ace/editor", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/lib/useragent",
    "ace/keyboard/textinput",
    "ace/mouse/mouse_handler",
    "ace/mouse/fold_handler",
    "ace/keyboard/keybinding",
    "ace/edit_session",
    "ace/search",
    "ace/range",
    "ace/lib/event_emitter",
    "ace/commands/command_manager",
    "ace/commands/default_commands",
    "ace/config",
    "ace/token_iterator",
    "ace/keyboard/gutter_handler",
    "ace/config",
    "ace/clipboard",
    "ace/lib/keys",
    "ace/lib/event",
    "ace/tooltip"
], function(require, exports, module1) {
    "use strict";
    var __values = this && this.__values || function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function() {
                if (o && i >= o.length) o = void 0;
                return {
                    value: o && o[i++],
                    done: !o
                };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var lang = require("./lib/lang");
    var useragent = require("./lib/useragent");
    var TextInput = require("./keyboard/textinput").TextInput;
    var MouseHandler = require("./mouse/mouse_handler").MouseHandler;
    var FoldHandler = require("./mouse/fold_handler").FoldHandler;
    var KeyBinding = require("./keyboard/keybinding").KeyBinding;
    var EditSession = require("./edit_session").EditSession;
    var Search = require("./search").Search;
    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var CommandManager = require("./commands/command_manager").CommandManager;
    var defaultCommands = require("./commands/default_commands").commands;
    var config = require("./config");
    var TokenIterator = require("./token_iterator").TokenIterator;
    var GutterKeyboardHandler = require("./keyboard/gutter_handler").GutterKeyboardHandler;
    var nls = require("./config").nls;
    var clipboard = require("./clipboard");
    var keys = require("./lib/keys");
    var event = require("./lib/event");
    var HoverTooltip = require("./tooltip").HoverTooltip;
    var Editor = /** @class */ function() {
        function Editor(renderer, session, options) {
            this.id = "editor" + ++Editor.$uid;
            this.session;
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
                this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
                this.renderer.textarea = this.textInput.getElement();
                this.$mouseHandler = new MouseHandler(this);
                new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
                wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall((function() {
                this._signal("input", {});
                if (this.session && !this.session.destroyed) this.session.bgTokenizer.scheduleStart();
            }).bind(this));
            this.on("change", function(_, _self) {
                _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config.resetOptions(this);
            if (options) this.setOptions(options);
            config._signal("editor", this);
        }
        Editor.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
        };
        Editor.prototype.startOperation = function(commandEvent) {
            this.session.startOperation(commandEvent);
        };
        Editor.prototype.endOperation = function(e) {
            this.session.endOperation(e);
        };
        Editor.prototype.onStartOperation = function(commandEvent) {
            this.curOp = this.session.curOp;
            this.curOp.scrollTop = this.renderer.scrollTop;
            this.prevOp = this.session.prevOp;
            if (!commandEvent) this.previousCommand = null;
        };
        Editor.prototype.onEndOperation = function(e) {
            if (this.curOp && this.session) {
                if (e && e.returnValue === false) {
                    this.curOp = null;
                    return;
                }
                this._signal("beforeEndOperation");
                if (!this.curOp) return;
                var command = this.curOp.command;
                var scrollIntoView = command && command.scrollIntoView;
                if (scrollIntoView) {
                    switch(scrollIntoView){
                        case "center-animate":
                            scrollIntoView = "animate";
                        case "center":
                            this.renderer.scrollCursorIntoView(null, 0.5);
                            break;
                        case "animate":
                        case "cursor":
                            this.renderer.scrollCursorIntoView();
                            break;
                        case "selectionPart":
                            var range = this.selection.getRange();
                            var config = this.renderer.layerConfig;
                            if (range.start.row >= config.lastRow || range.end.row <= config.firstRow) this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                            break;
                        default:
                            break;
                    }
                    if (scrollIntoView == "animate") this.renderer.animateScrolling(this.curOp.scrollTop);
                }
                this.$lastSel = this.session.selection.toJSON();
                this.prevOp = this.curOp;
                this.curOp = null;
            }
        };
        Editor.prototype.$historyTracker = function(e) {
            if (!this.$mergeUndoDeltas) return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e.command.name == prev.command.name;
            if (e.command.name == "insertstring") {
                var text = e.args;
                if (this.mergeNextCommand === undefined) this.mergeNextCommand = true;
                shouldMerge = shouldMerge && this.mergeNextCommand // previous command allows to coalesce with
                 && (!/\s/.test(text) || /\s/.test(prev.args)); // previous insertion was of same type
                this.mergeNextCommand = true;
            } else shouldMerge = shouldMerge && mergeableCommands.indexOf(e.command.name) !== -1; // the command is mergeable
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2000) shouldMerge = false; // the sequence is too long
            if (shouldMerge) this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e.command.name) !== -1) this.sequenceStartTime = Date.now();
        };
        Editor.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
                this.$keybindingId = keyboardHandler;
                var _self = this;
                config.loadModule([
                    "keybinding",
                    keyboardHandler
                ], function(module1) {
                    if (_self.$keybindingId == keyboardHandler) _self.keyBinding.setKeyboardHandler(module1 && module1.handler);
                    cb && cb();
                });
            } else {
                this.$keybindingId = null;
                this.keyBinding.setKeyboardHandler(keyboardHandler);
                cb && cb();
            }
        };
        Editor.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
        };
        Editor.prototype.setSession = function(session) {
            if (this.session == session) return;
            if (this.curOp) this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
                this.session.off("change", this.$onDocumentChange);
                this.session.off("changeMode", this.$onChangeMode);
                this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
                this.session.off("changeTabSize", this.$onChangeTabSize);
                this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
                this.session.off("changeWrapMode", this.$onChangeWrapMode);
                this.session.off("changeFold", this.$onChangeFold);
                this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
                this.session.off("changeBackMarker", this.$onChangeBackMarker);
                this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
                this.session.off("changeAnnotation", this.$onChangeAnnotation);
                this.session.off("changeOverwrite", this.$onCursorChange);
                this.session.off("changeScrollTop", this.$onScrollTopChange);
                this.session.off("changeScrollLeft", this.$onScrollLeftChange);
                this.session.off("startOperation", this.$onStartOperation);
                this.session.off("endOperation", this.$onEndOperation);
                var selection = this.session.getSelection();
                selection.off("changeCursor", this.$onCursorChange);
                selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
                this.$onDocumentChange = this.onDocumentChange.bind(this);
                session.on("change", this.$onDocumentChange);
                this.renderer.setSession(session);
                this.$onChangeMode = this.onChangeMode.bind(this);
                session.on("changeMode", this.$onChangeMode);
                this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
                session.on("tokenizerUpdate", this.$onTokenizerUpdate);
                this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
                session.on("changeTabSize", this.$onChangeTabSize);
                this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
                session.on("changeWrapLimit", this.$onChangeWrapLimit);
                this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
                session.on("changeWrapMode", this.$onChangeWrapMode);
                this.$onChangeFold = this.onChangeFold.bind(this);
                session.on("changeFold", this.$onChangeFold);
                this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
                this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
                this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
                this.session.on("changeBackMarker", this.$onChangeBackMarker);
                this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
                this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
                this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
                this.session.on("changeAnnotation", this.$onChangeAnnotation);
                this.$onCursorChange = this.onCursorChange.bind(this);
                this.session.on("changeOverwrite", this.$onCursorChange);
                this.$onScrollTopChange = this.onScrollTopChange.bind(this);
                this.session.on("changeScrollTop", this.$onScrollTopChange);
                this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
                this.session.on("changeScrollLeft", this.$onScrollLeftChange);
                this.selection = session.getSelection();
                this.selection.on("changeCursor", this.$onCursorChange);
                this.$onSelectionChange = this.onSelectionChange.bind(this);
                this.selection.on("changeSelection", this.$onSelectionChange);
                this.$onStartOperation = this.onStartOperation.bind(this);
                this.session.on("startOperation", this.$onStartOperation);
                this.$onEndOperation = this.onEndOperation.bind(this);
                this.session.on("endOperation", this.$onEndOperation);
                this.onChangeMode();
                this.onCursorChange();
                this.onScrollTopChange();
                this.onScrollLeftChange();
                this.onSelectionChange();
                this.onChangeFrontMarker();
                this.onChangeBackMarker();
                this.onChangeBreakpoint();
                this.onChangeAnnotation();
                this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
                this.renderer.updateFull();
            } else {
                this.selection = null;
                this.renderer.setSession(session);
            }
            this._signal("changeSession", {
                session: session,
                oldSession: oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", {
                oldEditor: this
            });
            if (oldSession) oldSession.$editor = null;
            session && session._signal("changeEditor", {
                editor: this
            });
            if (session) session.$editor = this;
            if (session && !session.destroyed) session.bgTokenizer.scheduleStart();
        };
        Editor.prototype.getSession = function() {
            return this.session;
        };
        Editor.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos) this.selectAll();
            else if (cursorPos == 1) this.navigateFileEnd();
            else if (cursorPos == -1) this.navigateFileStart();
            return val;
        };
        Editor.prototype.getValue = function() {
            return this.session.getValue();
        };
        Editor.prototype.getSelection = function() {
            return this.selection;
        };
        Editor.prototype.resize = function(force) {
            this.renderer.onResize(force);
        };
        Editor.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
        };
        Editor.prototype.getTheme = function() {
            return this.renderer.getTheme();
        };
        Editor.prototype.setStyle = function(style, incluude) {
            this.renderer.setStyle(style, incluude);
        };
        Editor.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
        };
        Editor.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
        };
        Editor.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
        };
        Editor.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) return;
            var self1 = this;
            this.$highlightPending = true;
            setTimeout(function() {
                self1.$highlightPending = false;
                var session = self1.session;
                if (!session || session.destroyed) return;
                if (session.$bracketHighlight) {
                    session.$bracketHighlight.markerIds.forEach(function(id) {
                        session.removeMarker(id);
                    });
                    session.$bracketHighlight = null;
                }
                var pos = self1.getCursorPosition();
                var handler = self1.getKeyboardHandler();
                var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self1);
                var ranges = session.getMatchingBracketRanges(pos, isBackwards);
                if (!ranges) {
                    var iterator = new TokenIterator(session, pos.row, pos.column);
                    var token = iterator.getCurrentToken();
                    if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                        var tagNamesRanges = session.getMatchingTags(pos);
                        if (tagNamesRanges) ranges = [
                            tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                            tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                        ];
                    }
                }
                if (!ranges && session.$mode.getMatching) ranges = session.$mode.getMatching(self1.session);
                if (!ranges) {
                    if (self1.getHighlightIndentGuides()) self1.renderer.$textLayer.$highlightIndentGuide();
                    return;
                }
                var markerType = "ace_bracket";
                if (!Array.isArray(ranges)) ranges = [
                    ranges
                ];
                else if (ranges.length == 1) markerType = "ace_error_bracket";
                if (ranges.length == 2) {
                    if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0) ranges = [
                        Range.fromPoints(ranges[0].start, ranges[1].end)
                    ];
                    else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0) ranges = [
                        Range.fromPoints(ranges[1].start, ranges[0].end)
                    ];
                }
                session.$bracketHighlight = {
                    ranges: ranges,
                    markerIds: ranges.map(function(range) {
                        return session.addMarker(range, markerType, "text");
                    })
                };
                if (self1.getHighlightIndentGuides()) self1.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
        };
        Editor.prototype.focus = function() {
            this.textInput.focus();
        };
        Editor.prototype.isFocused = function() {
            return this.textInput.isFocused();
        };
        Editor.prototype.blur = function() {
            this.textInput.blur();
        };
        Editor.prototype.onFocus = function(e) {
            if (this.$isFocused) return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e);
        };
        Editor.prototype.onBlur = function(e) {
            if (!this.$isFocused) return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e);
        };
        Editor.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
        };
        Editor.prototype.onDocumentChange = function(delta) {
            var wrap = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap);
            this._signal("change", delta);
            this.$cursorChange();
        };
        Editor.prototype.onTokenizerUpdate = function(e) {
            var rows = e.data;
            this.renderer.updateLines(rows.first, rows.last);
        };
        Editor.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
        };
        Editor.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
        };
        Editor.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
        };
        Editor.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
                if (this.$selectionStyle != "line" || !this.selection.isMultiLine()) highlight = this.getCursorPosition();
                if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty()) highlight = false;
                if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1)) highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
                session.removeMarker(session.$highlightLineMarker.id);
                session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
                var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
                range.id = session.addMarker(range, "ace_active-line", "screenLine");
                session.$highlightLineMarker = range;
            } else if (highlight) {
                session.$highlightLineMarker.start.row = highlight.row;
                session.$highlightLineMarker.end.row = highlight.row;
                session.$highlightLineMarker.start.column = highlight.column;
                session._signal("changeBackMarker");
            }
        };
        Editor.prototype.onSelectionChange = function(e) {
            var session = this.session;
            if (session.$selectionMarker) session.removeMarker(session.$selectionMarker);
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
                var range = this.selection.getRange();
                var style = this.getSelectionStyle();
                session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else this.$updateHighlightActiveLine();
            var re = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re);
            this._signal("changeSelection");
        };
        Editor.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine()) return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5000 || !/[\w\d]/.test(needle)) return;
            var re = this.$search.$assembleRegExp({
                wholeWord: true,
                caseSensitive: true,
                needle: needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re.test(wordWithBoundary)) return;
            return re;
        };
        Editor.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
        };
        Editor.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
        };
        Editor.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
        };
        Editor.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
        };
        Editor.prototype.onChangeMode = function(e) {
            this.renderer.updateText();
            this._emit("changeMode", e);
        };
        Editor.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
        };
        Editor.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
        };
        Editor.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
        };
        Editor.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
        };
        Editor.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
                copyLine = true;
                var ranges = this.selection.getAllRanges();
                for(var i = 0; i < ranges.length; i++){
                    var range = ranges[i];
                    if (i && ranges[i - 1].start.row == range.start.row) continue;
                    text += this.session.getLine(range.start.row) + nl;
                }
            }
            var e = {
                text: text
            };
            this._signal("copy", e);
            clipboard.lineMode = copyLine ? e.text : false;
            return e.text;
        };
        Editor.prototype.onCopy = function() {
            this.commands.exec("copy", this);
        };
        Editor.prototype.onCut = function() {
            this.commands.exec("cut", this);
        };
        Editor.prototype.onPaste = function(text, event) {
            var e = {
                text: text,
                event: event
            };
            this.commands.exec("paste", this, e);
        };
        Editor.prototype.$handlePaste = function(e) {
            if (typeof e == "string") e = {
                text: e
            };
            this._signal("paste", e);
            var text = e.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
                if (lineMode) session.insert({
                    row: this.selection.lead.row,
                    column: 0
                }, text);
                else this.insert(text);
            } else if (lineMode) this.selection.rangeList.ranges.forEach(function(range) {
                session.insert({
                    row: range.start.row,
                    column: 0
                }, text);
            });
            else {
                var lines = text.split(/\r\n|\r|\n/);
                var ranges = this.selection.rangeList.ranges;
                var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
                if (lines.length != ranges.length || isFullLine) return this.commands.exec("insertstring", this, text);
                for(var i = ranges.length; i--;){
                    var range = ranges[i];
                    if (!range.isEmpty()) session.remove(range);
                    session.insert(range.start, lines[i]);
                }
            }
        };
        Editor.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
        };
        Editor.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
                var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
                if (transform) {
                    if (text !== transform.text) {
                        if (!this.inVirtualSelectionMode) {
                            this.session.mergeUndoDeltas = false;
                            this.mergeNextCommand = false;
                        }
                    }
                    text = transform.text;
                }
            }
            if (text == "	") text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
                var range = this.getSelectionRange();
                cursor = this.session.remove(range);
                this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
                var range = Range.fromPoints(cursor, cursor);
                range.end.column += text.length;
                this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
                var line = session.getLine(cursor.row);
                if (cursor.column > line.search(/\S|$/)) {
                    var d = line.substr(cursor.column).search(/\S|$/);
                    session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d);
                }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
                if (transform.selection.length == 2) this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
                else this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
            }
            if (this.$enableAutoIndent) {
                if (session.getDocument().isNewLine(text)) {
                    var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                    session.insert({
                        row: cursor.row + 1,
                        column: 0
                    }, lineIndent);
                }
                if (shouldOutdent) mode.autoOutdent(lineState, session, cursor.row);
            }
        };
        Editor.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var ranges = this.selection.isEmpty() ? [
                new Range(0, 0, session.doc.getLength() - 1, 0)
            ] : this.selection.getAllRanges();
            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var tab = session.getTabString();
            for(var i = 0; i < ranges.length; i++){
                var startRow = ranges[i].start.row;
                var endRow = ranges[i].end.row;
                for(var row = startRow; row <= endRow; row++){
                    if (row > 0) {
                        prevLineState = session.getState(row - 1);
                        prevLine = session.getLine(row - 1);
                        lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                    }
                    var line = session.getLine(row);
                    var currIndent = mode.$getIndent(line);
                    if (lineIndent !== currIndent) {
                        if (currIndent.length > 0) {
                            var range = new Range(row, 0, row, currIndent.length);
                            session.remove(range);
                        }
                        if (lineIndent.length > 0) session.insert({
                            row: row,
                            column: 0
                        }, lineIndent);
                    }
                    mode.autoOutdent(prevLineState, session, row);
                }
            }
        };
        Editor.prototype.onTextInput = function(text, composition) {
            if (!composition) return this.keyBinding.onTextInput(text);
            this.startOperation({
                command: {
                    name: "insertstring"
                }
            });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount) this.forEachSelection(applyComposition);
            else applyComposition();
            this.endOperation();
        };
        Editor.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
                var r = this.selection.getRange();
                r.start.column -= composition.extendLeft;
                r.end.column += composition.extendRight;
                if (r.start.column < 0) {
                    r.start.row--;
                    r.start.column += this.session.getLine(r.start.row).length + 1;
                }
                this.selection.setRange(r);
                if (!text && !r.isEmpty()) this.remove();
            }
            if (text || !this.selection.isEmpty()) this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
                var r = this.selection.getRange();
                r.start.column -= composition.restoreStart;
                r.end.column -= composition.restoreEnd;
                this.selection.setRange(r);
            }
        };
        Editor.prototype.onCommandKey = function(e, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e, hashId, keyCode);
        };
        Editor.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
        };
        Editor.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
        };
        Editor.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
        };
        Editor.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
        };
        Editor.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
        };
        Editor.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
        };
        Editor.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
        };
        Editor.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
        };
        Editor.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
        };
        Editor.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
        };
        Editor.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
        };
        Editor.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };
        Editor.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };
        Editor.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
        };
        Editor.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
        };
        Editor.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
        };
        Editor.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
        };
        Editor.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
        };
        Editor.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
        };
        Editor.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
        };
        Editor.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
        };
        Editor.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
        };
        Editor.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
        };
        Editor.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
        };
        Editor.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
        };
        Editor.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
        };
        Editor.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
        };
        Editor.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
        };
        Editor.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
        };
        Editor.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
        };
        Editor.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
        };
        Editor.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
        };
        Editor.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
        };
        Editor.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
        };
        Editor.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
        };
        Editor.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
        };
        Editor.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        };
        Editor.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
                if (dir == "left") this.selection.selectLeft();
                else this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
                var session = this.session;
                var state = session.getState(range.start.row);
                var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
                if (range.end.column === 0) {
                    var text = session.getTextRange(range);
                    if (text[text.length - 1] == "\n") {
                        var line = session.getLine(range.end.row);
                        if (/^\s+$/.test(line)) range.end.column = line.length;
                    }
                }
                if (new_range) range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
        };
        Editor.prototype.removeWordRight = function() {
            if (this.selection.isEmpty()) this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        Editor.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty()) this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        Editor.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty()) this.selection.selectLineStart();
            if (this.selection.isEmpty()) this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
        };
        Editor.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty()) this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
                range.end.column = 0;
                range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
        };
        Editor.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
                this.session.remove(this.getSelectionRange());
                this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
        };
        Editor.prototype.setGhostText = function(text, position) {
            this.renderer.setGhostText(text, position);
        };
        Editor.prototype.removeGhostText = function() {
            this.renderer.removeGhostText();
        };
        Editor.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) return;
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0) return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
                swap = line.charAt(column) + line.charAt(column - 1);
                range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
                swap = line.charAt(column - 1) + line.charAt(column - 2);
                range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
        };
        Editor.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) this.selection.selectWord();
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
        };
        Editor.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) this.selection.selectWord();
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
        };
        Editor.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
            } else if (range.start.column < range.end.column) {
                var text = session.getTextRange(range);
                if (!/^\s+$/.test(text)) {
                    var rows = this.$getSelectedRows();
                    session.indentRows(rows.first, rows.last, "	");
                    return;
                }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
                var count = size - column % size;
                var indentString = lang.stringRepeat(" ", count);
            } else {
                var count = column % size;
                while(line[range.start.column - 1] == " " && count){
                    range.start.column--;
                    count--;
                }
                this.selection.setSelectionRange(range);
                indentString = "	";
            }
            return this.insert(indentString);
        };
        Editor.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
        };
        Editor.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
        };
        Editor.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for(var i = rows.first; i <= rows.last; i++)lines.push(session.getLine(i));
            lines.sort(function(a, b) {
                if (a.toLowerCase() < b.toLowerCase()) return -1;
                if (a.toLowerCase() > b.toLowerCase()) return 1;
                return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for(var i = rows.first; i <= rows.last; i++){
                var line = session.getLine(i);
                deleteRange.start.row = i;
                deleteRange.end.row = i;
                deleteRange.end.column = line.length;
                session.replace(deleteRange, lines[i - rows.first]);
            }
        };
        Editor.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
        };
        Editor.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
        };
        Editor.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s = this.session.getLine(row);
            while(_numberRx.lastIndex < column){
                var m = _numberRx.exec(s);
                if (m.index <= column && m.index + m[0].length >= column) {
                    var number = {
                        value: m[0],
                        start: m.index,
                        end: m.index + m[0].length
                    };
                    return number;
                }
            }
            return null;
        };
        Editor.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c)) && isFinite(c)) {
                var nr = this.getNumberAt(row, column);
                if (nr) {
                    var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                    var decimals = nr.start + nr.value.length - fp;
                    var t = parseFloat(nr.value);
                    t *= Math.pow(10, decimals);
                    if (fp !== nr.end && column < fp) amount *= Math.pow(10, nr.end - column - 1);
                    else amount *= Math.pow(10, nr.end - column);
                    t += amount;
                    t /= Math.pow(10, decimals);
                    var nnr = t.toFixed(decimals);
                    var replaceRange = new Range(row, nr.start, row, nr.end);
                    this.session.replace(replaceRange, nnr);
                    this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
                }
            } else this.toggleWord();
        };
        Editor.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0) delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) wordParts.forEach(function(item, i) {
                itLength = curLength + item.length;
                if (delta >= curLength && delta <= itLength) {
                    currentState = item;
                    that.selection.clearSelection();
                    that.moveCursorTo(row, curLength + currWordStart);
                    that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
            });
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for(var i = 0; i < wordPairs.length; i++){
                var item = wordPairs[i];
                for(var j = 0; j <= 1; j++){
                    var negate = +!j;
                    var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item[j]) + ")\\s?$", "i"));
                    if (firstCondition) {
                        var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                        if (secondCondition) {
                            reg = currentState.replace(new RegExp(lang.escapeRegExp(item[j]), "i"), function(result) {
                                var res = item[negate];
                                if (result.toUpperCase() == result) res = res.toUpperCase();
                                else if (result.charAt(0).toUpperCase() == result.charAt(0)) res = res.substr(0, 0) + item[negate].charAt(0).toUpperCase() + res.substr(1);
                                return res;
                            });
                            this.insert(reg);
                            reg = "";
                        }
                    }
                }
            }
        };
        Editor.prototype.findLinkAt = function(row, column) {
            var e_1, _a;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0) columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match;
            try {
                for(var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()){
                    var item = wordParts_1_1.value;
                    currentPosition = previousPosition + item.length;
                    if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                        if (item.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                            match = item.replace(/[\s:.,'";}\]]+$/, "");
                            break;
                        }
                    }
                    previousPosition = currentPosition;
                }
            } catch (e_1_1) {
                e_1 = {
                    error: e_1_1
                };
            } finally{
                try {
                    if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
                } finally{
                    if (e_1) throw e_1.error;
                }
            }
            return match;
        };
        Editor.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url) window.open(url, "_blank");
            return url != null;
        };
        Editor.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
        };
        Editor.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
                var row = range.start.row;
                doc.duplicateLines(row, row);
            } else {
                var point = reverse ? range.start : range.end;
                var endPoint = doc.insert(point, doc.getTextRange(range));
                range.start = point;
                range.end = endPoint;
                sel.setSelectionRange(range, reverse);
            }
        };
        Editor.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
        };
        Editor.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
        };
        Editor.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
        };
        Editor.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
        };
        Editor.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
        };
        Editor.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
                var range = selection.toOrientedRange();
                rows = this.$getSelectedRows(range);
                moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
                if (copy && dir == -1) moved = 0;
                range.moveBy(moved, 0);
                selection.fromOrientedRange(range);
            } else {
                var ranges = selection.rangeList.ranges;
                selection.rangeList.detach(this.session);
                this.inVirtualSelectionMode = true;
                var diff = 0;
                var totalDiff = 0;
                var l = ranges.length;
                for(var i = 0; i < l; i++){
                    var rangeIndex = i;
                    ranges[i].moveBy(diff, 0);
                    rows = this.$getSelectedRows(ranges[i]);
                    var first = rows.first;
                    var last = rows.last;
                    while(++i < l){
                        if (totalDiff) ranges[i].moveBy(totalDiff, 0);
                        var subRows = this.$getSelectedRows(ranges[i]);
                        if (copy && subRows.first != last) break;
                        else if (!copy && subRows.first > last + 1) break;
                        last = subRows.last;
                    }
                    i--;
                    diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                    if (copy && dir == -1) rangeIndex = i + 1;
                    while(rangeIndex <= i){
                        ranges[rangeIndex].moveBy(diff, 0);
                        rangeIndex++;
                    }
                    if (!copy) diff = 0;
                    totalDiff += diff;
                }
                selection.fromOrientedRange(selection.ranges[0]);
                selection.rangeList.attach(this.session);
                this.inVirtualSelectionMode = false;
            }
        };
        Editor.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
                first: this.session.getRowFoldStart(range.start.row),
                last: this.session.getRowFoldEnd(range.end.row)
            };
        };
        Editor.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
        };
        Editor.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
        };
        Editor.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
        };
        Editor.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
        };
        Editor.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
        };
        Editor.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
        };
        Editor.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
        };
        Editor.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        };
        Editor.prototype.$moveByPage = function(dir, select) {
            var renderer = this.renderer;
            var config = this.renderer.layerConfig;
            var rows = dir * Math.floor(config.height / config.lineHeight);
            if (select === true) this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
            });
            else if (select === false) {
                this.selection.moveCursorBy(rows, 0);
                this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config.lineHeight);
            if (select != null) renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
        };
        Editor.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
        };
        Editor.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
        };
        Editor.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
        };
        Editor.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
        };
        Editor.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
        };
        Editor.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
        };
        Editor.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
        };
        Editor.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
        };
        Editor.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
                row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
                column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
        };
        Editor.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
        };
        Editor.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
        };
        Editor.prototype.getSelectionRange = function() {
            return this.selection.getRange();
        };
        Editor.prototype.selectAll = function() {
            this.selection.selectAll();
        };
        Editor.prototype.clearSelection = function() {
            this.selection.clearSelection();
        };
        Editor.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
        };
        Editor.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
        };
        Editor.prototype.jumpToMatching = function(select, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) prevToken = iterator.stepBackward();
            var token = prevToken || iterator.stepForward();
            if (!token) return;
            var matchType;
            var found = false;
            var depth = {};
            var i = cursor.column - token.start;
            var bracketType;
            var brackets = {
                ")": "(",
                "(": "(",
                "]": "[",
                "[": "[",
                "{": "{",
                "}": "{"
            };
            do {
                if (token.value.match(/[{}()\[\]]/g)) for(; i < token.value.length && !found; i++){
                    if (!brackets[token.value[i]]) continue;
                    bracketType = brackets[token.value[i]] + "." + token.type.replace("rparen", "lparen");
                    if (isNaN(depth[bracketType])) depth[bracketType] = 0;
                    switch(token.value[i]){
                        case "(":
                        case "[":
                        case "{":
                            depth[bracketType]++;
                            break;
                        case ")":
                        case "]":
                        case "}":
                            depth[bracketType]--;
                            if (depth[bracketType] === -1) {
                                matchType = "bracket";
                                found = true;
                            }
                            break;
                    }
                }
                else if (token.type.indexOf("tag-name") !== -1) {
                    if (isNaN(depth[token.value])) depth[token.value] = 0;
                    if (prevToken.value === "<" && tokenCount > 1) depth[token.value]++;
                    else if (prevToken.value === "</") depth[token.value]--;
                    if (depth[token.value] === -1) {
                        matchType = "tag";
                        found = true;
                    }
                }
                if (!found) {
                    prevToken = token;
                    tokenCount++;
                    token = iterator.stepForward();
                    i = 0;
                }
            }while (token && !found);
            if (!matchType) return;
            var range, pos;
            if (matchType === "bracket") {
                range = this.session.getBracketRange(cursor);
                if (!range) {
                    range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i - 1);
                    pos = range.start;
                    if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2) range = this.session.getBracketRange(pos);
                }
            } else if (matchType === "tag") {
                if (!token || token.type.indexOf("tag-name") === -1) return;
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
                if (range.compare(cursor.row, cursor.column) === 0) {
                    var tagsRanges = this.session.getMatchingTags(cursor);
                    if (tagsRanges) {
                        if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                            range = tagsRanges.closeTag;
                            pos = range.start;
                        } else {
                            range = tagsRanges.openTag;
                            if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column) pos = range.end;
                            else pos = range.start;
                        }
                    }
                }
                pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
                if (select) {
                    if (range && expand) this.selection.setRange(range);
                    else if (range && range.isEqual(this.getSelectionRange())) this.clearSelection();
                    else this.selection.selectTo(pos.row, pos.column);
                } else this.selection.moveTo(pos.row, pos.column);
            }
        };
        Editor.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({
                row: lineNumber - 1,
                column: column || 0
            });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1)) this.scrollToLine(lineNumber - 1, true, animate);
        };
        Editor.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
        };
        Editor.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
                var selectionStart = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
        };
        Editor.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
                var selectionEnd = this.selection.anchor.getPosition();
                return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
        };
        Editor.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionStart = this.getSelectionRange().start;
                this.moveCursorToPosition(selectionStart);
            } else {
                times = times || 1;
                while(times--)this.selection.moveCursorLeft();
            }
            this.clearSelection();
        };
        Editor.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
                var selectionEnd = this.getSelectionRange().end;
                this.moveCursorToPosition(selectionEnd);
            } else {
                times = times || 1;
                while(times--)this.selection.moveCursorRight();
            }
            this.clearSelection();
        };
        Editor.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
        };
        Editor.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
        };
        Editor.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
        };
        Editor.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
        };
        Editor.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
        };
        Editor.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
        };
        Editor.prototype.replace = function(replacement, options) {
            if (options) this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range) return replaced;
            if (this.$tryReplace(range, replacement)) replaced = 1;
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
        };
        Editor.prototype.replaceAll = function(replacement, options) {
            if (options) this.$search.set(options);
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length) return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for(var i = ranges.length - 1; i >= 0; --i)if (this.$tryReplace(ranges[i], replacement)) replaced++;
            this.selection.setSelectionRange(selection);
            return replaced;
        };
        Editor.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
                range.end = this.session.replace(range, replacement);
                return range;
            } else return null;
        };
        Editor.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
        };
        Editor.prototype.find = function(needle, options, animate) {
            if (!options) options = {};
            if (typeof needle == "string" || needle instanceof RegExp) options.needle = needle;
            else if (typeof needle == "object") oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
                needle = this.session.getTextRange(range) || this.$search.$options.needle;
                if (!needle) {
                    range = this.session.getWordRange(range.start.row, range.start.column);
                    needle = this.session.getTextRange(range);
                }
                this.$search.set({
                    needle: needle
                });
            }
            this.$search.set(options);
            if (!options.start) this.$search.set({
                start: range
            });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll) return newRange;
            if (newRange) {
                this.revealRange(newRange, animate);
                return newRange;
            }
            if (options.backwards) range.start = range.end;
            else range.end = range.start;
            this.selection.setRange(range);
        };
        Editor.prototype.findNext = function(options, animate) {
            this.find({
                skipCurrent: true,
                backwards: false
            }, options, animate);
        };
        Editor.prototype.findPrevious = function(options, animate) {
            this.find(options, {
                skipCurrent: true,
                backwards: true
            }, animate);
        };
        Editor.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false) this.renderer.animateScrolling(scrollTop);
        };
        Editor.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        Editor.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
        };
        Editor.prototype.destroy = function() {
            if (this.$toDestroy) {
                this.$toDestroy.forEach(function(el) {
                    el.destroy();
                });
                this.$toDestroy = null;
            }
            if (this.$mouseHandler) this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session) this.session.destroy();
            if (this._$emitInputEvent) this._$emitInputEvent.cancel();
            this.removeAllListeners();
        };
        Editor.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable) return;
            var rect;
            var self1 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor) this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
                shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
                if (shouldScroll) rect = self1.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
                if (shouldScroll && rect && (self1.isFocused() || self1.searchBox && self1.searchBox.isFocused())) {
                    var renderer = self1.renderer;
                    var pos = renderer.$cursorLayer.$pixelPos;
                    var config = renderer.layerConfig;
                    var top = pos.top - config.offset;
                    if (pos.top >= 0 && top + rect.top < 0) shouldScroll = true;
                    else if (pos.top < config.height && pos.top + rect.top + config.lineHeight > window.innerHeight) shouldScroll = false;
                    else shouldScroll = null;
                    if (shouldScroll != null) {
                        scrollAnchor.style.top = top + "px";
                        scrollAnchor.style.left = pos.left + "px";
                        scrollAnchor.style.height = config.lineHeight + "px";
                        scrollAnchor.scrollIntoView(shouldScroll);
                    }
                    shouldScroll = rect = null;
                }
            });
            this.setAutoScrollEditorIntoView = function(enable) {
                if (enable) return;
                delete this.setAutoScrollEditorIntoView;
                this.off("changeSelection", onChangeSelection);
                this.renderer.off("afterRender", onAfterRender);
                this.renderer.off("beforeRender", onBeforeRender);
            };
        };
        Editor.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer) return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
        };
        Editor.prototype.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("ace/ext/prompt", function(module1) {
                module1.prompt(editor, message, options, callback);
            });
        };
        return Editor;
    }();
    Editor.$uid = 0;
    Editor.prototype.curOp = null;
    Editor.prototype.prevOp = {};
    Editor.prototype.$mergeableCommands = [
        "backspace",
        "del",
        "insertstring"
    ];
    Editor.prototype.$toggleWordPairs = [
        [
            "first",
            "last"
        ],
        [
            "true",
            "false"
        ],
        [
            "yes",
            "no"
        ],
        [
            "width",
            "height"
        ],
        [
            "top",
            "bottom"
        ],
        [
            "right",
            "left"
        ],
        [
            "on",
            "off"
        ],
        [
            "x",
            "y"
        ],
        [
            "get",
            "set"
        ],
        [
            "max",
            "min"
        ],
        [
            "horizontal",
            "vertical"
        ],
        [
            "show",
            "hide"
        ],
        [
            "add",
            "remove"
        ],
        [
            "up",
            "down"
        ],
        [
            "before",
            "after"
        ],
        [
            "even",
            "odd"
        ],
        [
            "in",
            "out"
        ],
        [
            "inside",
            "outside"
        ],
        [
            "next",
            "previous"
        ],
        [
            "increase",
            "decrease"
        ],
        [
            "attach",
            "detach"
        ],
        [
            "&&",
            "||"
        ],
        [
            "==",
            "!="
        ]
    ];
    oop.implement(Editor.prototype, EventEmitter);
    config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
            set: function(style) {
                this.onSelectionChange();
                this._signal("changeSelectionStyle", {
                    data: style
                });
            },
            initialValue: "line"
        },
        highlightActiveLine: {
            set: function() {
                this.$updateHighlightActiveLine();
            },
            initialValue: true
        },
        highlightSelectedWord: {
            set: function(shouldHighlight) {
                this.$onSelectionChange();
            },
            initialValue: true
        },
        readOnly: {
            set: function(/**@type{boolean}*/ readOnly) {
                var _this = this;
                this.textInput.setReadOnly(readOnly);
                this.$resetCursorStyle();
                if (!this.$readOnlyCallback) this.$readOnlyCallback = function(e) {
                    var shouldShow = false;
                    if (e && e.type == "keydown") {
                        shouldShow = e && e.key && e.key.length == 1 && !e.ctrlKey && !e.metaKey;
                        if (!shouldShow) return;
                    } else if (e && e.type !== "exec") shouldShow = true;
                    if (shouldShow) {
                        if (!_this.hoverTooltip) _this.hoverTooltip = new HoverTooltip();
                        var domNode = dom.createElement("div");
                        domNode.textContent = nls("editor.tooltip.disable-editing", "Editing is disabled");
                        if (!_this.hoverTooltip.isOpen) _this.hoverTooltip.showForRange(_this, _this.getSelectionRange(), domNode);
                    } else if (_this.hoverTooltip && _this.hoverTooltip.isOpen) _this.hoverTooltip.hide();
                };
                var textArea = this.textInput.getElement();
                if (readOnly) {
                    event.addListener(textArea, "keydown", this.$readOnlyCallback, this);
                    this.commands.on("exec", this.$readOnlyCallback);
                    this.commands.on("commandUnavailable", this.$readOnlyCallback);
                } else {
                    event.removeListener(textArea, "keydown", this.$readOnlyCallback);
                    this.commands.off("exec", this.$readOnlyCallback);
                    this.commands.off("commandUnavailable", this.$readOnlyCallback);
                    if (this.hoverTooltip) {
                        this.hoverTooltip.destroy();
                        this.hoverTooltip = null;
                    }
                }
            },
            initialValue: false
        },
        copyWithEmptySelection: {
            set: function(value) {
                this.textInput.setCopyWithEmptySelection(value);
            },
            initialValue: false
        },
        cursorStyle: {
            set: function(val) {
                this.$resetCursorStyle();
            },
            values: [
                "ace",
                "slim",
                "smooth",
                "wide"
            ],
            initialValue: "ace"
        },
        mergeUndoDeltas: {
            values: [
                false,
                true,
                "always"
            ],
            initialValue: true
        },
        behavioursEnabled: {
            initialValue: true
        },
        wrapBehavioursEnabled: {
            initialValue: true
        },
        enableAutoIndent: {
            initialValue: true
        },
        autoScrollEditorIntoView: {
            set: function(val) {
                this.setAutoScrollEditorIntoView(val);
            }
        },
        keyboardHandler: {
            set: function(val) {
                this.setKeyboardHandler(val);
            },
            get: function() {
                return this.$keybindingId;
            },
            handlesSet: true
        },
        value: {
            set: function(val) {
                this.session.setValue(val);
            },
            get: function() {
                return this.getValue();
            },
            handlesSet: true,
            hidden: true
        },
        session: {
            set: function(val) {
                this.setSession(val);
            },
            get: function() {
                return this.session;
            },
            handlesSet: true,
            hidden: true
        },
        showLineNumbers: {
            set: function(show) {
                this.renderer.$gutterLayer.setShowLineNumbers(show);
                this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
                if (show && this.$relativeLineNumbers) relativeNumberRenderer.attach(this);
                else relativeNumberRenderer.detach(this);
            },
            initialValue: true
        },
        relativeLineNumbers: {
            set: function(value) {
                if (this.$showLineNumbers && value) relativeNumberRenderer.attach(this);
                else relativeNumberRenderer.detach(this);
            }
        },
        placeholder: {
            set: function(message) {
                if (!this.$updatePlaceholder) {
                    this.$updatePlaceholder = (function() {
                        var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                        if (hasValue && this.renderer.placeholderNode) {
                            this.renderer.off("afterRender", this.$updatePlaceholder);
                            dom.removeCssClass(this.container, "ace_hasPlaceholder");
                            this.renderer.placeholderNode.remove();
                            this.renderer.placeholderNode = null;
                        } else if (!hasValue && !this.renderer.placeholderNode) {
                            this.renderer.on("afterRender", this.$updatePlaceholder);
                            dom.addCssClass(this.container, "ace_hasPlaceholder");
                            var el = dom.createElement("div");
                            el.className = "ace_placeholder";
                            el.textContent = this.$placeholder || "";
                            this.renderer.placeholderNode = el;
                            this.renderer.content.appendChild(this.renderer.placeholderNode);
                        } else if (!hasValue && this.renderer.placeholderNode) this.renderer.placeholderNode.textContent = this.$placeholder || "";
                    }).bind(this);
                    this.on("input", this.$updatePlaceholder);
                }
                this.$updatePlaceholder();
            }
        },
        enableKeyboardAccessibility: {
            set: function(value) {
                var blurCommand = {
                    name: "blurTextInput",
                    description: "Set focus to the editor content div to allow tabbing through the page",
                    bindKey: "Esc",
                    exec: function(editor) {
                        editor.blur();
                        editor.renderer.scroller.focus();
                    },
                    readOnly: true
                };
                var focusOnEnterKeyup = function(e) {
                    if (e.target == this.renderer.scroller && e.keyCode === keys["enter"]) {
                        e.preventDefault();
                        var row = this.getCursorPosition().row;
                        if (!this.isRowVisible(row)) this.scrollToLine(row, true, true);
                        this.focus();
                    }
                };
                var gutterKeyboardHandler;
                if (value) {
                    this.renderer.enableKeyboardAccessibility = true;
                    this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
                    this.textInput.getElement().setAttribute("tabindex", -1);
                    this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
                    this.renderer.scroller.setAttribute("tabindex", 0);
                    this.renderer.scroller.setAttribute("role", "group");
                    this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
                    this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
                    this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
                    this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
                    this.commands.addCommand(blurCommand);
                    this.renderer.$gutter.setAttribute("tabindex", 0);
                    this.renderer.$gutter.setAttribute("aria-hidden", false);
                    this.renderer.$gutter.setAttribute("role", "group");
                    this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
                    this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
                    this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
                    this.renderer.content.setAttribute("aria-hidden", true);
                    if (!gutterKeyboardHandler) gutterKeyboardHandler = new GutterKeyboardHandler(this);
                    gutterKeyboardHandler.addListener();
                    this.textInput.setAriaOptions({
                        setLabel: true
                    });
                } else {
                    this.renderer.enableKeyboardAccessibility = false;
                    this.textInput.getElement().setAttribute("tabindex", 0);
                    this.textInput.setNumberOfExtraLines(0);
                    this.renderer.scroller.setAttribute("tabindex", -1);
                    this.renderer.scroller.removeAttribute("role");
                    this.renderer.scroller.removeAttribute("aria-roledescription");
                    this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
                    this.renderer.scroller.removeAttribute("aria-label");
                    this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
                    this.commands.removeCommand(blurCommand);
                    this.renderer.content.removeAttribute("aria-hidden");
                    this.renderer.$gutter.setAttribute("tabindex", -1);
                    this.renderer.$gutter.setAttribute("aria-hidden", true);
                    this.renderer.$gutter.removeAttribute("role");
                    this.renderer.$gutter.removeAttribute("aria-roledescription");
                    this.renderer.$gutter.removeAttribute("aria-label");
                    this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
                    if (gutterKeyboardHandler) gutterKeyboardHandler.removeListener();
                }
            },
            initialValue: false
        },
        textInputAriaLabel: {
            set: function(val) {
                this.$textInputAriaLabel = val;
            },
            initialValue: ""
        },
        enableMobileMenu: {
            set: function(val) {
                this.$enableMobileMenu = val;
            },
            initialValue: true
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
    });
    var relativeNumberRenderer = {
        getText: function(/**@type{EditSession}*/ session, /**@type{number}*/ row) {
            return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "\xb7" : "")) + "";
        },
        getWidth: function(session, /**@type{number}*/ lastLineNumber, config) {
            return Math.max(lastLineNumber.toString().length, (config.lastRow + 1).toString().length, 2) * config.characterWidth;
        },
        update: function(e, /**@type{Editor}*/ editor) {
            editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(/**@type{Editor}*/ editor) {
            editor.renderer.$gutterLayer.$renderer = this;
            editor.on("changeSelection", this.update);
            this.update(null, editor);
        },
        detach: function(/**@type{Editor}*/ editor) {
            if (editor.renderer.$gutterLayer.$renderer == this) editor.renderer.$gutterLayer.$renderer = null;
            editor.off("changeSelection", this.update);
            this.update(null, editor);
        }
    };
    exports.Editor = Editor;
});
ace.define("ace/layer/lines", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var Lines = /** @class */ function() {
        function Lines(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 500000;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
        }
        Lines.prototype.moveContainer = function(config) {
            dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
        };
        Lines.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
        };
        Lines.prototype.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
        };
        Lines.prototype.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
        };
        Lines.prototype.getLength = function() {
            return this.cells.length;
        };
        Lines.prototype.get = function(index) {
            return this.cells[index];
        };
        Lines.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
        };
        Lines.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
        };
        Lines.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.push.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for(var i = 0; i < cell.length; i++)fragment.appendChild(cell[i].element);
                this.element.appendChild(fragment);
            } else {
                this.cells.push(cell);
                this.element.appendChild(cell.element);
            }
        };
        Lines.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
                this.cells.unshift.apply(this.cells, cell);
                var fragment = dom.createFragment(this.element);
                for(var i = 0; i < cell.length; i++)fragment.appendChild(cell[i].element);
                if (this.element.firstChild) this.element.insertBefore(fragment, this.element.firstChild);
                else this.element.appendChild(fragment);
            } else {
                this.cells.unshift(cell);
                this.element.insertAdjacentElement("afterbegin", cell.element);
            }
        };
        Lines.prototype.last = function() {
            if (this.cells.length) return this.cells[this.cells.length - 1];
            else return null;
        };
        Lines.prototype.$cacheCell = function(cell) {
            if (!cell) return;
            cell.element.remove();
            this.cellCache.push(cell);
        };
        Lines.prototype.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
                var element = dom.createElement("div");
                if (initElement) initElement(element);
                this.element.appendChild(element);
                cell = {
                    element: element,
                    text: "",
                    row: row
                };
            }
            cell.row = row;
            return cell;
        };
        return Lines;
    }();
    exports.Lines = Lines;
});
ace.define("ace/layer/gutter", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/oop",
    "ace/lib/lang",
    "ace/lib/event_emitter",
    "ace/layer/lines",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var lang = require("../lib/lang");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var Lines = require("./lines").Lines;
    var nls = require("../config").nls;
    var Gutter = /** @class */ function() {
        function Gutter(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
        }
        Gutter.prototype.setSession = function(session) {
            if (this.session) this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session) session.on("change", this.$updateAnnotations);
        };
        Gutter.prototype.addGutterDecoration = function(row, className) {
            if (window.console) console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
        };
        Gutter.prototype.removeGutterDecoration = function(row, className) {
            if (window.console) console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
        };
        Gutter.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for(var i = 0; i < annotations.length; i++){
                var annotation = annotations[i];
                var row = annotation.row;
                var rowInfo = this.$annotations[row];
                if (!rowInfo) rowInfo = this.$annotations[row] = {
                    text: [],
                    type: [],
                    displayText: []
                };
                var annoText = annotation.text;
                var displayAnnoText = annotation.text;
                var annoType = annotation.type;
                annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
                displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
                if (rowInfo.text.indexOf(annoText) === -1) {
                    rowInfo.text.push(annoText);
                    rowInfo.type.push(annoType);
                    rowInfo.displayText.push(displayAnnoText);
                }
                var className = annotation.className;
                if (className) rowInfo.className = className;
                else if (annoType === "error") rowInfo.className = " ace_error";
                else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) rowInfo.className = " ace_security";
                else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) rowInfo.className = " ace_warning";
                else if (annoType === "info" && !rowInfo.className) rowInfo.className = " ace_info";
                else if (annoType === "hint" && !rowInfo.className) rowInfo.className = " ace_hint";
            }
        };
        Gutter.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length) return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) ;
            else if (delta.action == "remove") this.$annotations.splice(firstRow, len + 1, null);
            else {
                var args = new Array(len + 1);
                args.unshift(firstRow, 1);
                this.$annotations.splice.apply(this.$annotations, args);
            }
        };
        Gutter.prototype.update = function(config) {
            this.config = config;
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(config.lastRow + config.gutterOffset, session.getLength() - 1);
            this.oldLastRow = lastRow;
            this.config = config;
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while(true){
                if (row > foldStart) {
                    row = fold.end.row + 1;
                    fold = session.getNextFoldLine(row, fold);
                    foldStart = fold ? fold.start.row : Infinity;
                }
                if (row > lastRow) {
                    while(this.$lines.getLength() > index + 1)this.$lines.pop();
                    break;
                }
                cell = this.$lines.get(++index);
                if (cell) cell.row = row;
                else {
                    cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                    this.$lines.push(cell);
                }
                this.$renderCell(cell, config, fold, row);
                row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };
        Gutter.prototype.$updateGutterWidth = function(config) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode) lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
                this.gutterWidth = gutterWidth;
                this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
                this._signal("changeGutterWidth", gutterWidth);
            }
        };
        Gutter.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine) return;
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row) return;
            this.$cursorRow = position.row;
        };
        Gutter.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine) return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row) return;
            if (this.$cursorCell) this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for(var i = 0; i < cells.length; i++){
                var cell = cells[i];
                if (cell.row >= this.$cursorRow) {
                    if (cell.row > this.$cursorRow) {
                        var fold = this.session.getFoldLine(this.$cursorRow);
                        if (i > 0 && fold && fold.start.row == cells[i - 1].row) cell = cells[i - 1];
                        else break;
                    }
                    cell.element.className = "ace_gutter-active-line " + cell.element.className;
                    this.$cursorCell = cell;
                    break;
                }
            }
        };
        Gutter.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config)) return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = Math.min(config.lastRow + config.gutterOffset, this.session.getLength() - 1);
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config.firstRow) return this.update(config);
            if (lastRow < oldConfig.firstRow) return this.update(config);
            if (oldConfig.firstRow < config.firstRow) for(var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)this.$lines.shift();
            if (oldLastRow > lastRow) for(var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            if (lastRow > oldLastRow) this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config);
        };
        Gutter.prototype.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while(true){
                if (row > foldStart) {
                    row = foldLine.end.row + 1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow) break;
                var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$renderCell(cell, config, foldLine, row);
                fragment.push(cell);
                row++;
            }
            return fragment;
        };
        Gutter.prototype.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var customWidget = element.childNodes[3];
            var annotationIconNode = annotationNode.firstChild;
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            var lineHeight = config.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (this.$highlightGutterLine) {
                if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                    className += "ace_gutter-active-line ";
                    if (this.$cursorCell != cell) {
                        if (this.$cursorCell) this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                        this.$cursorCell = cell;
                    }
                }
            }
            if (breakpoints[row]) className += breakpoints[row];
            if (decorations[row]) className += decorations[row];
            if (this.$annotations[row] && row !== foldStart) className += this.$annotations[row].className;
            if (foldWidgets) {
                var c = foldWidgets[row];
                if (c == null) c = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c) {
                var foldClass = "ace_fold-widget ace_" + c;
                var isClosedFold = c == "start" && row == foldStart && row < fold.end.row;
                if (isClosedFold) {
                    foldClass += " ace_closed";
                    var foldAnnotationClass = "";
                    var annotationInFold = false;
                    for(var i = row + 1; i <= fold.end.row; i++){
                        if (!this.$annotations[i]) continue;
                        if (this.$annotations[i].className === " ace_error") {
                            annotationInFold = true;
                            foldAnnotationClass = " ace_error_fold";
                            break;
                        }
                        if (this.$annotations[i].className === " ace_security") {
                            annotationInFold = true;
                            foldAnnotationClass = " ace_security_fold";
                        } else if (this.$annotations[i].className === " ace_warning" && foldAnnotationClass !== " ace_security_fold") {
                            annotationInFold = true;
                            foldAnnotationClass = " ace_warning_fold";
                        }
                    }
                    className += foldAnnotationClass;
                } else foldClass += " ace_open";
                if (foldWidget.className != foldClass) foldWidget.className = foldClass;
                dom.setStyle(foldWidget.style, "height", lineHeight);
                dom.setStyle(foldWidget.style, "display", "inline-block");
                foldWidget.setAttribute("role", "button");
                foldWidget.setAttribute("tabindex", "-1");
                var foldRange = session.getFoldWidgetRange(row);
                if (foldRange) foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                    foldRange.start.row + 1,
                    foldRange.end.row + 1
                ]));
                else if (fold) foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                    fold.start.row + 1,
                    fold.end.row + 1
                ]));
                else foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [
                    row + 1
                ]));
                if (isClosedFold) {
                    foldWidget.setAttribute("aria-expanded", "false");
                    foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
                } else {
                    foldWidget.setAttribute("aria-expanded", "true");
                    foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
                }
            } else if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
            }
            var customWidgetAttributes = this.session.$gutterCustomWidgets[row];
            if (customWidgetAttributes) this.$addCustomWidget(row, customWidgetAttributes, cell);
            else if (customWidget) this.$removeCustomWidget(row, cell);
            if (annotationInFold && this.$showFoldedAnnotations) {
                annotationNode.className = "ace_gutter_annotation";
                annotationIconNode.className = iconClassName;
                annotationIconNode.className += foldAnnotationClass;
                dom.setStyle(annotationIconNode.style, "height", lineHeight);
                dom.setStyle(annotationNode.style, "display", "block");
                dom.setStyle(annotationNode.style, "height", lineHeight);
                var ariaLabel;
                switch(foldAnnotationClass){
                    case " ace_error_fold":
                        ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_security_fold":
                        ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_warning_fold":
                        ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [
                            rowText
                        ]);
                        break;
                }
                annotationNode.setAttribute("aria-label", ariaLabel);
                annotationNode.setAttribute("tabindex", "-1");
                annotationNode.setAttribute("role", "button");
            } else if (this.$annotations[row]) {
                annotationNode.className = "ace_gutter_annotation";
                annotationIconNode.className = iconClassName;
                if (this.$useSvgGutterIcons) annotationIconNode.className += this.$annotations[row].className;
                else element.classList.add(this.$annotations[row].className.replace(" ", ""));
                dom.setStyle(annotationIconNode.style, "height", lineHeight);
                dom.setStyle(annotationNode.style, "display", "block");
                dom.setStyle(annotationNode.style, "height", lineHeight);
                var ariaLabel;
                switch(this.$annotations[row].className){
                    case " ace_error":
                        ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_security":
                        ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_warning":
                        ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_info":
                        ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [
                            rowText
                        ]);
                        break;
                    case " ace_hint":
                        ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [
                            rowText
                        ]);
                        break;
                }
                annotationNode.setAttribute("aria-label", ariaLabel);
                annotationNode.setAttribute("tabindex", "-1");
                annotationNode.setAttribute("role", "button");
            } else {
                dom.setStyle(annotationNode.style, "display", "none");
                annotationNode.removeAttribute("aria-label");
                annotationNode.removeAttribute("role");
                annotationNode.setAttribute("tabindex", "0");
            }
            if (rowText !== textNode.data) textNode.data = rowText;
            if (element.className != className) element.className = className;
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            cell.text = rowText;
            if (annotationNode.style.display === "none" && foldWidget.style.display === "none" && !customWidgetAttributes) cell.element.setAttribute("aria-hidden", true);
            else cell.element.setAttribute("aria-hidden", false);
            return cell;
        };
        Gutter.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
        };
        Gutter.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
                getWidth: function() {
                    return 0;
                },
                getText: function() {
                    return "";
                }
            };
        };
        Gutter.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
        };
        Gutter.prototype.setShowFoldWidgets = function(show) {
            if (show) dom.addCssClass(this.element, "ace_folding-enabled");
            else dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
        };
        Gutter.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
        };
        Gutter.prototype.$hideFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
                var foldWidget = rowCell.element.childNodes[1];
                if (foldWidget) dom.setStyle(foldWidget.style, "display", "none");
            }
        };
        Gutter.prototype.$showFoldWidget = function(row, cell) {
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
                var foldWidget = rowCell.element.childNodes[1];
                if (foldWidget && this.session.foldWidgets && this.session.foldWidgets[rowCell.row]) dom.setStyle(foldWidget.style, "display", "inline-block");
            }
        };
        Gutter.prototype.$getGutterCell = function(row) {
            var cells = this.$lines.cells;
            var visibileRow = this.session.documentToScreenRow(row, 0);
            return cells[row - this.config.firstRowScreen - (row - visibileRow)];
        };
        Gutter.prototype.$addCustomWidget = function(row, _a, cell) {
            var className = _a.className, label = _a.label, title = _a.title, callbacks = _a.callbacks;
            this.session.$gutterCustomWidgets[row] = {
                className: className,
                label: label,
                title: title,
                callbacks: callbacks
            };
            this.$hideFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
                var customWidget = rowCell.element.querySelector(".ace_custom-widget");
                if (customWidget) customWidget.remove();
                customWidget = dom.createElement("span");
                customWidget.className = "ace_custom-widget ".concat(className);
                customWidget.setAttribute("tabindex", "-1");
                customWidget.setAttribute("role", "button");
                customWidget.setAttribute("aria-label", label);
                customWidget.setAttribute("title", title);
                dom.setStyle(customWidget.style, "display", "inline-block");
                dom.setStyle(customWidget.style, "height", "inherit");
                if (callbacks && callbacks.onClick) customWidget.addEventListener("click", function(e) {
                    callbacks.onClick(e, row);
                    e.stopPropagation();
                });
                rowCell.element.appendChild(customWidget);
            }
        };
        Gutter.prototype.$removeCustomWidget = function(row, cell) {
            delete this.session.$gutterCustomWidgets[row];
            this.$showFoldWidget(row, cell);
            var rowCell = cell || this.$getGutterCell(row);
            if (rowCell && rowCell.element) {
                var customWidget = rowCell.element.querySelector(".ace_custom-widget");
                if (customWidget) rowCell.element.removeChild(customWidget);
            }
        };
        Gutter.prototype.$computePadding = function() {
            if (!this.element.firstChild) return {
                left: 0,
                right: 0
            };
            var style = dom.computedStyle(/**@type{Element}*/ this.element.firstChild);
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
        };
        Gutter.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left) return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right) return "foldWidgets";
        };
        return Gutter;
    }();
    Gutter.prototype.$fixedWidth = false;
    Gutter.prototype.$highlightGutterLine = true;
    Gutter.prototype.$renderer = "";
    Gutter.prototype.$showLineNumbers = true;
    Gutter.prototype.$showFoldWidgets = true;
    oop.implement(Gutter.prototype, EventEmitter);
    function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        var annotationIconNode = dom.createElement("span");
        annotationNode.appendChild(annotationIconNode);
        return element;
    }
    exports.Gutter = Gutter;
});
ace.define("ace/layer/marker", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var Range = require("../range").Range;
    var dom = require("../lib/dom");
    var Marker = /** @class */ function() {
        function Marker(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
        }
        Marker.prototype.setPadding = function(padding) {
            this.$padding = padding;
        };
        Marker.prototype.setSession = function(session) {
            this.session = session;
        };
        Marker.prototype.setMarkers = function(markers) {
            this.markers = markers;
        };
        Marker.prototype.elt = function(className, css) {
            var x = this.i != -1 && this.element.childNodes[this.i];
            if (!x) {
                x = document.createElement("div");
                this.element.appendChild(x);
                this.i = -1;
            } else this.i++;
            x.style.cssText = css;
            x.className = className;
        };
        Marker.prototype.update = function(config) {
            if (!config) return;
            this.config = config;
            this.i = 0;
            var html;
            for(var key in this.markers){
                var marker = this.markers[key];
                if (!marker.range) {
                    marker.update(html, this, this.session, config);
                    continue;
                }
                var range = marker.range.clipRows(config.firstRow, config.lastRow);
                if (range.isEmpty()) continue;
                range = range.toScreenRange(this.session);
                if (marker.renderer) {
                    var top = this.$getTop(range.start.row, config);
                    var left = this.$padding + range.start.column * config.characterWidth;
                    marker.renderer(html, range, left, top, config);
                } else if (marker.type == "fullLine") this.drawFullLineMarker(html, range, marker.clazz, config);
                else if (marker.type == "screenLine") this.drawScreenLineMarker(html, range, marker.clazz, config);
                else if (range.isMultiLine()) {
                    if (marker.type == "text") this.drawTextMarker(html, range, marker.clazz, config);
                    else this.drawMultiLineMarker(html, range, marker.clazz, config);
                } else this.drawSingleLineMarker(html, range, marker.clazz + " ace_start" + " ace_br15", config);
            }
            if (this.i != -1) while(this.i < this.element.childElementCount)this.element.removeChild(this.element.lastChild);
        };
        Marker.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
        };
        Marker.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for(; row <= end; row++){
                lineRange.start.row = lineRange.end.row = row;
                lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
                lineRange.end.column = next;
                prev = curr;
                curr = next;
                next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
                this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
        };
        Marker.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
                var range1 = range.clone();
                range1.end.row = range1.start.row;
                range1.end.column = this.session.getLine(range1.start.row).length;
                this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;" + "right:" + padding + "px;" + "top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
                var range1 = range.clone();
                range1.start.row = range1.end.row;
                range1.start.column = 0;
                this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
                top = this.$getTop(range.end.row, config);
                var width = range.end.column * config.characterWidth;
                this.elt(clazz + " ace_br12", "height:" + height + "px;" + "width:" + width + "px;" + "top:" + top + "px;" + "left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0) return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;" + "right:" + padding + "px;" + "top:" + top + "px;" + "left:" + padding + "px;" + (extraStyle || ""));
        };
        Marker.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            this.elt(clazz, "height:" + height + "px;" + "width:" + width + "px;" + "top:" + top + "px;" + "left:" + left + "px;" + (extraStyle || ""));
        };
        Marker.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
                this.elt(clazz, "height:" + height + "px;" + "width:" + (selection.width + (extraLength || 0)) + "px;" + "top:" + top + "px;" + "left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
        };
        Marker.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row) height += this.$getTop(range.end.row, config) - top;
            this.elt(clazz, "height:" + height + "px;" + "top:" + top + "px;" + "left:0;right:0;" + (extraStyle || ""));
        };
        Marker.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            this.elt(clazz, "height:" + height + "px;" + "top:" + top + "px;" + "left:0;right:0;" + (extraStyle || ""));
        };
        return Marker;
    }();
    Marker.prototype.$padding = 0;
    function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
    }
    exports.Marker = Marker;
});
ace.define("ace/layer/text_util", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    var textTokens = new Set([
        "text",
        "rparen",
        "lparen"
    ]);
    exports.isTextToken = function(tokenType) {
        return textTokens.has(tokenType);
    };
});
ace.define("ace/layer/text", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/layer/lines",
    "ace/lib/event_emitter",
    "ace/config",
    "ace/layer/text_util"
], function(require, exports, module1) {
    "use strict";
    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var Lines = require("./lines").Lines;
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var nls = require("../config").nls;
    var isTextToken = require("./text_util").isTextToken;
    var Text = /** @class */ function() {
        function Text(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
        }
        Text.prototype.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
                this.EOL_CHAR = EOL_CHAR;
                return true;
            }
        };
        Text.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
        };
        Text.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
        };
        Text.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
        };
        Text.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on("changeCharacterSize", (function(e) {
                this._signal("changeCharacterSize", e);
            }).bind(this));
            this.$pollSizeChanges();
        };
        Text.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
        };
        Text.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        };
        Text.prototype.setSession = function(session) {
            this.session = session;
            if (session) this.$computeTabString();
        };
        Text.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles) return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
                this.showSpaces = /tab/i.test(showInvisibles);
                this.showTabs = /space/i.test(showInvisibles);
                this.showEOL = /eol/i.test(showInvisibles);
            } else this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            this.$computeTabString();
            return true;
        };
        Text.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display) return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
        };
        Text.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight) return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
        };
        Text.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [
                0
            ];
            for(var i = 1; i < tabSize + 1; i++)if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i);
                tabStr.push(span);
            } else tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i), this.element));
            if (this.displayIndentGuides) {
                this.$indentGuideRe = /\s\S| \t|\t |\s$/;
                var className = "ace_indent-guide";
                var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
                var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
                var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
                var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
                var span = this.dom.createElement("span");
                span.className = className + spaceClass;
                span.textContent = spaceContent;
                this.$tabStrings[" "] = span;
                var span = this.dom.createElement("span");
                span.className = className + tabClass;
                span.textContent = tabContent;
                this.$tabStrings["	"] = span;
            }
        };
        Text.prototype.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) return this.update(config);
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for(var row = config.firstRow; row < first; row++){
                var foldLine = this.session.getFoldLine(row);
                if (foldLine) {
                    if (foldLine.containsRow(first)) {
                        first = foldLine.start.row;
                        break;
                    } else row = foldLine.end.row;
                }
                lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while(true){
                if (row > foldStart) {
                    row = foldLine.end.row + 1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > last) break;
                var lineElement = lineElements[lineElementsIdx++];
                if (lineElement) {
                    this.dom.removeChildren(lineElement);
                    this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                    if (heightChanged) lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                    var height = config.lineHeight * this.session.getRowLength(row) + "px";
                    if (lineElement.style.height != height) {
                        heightChanged = true;
                        lineElement.style.height = height;
                    }
                }
                row++;
            }
            if (heightChanged) while(lineElementsIdx < this.$lines.cells.length){
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
            }
        };
        Text.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (this.$lines.pageChanged(oldConfig, config)) return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config.firstRow) return this.update(config);
            if (lastRow < oldConfig.firstRow) return this.update(config);
            if (!oldConfig || oldConfig.lastRow < config.firstRow) return this.update(config);
            if (config.lastRow < oldConfig.firstRow) return this.update(config);
            if (oldConfig.firstRow < config.firstRow) for(var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)this.$lines.shift();
            if (oldConfig.lastRow > config.lastRow) for(var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            if (config.lastRow > oldConfig.lastRow) this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            this.$highlightIndentGuide();
        };
        Text.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while(true){
                if (row > foldStart) {
                    row = foldLine.end.row + 1;
                    foldLine = this.session.getNextFoldLine(row, foldLine);
                    foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (row > lastRow) break;
                var line = this.$lines.createCell(row, config, this.session);
                var lineEl = line.element;
                this.dom.removeChildren(lineEl);
                dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
                dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
                this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
                if (this.$useLineGroups()) lineEl.className = "ace_line_group";
                else lineEl.className = "ace_line";
                fragment.push(line);
                row++;
            }
            return fragment;
        };
        Text.prototype.update = function(config) {
            this.$lines.moveContainer(config);
            this.config = config;
            var firstRow = config.firstRow;
            var lastRow = config.lastRow;
            var lines = this.$lines;
            while(lines.getLength())lines.pop();
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
        };
        Text.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self1 = this;
            var re = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m;
            var i = 0;
            while(m = re.exec(value)){
                var tab = m[1];
                var simpleSpace = m[2];
                var controlCharacter = m[3];
                var cjkSpace = m[4];
                var cjk = m[5];
                if (!self1.showSpaces && simpleSpace) continue;
                var before = i != m.index ? value.slice(i, m.index) : "";
                i = m.index + m[0].length;
                if (before) valueFragment.appendChild(this.dom.createTextNode(before, this.element));
                if (tab) {
                    var tabSize = self1.session.getScreenTabSize(screenColumn + m.index);
                    valueFragment.appendChild(self1.$tabStrings[tabSize].cloneNode(true));
                    screenColumn += tabSize - 1;
                } else if (simpleSpace) {
                    if (self1.showSpaces) {
                        var span = this.dom.createElement("span");
                        span.className = "ace_invisible ace_invisible_space";
                        span.textContent = lang.stringRepeat(self1.SPACE_CHAR, simpleSpace.length);
                        valueFragment.appendChild(span);
                    } else valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                } else if (controlCharacter) {
                    var span = this.dom.createElement("span");
                    span.className = "ace_invisible ace_invisible_space ace_invalid";
                    span.textContent = lang.stringRepeat(self1.SPACE_CHAR, controlCharacter.length);
                    valueFragment.appendChild(span);
                } else if (cjkSpace) {
                    screenColumn += 1;
                    var span = this.dom.createElement("span");
                    span.style.width = self1.config.characterWidth * 2 + "px";
                    span.className = self1.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                    span.textContent = self1.showSpaces ? self1.SPACE_CHAR : cjkSpace;
                    valueFragment.appendChild(span);
                } else if (cjk) {
                    screenColumn += 1;
                    var span = this.dom.createElement("span");
                    span.style.width = self1.config.characterWidth * 2 + "px";
                    span.className = "ace_cjk";
                    span.textContent = cjk;
                    valueFragment.appendChild(span);
                }
            }
            valueFragment.appendChild(this.dom.createTextNode(i ? value.slice(i) : value, this.element));
            if (!isTextToken(token.type)) {
                var classes = "ace_" + token.type.replace(/\./g, " ace_");
                var span = this.dom.createElement("span");
                if (token.type == "fold") {
                    span.style.width = token.value.length * this.config.characterWidth + "px";
                    span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
                }
                span.className = classes;
                span.appendChild(valueFragment);
                parent.appendChild(span);
            } else parent.appendChild(valueFragment);
            return screenColumn + value.length;
        };
        Text.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max) return value;
            if (value[0] == " ") {
                cols -= cols % this.tabSize;
                var count = cols / this.tabSize;
                for(var i = 0; i < count; i++)parent.appendChild(this.$tabStrings[" "].cloneNode(true));
                this.$highlightIndentGuide();
                return value.substr(cols);
            } else if (value[0] == "	") {
                for(var i = 0; i < cols; i++)parent.appendChild(this.$tabStrings["	"].cloneNode(true));
                this.$highlightIndentGuide();
                return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
        };
        Text.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides) return;
            this.$highlightIndentGuideMarker = {
                indentLevel: undefined,
                start: undefined,
                end: undefined,
                dir: undefined
            };
            var lines = this.session.doc.$lines;
            if (!lines) return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
                indentLevel: elementIndentLevel,
                start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
                var ranges = this.session.$bracketHighlight.ranges;
                for(var i = 0; i < ranges.length; i++)if (cursor.row !== ranges[i].start.row) {
                    this.$highlightIndentGuideMarker.end = ranges[i].start.row + 1;
                    if (cursor.row > ranges[i].start.row) this.$highlightIndentGuideMarker.dir = -1;
                    else this.$highlightIndentGuideMarker.dir = 1;
                    break;
                }
            }
            if (!this.$highlightIndentGuideMarker.end) {
                if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                    this.$highlightIndentGuideMarker.dir = 1;
                    for(var i = cursor.row + 1; i < lines.length; i++){
                        var line = lines[i];
                        var currentIndent = /^\s*/.exec(line)[0].length;
                        if (line !== "") {
                            this.$highlightIndentGuideMarker.end = i;
                            if (currentIndent <= initialIndent) break;
                        }
                    }
                }
            }
            this.$renderHighlightIndentGuide();
        };
        Text.prototype.$clearActiveIndentGuide = function() {
            var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
            for(var i = 0; i < activeIndentGuides.length; i++)activeIndentGuides[i].classList.remove("ace_indent-guide-active");
        };
        Text.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
                var element = cell.element;
                if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
                    if (cell.element.childNodes.length > 0) element = cell.element.childNodes[0];
                    else return;
                }
                var childNodes = element.childNodes;
                if (childNodes) {
                    var node = childNodes[indentLevel - 1];
                    if (node && node.classList && node.classList.contains("ace_indent-guide")) node.classList.add("ace_indent-guide-active");
                }
            }
        };
        Text.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines) return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
                if (this.$highlightIndentGuideMarker.dir === 1) for(var i = 0; i < cells.length; i++){
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                        if (cell.row >= this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
                else for(var i = cells.length - 1; i >= 0; i--){
                    var cell = cells[i];
                    if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                        if (cell.row < this.$highlightIndentGuideMarker.end) break;
                        this.$setIndentGuideActive(cell, indentLevel);
                    }
                }
            }
        };
        Text.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
        };
        Text.prototype.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                var value = token.value;
                if (i == 0 && this.displayIndentGuides) {
                    chars = value.length;
                    value = this.renderIndentGuide(lineEl, value, splitChars);
                    if (!value) continue;
                    chars -= value.length;
                }
                if (chars + value.length < splitChars) {
                    screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                    chars += value.length;
                } else {
                    while(chars + value.length >= splitChars){
                        screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                        value = value.substring(splitChars - chars);
                        chars = splitChars;
                        lineEl = this.$createLineElement();
                        parent.appendChild(lineEl);
                        lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("\xa0", splits.indent), this.element));
                        split++;
                        screenColumn = 0;
                        splitChars = splits[split] || Number.MAX_VALUE;
                    }
                    if (value.length != 0) {
                        chars += value.length;
                        screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                    }
                }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH) this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
        };
        Text.prototype.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                var value = token.value;
                if (i == 0 && this.displayIndentGuides) {
                    value = this.renderIndentGuide(parent, value);
                    if (!value) continue;
                }
                if (screenColumn + value.length > this.MAX_LINE_LENGTH) return this.$renderOverflowMessage(parent, screenColumn, token, value);
                screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
        };
        Text.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
        };
        Text.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false) foldLine = this.session.getFoldLine(row);
            if (foldLine) var tokens = this.$getFoldLineTokens(row, foldLine);
            else var tokens = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens.length) {
                var splits = this.session.getRowSplitData(row);
                if (splits && splits.length) {
                    this.$renderWrappedLine(parent, tokens, splits);
                    var lastLineEl = parent.lastChild;
                } else {
                    var lastLineEl = parent;
                    if (this.$useLineGroups()) {
                        lastLineEl = this.$createLineElement();
                        parent.appendChild(lastLineEl);
                    }
                    this.$renderSimpleLine(lastLineEl, tokens);
                }
            } else if (this.$useLineGroups()) {
                lastLineEl = this.$createLineElement();
                parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
                if (foldLine) row = foldLine.end.row;
                var invisibleEl = this.dom.createElement("span");
                invisibleEl.className = "ace_invisible ace_invisible_eol";
                invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
                lastLineEl.appendChild(invisibleEl);
            }
        };
        Text.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens, from, to) {
                var idx = 0, col = 0;
                while(col + tokens[idx].value.length < from){
                    col += tokens[idx].value.length;
                    idx++;
                    if (idx == tokens.length) return;
                }
                if (col != from) {
                    var value = tokens[idx].value.substring(from - col);
                    if (value.length > to - from) value = value.substring(0, to - from);
                    renderTokens.push({
                        type: tokens[idx].type,
                        value: value
                    });
                    col = from + value.length;
                    idx += 1;
                }
                while(col < to && idx < tokens.length){
                    var value = tokens[idx].value;
                    if (value.length + col > to) renderTokens.push({
                        type: tokens[idx].type,
                        value: value.substring(0, to - col)
                    });
                    else renderTokens.push(tokens[idx]);
                    col += value.length;
                    idx += 1;
                }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row, column, lastColumn, isNewRow) {
                if (placeholder != null) renderTokens.push({
                    type: "fold",
                    value: placeholder
                });
                else {
                    if (isNewRow) tokens = session.getTokens(row);
                    if (tokens.length) addTokens(tokens, lastColumn, column);
                }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
        };
        Text.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
        };
        return Text;
    }();
    Text.prototype.EOF_CHAR = "\xb6";
    Text.prototype.EOL_CHAR_LF = "\xac";
    Text.prototype.EOL_CHAR_CRLF = "\xa4";
    Text.prototype.EOL_CHAR = Text.prototype.EOL_CHAR_LF;
    Text.prototype.TAB_CHAR = "‚Äî"; //"\u21E5";
    Text.prototype.SPACE_CHAR = "\xb7";
    Text.prototype.$padding = 0;
    Text.prototype.MAX_LINE_LENGTH = 10000;
    Text.prototype.showInvisibles = false;
    Text.prototype.showSpaces = false;
    Text.prototype.showTabs = false;
    Text.prototype.showEOL = false;
    Text.prototype.displayIndentGuides = true;
    Text.prototype.$highlightIndentGuides = true;
    Text.prototype.$tabStrings = [];
    Text.prototype.destroy = {};
    Text.prototype.onChangeTabSize = Text.prototype.$computeTabString;
    oop.implement(Text.prototype, EventEmitter);
    exports.Text = Text;
});
ace.define("ace/layer/cursor", [
    "require",
    "exports",
    "module",
    "ace/lib/dom"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var Cursor = /** @class */ function() {
        function Cursor(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1000;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
        }
        Cursor.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for(var i = cursors.length; i--;)dom.setStyle(cursors[i].style, "opacity", val ? "" : "0");
        };
        Cursor.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for(var i = cursors.length; i--;)cursors[i].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout((function() {
                if (this.$isAnimating) dom.addCssClass(this.element, "ace_animate-blinking");
            }).bind(this));
        };
        Cursor.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
        };
        Cursor.prototype.setPadding = function(padding) {
            this.$padding = padding;
        };
        Cursor.prototype.setSession = function(session) {
            this.session = session;
        };
        Cursor.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
                this.isBlinking = blinking;
                this.restartTimer();
            }
        };
        Cursor.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
                this.blinkInterval = blinkInterval;
                this.restartTimer();
            }
        };
        Cursor.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
                this.smoothBlinking = smoothBlinking;
                dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
                this.$updateCursors(true);
                this.restartTimer();
            }
        };
        Cursor.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
        };
        Cursor.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
                var el = this.cursors.pop();
                el.parentNode.removeChild(el);
                return el;
            }
        };
        Cursor.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };
        Cursor.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
        };
        Cursor.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
                this.$isSmoothBlinking = false;
                dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
                this.$stopCssAnimation();
                return;
            }
            if (this.smoothBlinking) {
                this.$isSmoothBlinking = true;
                setTimeout((function() {
                    if (this.$isSmoothBlinking) dom.addCssClass(this.element, "ace_smooth-blinking");
                }).bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) this.$startCssAnimation();
            else {
                var blink = /**@this{Cursor}*/ (function() {
                    this.timeoutId = setTimeout(function() {
                        update(false);
                    }, 0.6 * this.blinkInterval);
                }).bind(this);
                this.intervalId = setInterval(function() {
                    update(true);
                    blink();
                }, this.blinkInterval);
                blink();
            }
        };
        Cursor.prototype.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session) return {
                left: 0,
                top: 0
            };
            if (!position) position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return {
                left: cursorLeft,
                top: cursorTop
            };
        };
        Cursor.prototype.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
        };
        Cursor.prototype.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i = 0, cursorIndex = 0;
            if (selections === undefined || selections.length === 0) selections = [
                {
                    cursor: null
                }
            ];
            for(var i = 0, n = selections.length; i < n; i++){
                var pixelPos = this.getPixelPosition(selections[i].cursor, true);
                if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i > 1) continue;
                var element = this.cursors[cursorIndex++] || this.addCursor();
                var style = element.style;
                if (!this.drawCursor) {
                    if (!this.isCursorInView(pixelPos, config)) dom.setStyle(style, "display", "none");
                    else {
                        dom.setStyle(style, "display", "block");
                        dom.translate(element, pixelPos.left, pixelPos.top);
                        dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                        dom.setStyle(style, "height", config.lineHeight + "px");
                    }
                } else this.drawCursor(element, pixelPos, config, selections[i], this.session);
            }
            while(this.cursors.length > cursorIndex)this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
        };
        Cursor.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
                this.overwrite = overwrite;
                if (overwrite) dom.addCssClass(this.element, "ace_overwrite-cursors");
                else dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
        };
        Cursor.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
        };
        return Cursor;
    }();
    Cursor.prototype.$padding = 0;
    Cursor.prototype.drawCursor = null;
    exports.Cursor = Cursor;
});
ace.define("ace/scrollbar", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var event = require("./lib/event");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var MAX_SCROLL_H = 0x8000;
    var Scrollbar = /** @class */ function() {
        function Scrollbar(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = "\xa0";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
        }
        Scrollbar.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
        };
        return Scrollbar;
    }();
    oop.implement(Scrollbar.prototype, EventEmitter);
    var VScrollBar = /** @class */ function(_super) {
        __extends(VScrollBar, _super);
        function VScrollBar(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
        }
        VScrollBar.prototype.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollTop = this.element.scrollTop;
                if (this.coeff != 1) {
                    var h = this.element.clientHeight / this.scrollHeight;
                    this.scrollTop = this.scrollTop * (1 - h) / (this.coeff - h);
                }
                this._emit("scroll", {
                    data: this.scrollTop
                });
            }
            this.skipEvent = false;
        };
        VScrollBar.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        VScrollBar.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
        };
        VScrollBar.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
                this.coeff = MAX_SCROLL_H / height;
                height = MAX_SCROLL_H;
            } else if (this.coeff != 1) this.coeff = 1;
            this.inner.style.height = height + "px";
        };
        VScrollBar.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
                this.skipEvent = true;
                this.scrollTop = scrollTop;
                this.element.scrollTop = scrollTop * this.coeff;
            }
        };
        return VScrollBar;
    }(Scrollbar);
    VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
    var HScrollBar = /** @class */ function(_super) {
        __extends(HScrollBar, _super);
        function HScrollBar(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
        }
        HScrollBar.prototype.onScroll = function() {
            if (!this.skipEvent) {
                this.scrollLeft = this.element.scrollLeft;
                this._emit("scroll", {
                    data: this.scrollLeft
                });
            }
            this.skipEvent = false;
        };
        HScrollBar.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
        };
        HScrollBar.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
        };
        HScrollBar.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        HScrollBar.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
        };
        HScrollBar.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
                this.skipEvent = true;
                this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
        };
        return HScrollBar;
    }(Scrollbar);
    exports.ScrollBar = VScrollBar; // backward compatibility
    exports.ScrollBarV = VScrollBar; // backward compatibility
    exports.ScrollBarH = HScrollBar; // backward compatibility
    exports.VScrollBar = VScrollBar;
    exports.HScrollBar = HScrollBar;
});
ace.define("ace/scrollbar_custom", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/event",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var __extends = this && this.__extends || function() {
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || ({
                __proto__: []
            }) instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        return function(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    }();
    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var event = require("./lib/event");
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
    var ScrollBar = /** @class */ function() {
        function ScrollBar(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [
                500,
                300,
                300
            ], this, "onMouseDown");
        }
        ScrollBar.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
        };
        return ScrollBar;
    }();
    oop.implement(ScrollBar.prototype, EventEmitter);
    var VScrollBar = /** @class */ function(_super) {
        __extends(VScrollBar, _super);
        function VScrollBar(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
        }
        VScrollBar.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown") return;
            if (event.getButton(e) !== 0 || e.detail === 2) return;
            if (e.target === this.inner) {
                var self1 = this;
                var mousePageY = e.clientY;
                var onMouseMove = function(e) {
                    mousePageY = e.clientY;
                };
                var onMouseUp = function() {
                    clearInterval(timerId);
                };
                var startY = e.clientY;
                var startTop = this.thumbTop;
                var onScrollInterval = function() {
                    if (mousePageY === undefined) return;
                    var scrollTop = self1.scrollTopFromThumbTop(startTop + mousePageY - startY);
                    if (scrollTop === self1.scrollTop) return;
                    self1._emit("scroll", {
                        data: scrollTop
                    });
                };
                event.capture(this.inner, onMouseMove, onMouseUp);
                var timerId = setInterval(onScrollInterval, 20);
                return event.preventDefault(e);
            }
            var top = e.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", {
                data: this.scrollTopFromThumbTop(top)
            });
            return event.preventDefault(e);
        };
        VScrollBar.prototype.getHeight = function() {
            return this.height;
        };
        VScrollBar.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) scrollTop = 0;
            else if (scrollTop > this.pageHeight - this.viewHeight) scrollTop = this.pageHeight - this.viewHeight;
            return scrollTop;
        };
        VScrollBar.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        };
        VScrollBar.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
        };
        VScrollBar.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force) return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight) this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15) this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
                this.scrollTop = this.pageHeight - this.viewHeight;
                if (this.scrollTop < 0) this.scrollTop = 0;
                this._emit("scroll", {
                    data: this.scrollTop
                });
            }
        };
        VScrollBar.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0) scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
        };
        return VScrollBar;
    }(ScrollBar);
    VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
    var HScrollBar = /** @class */ function(_super) {
        __extends(HScrollBar, _super);
        function HScrollBar(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
        }
        HScrollBar.prototype.onMouseDown = function(eType, e) {
            if (eType !== "mousedown") return;
            if (event.getButton(e) !== 0 || e.detail === 2) return;
            if (e.target === this.inner) {
                var self1 = this;
                var mousePageX = e.clientX;
                var onMouseMove = function(e) {
                    mousePageX = e.clientX;
                };
                var onMouseUp = function() {
                    clearInterval(timerId);
                };
                var startX = e.clientX;
                var startLeft = this.thumbLeft;
                var onScrollInterval = function() {
                    if (mousePageX === undefined) return;
                    var scrollLeft = self1.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                    if (scrollLeft === self1.scrollLeft) return;
                    self1._emit("scroll", {
                        data: scrollLeft
                    });
                };
                event.capture(this.inner, onMouseMove, onMouseUp);
                var timerId = setInterval(onScrollInterval, 20);
                return event.preventDefault(e);
            }
            var left = e.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", {
                data: this.scrollLeftFromThumbLeft(left)
            });
            return event.preventDefault(e);
        };
        HScrollBar.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
        };
        HScrollBar.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) scrollLeft = 0;
            else if (scrollLeft > this.pageWidth - this.viewWidth) scrollLeft = this.pageWidth - this.viewWidth;
            return scrollLeft;
        };
        HScrollBar.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
        };
        HScrollBar.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force) return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth) this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15) this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
                this.scrollLeft = this.pageWidth - this.viewWidth;
                if (this.scrollLeft < 0) this.scrollLeft = 0;
                this._emit("scroll", {
                    data: this.scrollLeft
                });
            }
        };
        HScrollBar.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0) scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
        };
        return HScrollBar;
    }(ScrollBar);
    HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
    exports.ScrollBar = VScrollBar; // backward compatibility
    exports.ScrollBarV = VScrollBar; // backward compatibility
    exports.ScrollBarH = HScrollBar; // backward compatibility
    exports.VScrollBar = VScrollBar;
    exports.HScrollBar = HScrollBar;
});
ace.define("ace/renderloop", [
    "require",
    "exports",
    "module",
    "ace/lib/event"
], function(require, exports, module1) {
    "use strict";
    var event = require("./lib/event");
    var RenderLoop = /** @class */ function() {
        function RenderLoop(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts) {
                _self.pending = false;
                var changes = _self.changes;
                if (changes) {
                    event.blockIdle(100);
                    _self.changes = 0;
                    _self.onRender(changes);
                }
                if (_self.changes) {
                    if (_self.$recursionLimit-- < 0) return;
                    _self.schedule();
                } else _self.$recursionLimit = 2;
            };
        }
        RenderLoop.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
                event.nextFrame(this._flush);
                this.pending = true;
            }
        };
        RenderLoop.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
        };
        return RenderLoop;
    }();
    exports.RenderLoop = RenderLoop;
});
ace.define("ace/layer/font_metrics", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/lib/event",
    "ace/lib/useragent",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    var oop = require("../lib/oop");
    var dom = require("../lib/dom");
    var lang = require("../lib/lang");
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var CHAR_COUNT = 512;
    var USE_OBSERVER = typeof ResizeObserver == "function";
    var L = 200;
    var FontMetrics = /** @class */ function() {
        function FontMetrics(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = {
                width: 0,
                height: 0
            };
            if (USE_OBSERVER) this.$addObserver();
            else this.checkForSizeChanges();
        }
        FontMetrics.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) style["font-family"] = "inherit";
            else style.font = "inherit";
            style.overflow = isRoot ? "hidden" : "visible";
        };
        FontMetrics.prototype.checkForSizeChanges = function(size) {
            if (size === undefined) size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
                this.$measureNode.style.fontWeight = "bold";
                var boldSize = this.$measureSizes();
                this.$measureNode.style.fontWeight = "";
                this.$characterSize = size;
                this.charSizes = Object.create(null);
                this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
                this._emit("changeCharacterSize", {
                    data: size
                });
            }
        };
        FontMetrics.prototype.$addObserver = function() {
            var self1 = this;
            this.$observer = new window.ResizeObserver(function(e) {
                self1.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
        };
        FontMetrics.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer) return this.$pollSizeChangesTimer;
            var self1 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
                self1.checkForSizeChanges();
                event.onIdle(cb, 500);
            }, 500);
        };
        FontMetrics.prototype.setPolling = function(val) {
            if (val) this.$pollSizeChanges();
            else if (this.$pollSizeChangesTimer) {
                clearInterval(this.$pollSizeChangesTimer);
                this.$pollSizeChangesTimer = 0;
            }
        };
        FontMetrics.prototype.$measureSizes = function(node) {
            var size = {
                height: (node || this.$measureNode).clientHeight,
                width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0) return null;
            return size;
        };
        FontMetrics.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
        };
        FontMetrics.prototype.getCharacterWidth = function(ch) {
            var w = this.charSizes[ch];
            if (w === undefined) w = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            return w;
        };
        FontMetrics.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer) this.$observer.disconnect();
            if (this.el && this.el.parentNode) this.el.parentNode.removeChild(this.el);
        };
        FontMetrics.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement) return 1;
            return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
        };
        FontMetrics.prototype.$initTransformMeasureNodes = function() {
            var t = function(t, l) {
                return [
                    "div",
                    {
                        style: "position: absolute;top:" + t + "px;left:" + l + "px;"
                    }
                ];
            };
            this.els = dom.buildDom([
                t(0, 0),
                t(L, 0),
                t(0, L),
                t(L, L)
            ], this.el);
        };
        FontMetrics.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
                var zoom = this.$getZoom(this.el);
                clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
                var det = l1[1] * l2[0] - l1[0] * l2[1];
                return [
                    (-l2[1] * r[0] + l2[0] * r[1]) / det,
                    (+l1[1] * r[0] - l1[0] * r[1]) / det
                ];
            }
            function sub(a, b) {
                return [
                    a[0] - b[0],
                    a[1] - b[1]
                ];
            }
            function add(a, b) {
                return [
                    a[0] + b[0],
                    a[1] + b[1]
                ];
            }
            function mul(a, b) {
                return [
                    a * b[0],
                    a * b[1]
                ];
            }
            if (!this.els) this.$initTransformMeasureNodes();
            function p(el) {
                var r = el.getBoundingClientRect();
                return [
                    r.left,
                    r.top
                ];
            }
            var a = p(this.els[0]);
            var b = p(this.els[1]);
            var c = p(this.els[2]);
            var d = p(this.els[3]);
            var h = solve(sub(d, b), sub(d, c), sub(add(b, c), add(d, a)));
            var m1 = mul(1 + h[0], sub(b, a));
            var m2 = mul(1 + h[1], sub(c, a));
            if (elPos) {
                var x = elPos;
                var k = h[0] * x[0] / L + h[1] * x[1] / L + 1;
                var ut = add(mul(x[0], m1), mul(x[1], m2));
                return add(mul(1 / k / L, ut), a);
            }
            var u = sub(clientPos, a);
            var f = solve(sub(m1, mul(h[0], u)), sub(m2, mul(h[1], u)), u);
            return mul(L, f);
        };
        return FontMetrics;
    }();
    FontMetrics.prototype.$characterSize = {
        width: 0,
        height: 0
    };
    oop.implement(FontMetrics.prototype, EventEmitter);
    exports.FontMetrics = FontMetrics;
});
ace.define("ace/css/editor-css", [
    "require",
    "exports",
    "module"
], function(require, exports, module1) {
    module1.exports = '\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'Source Code Pro\', \'source-code-pro\', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n    forced-color-adjust: none;\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n.ace_invisible {\n    font-variant-ligatures: none;\n}\n\n.ace_keyboard-focus:focus {\n    box-shadow: inset 0 0 0 2px #5E9ED6;\n    outline: none;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: \'\';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: "";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell_svg-icons .ace_gutter_annotation {\n    margin-left: -14px;\n    float: left;\n}\n\n.ace_gutter-cell .ace_gutter_annotation {\n    margin-left: -19px;\n    float: left;\n}\n\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");\n}\n\n.ace_icon_svg.ace_error {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: darkorange;\n}\n.ace_icon_svg.ace_info {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: royalblue;\n}\n.ace_icon_svg.ace_hint {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");\n    background-color: silver;\n}\n\n.ace_icon_svg.ace_error_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_security_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");\n    background-color: darkorange;\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");\n}\n\n.ace_tooltip {\n    background-color: #f5f5f5;\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre-wrap;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n    overflow: auto;\n    max-width: min(33em, 66vw);\n    overscroll-behavior: contain;\n}\n.ace_tooltip pre {\n    white-space: pre-wrap;\n}\n\n.ace_tooltip.ace_dark {\n    background-color: #636363;\n    color: #fff;\n}\n\n.ace_tooltip:focus {\n    outline: 1px solid #5E9ED6;\n}\n\n.ace_icon {\n    display: inline-block;\n    width: 18px;\n    vertical-align: top;\n}\n\n.ace_icon_svg {\n    display: inline-block;\n    width: 12px;\n    vertical-align: top;\n    -webkit-mask-repeat: no-repeat;\n    -webkit-mask-size: 12px;\n    -webkit-mask-position: center;\n}\n\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_fold-widget, .ace_custom-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_custom-widget {\n    background: none;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    position: relative;\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n    z-index: 1;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n}\n\n.ace_ghost_text_container > div {\n    white-space: pre;\n}\n\n.ghost_text_line_wrapped::after {\n    content: "‚Ü©";\n    position: absolute;\n}\n\n.ace_lineWidgetContainer.ace_ghost_text {\n    margin: 0px 4px\n}\n\n.ace_screenreader-only {\n    position:absolute;\n    left:-10000px;\n    top:auto;\n    width:1px;\n    height:1px;\n    overflow:hidden;\n}\n\n.ace_hidden_token {\n    display: none;\n}';
});
ace.define("ace/layer/decorators", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/lib/oop",
    "ace/lib/event_emitter"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var oop = require("../lib/oop");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var Decorator = /** @class */ function() {
        function Decorator(parent, renderer) {
            this.parentEl = parent;
            this.canvas = dom.createElement("canvas");
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7px";
            this.canvas.style.position = "absolute";
            this.colors = {};
            this.colors.dark = {
                "error": "rgba(255, 18, 18, 1)",
                "warning": "rgba(18, 136, 18, 1)",
                "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
                "error": "rgb(255,51,51)",
                "warning": "rgb(32,133,72)",
                "info": "rgb(35,68,138)"
            };
            this.setDimensions();
            parent.element.appendChild(this.canvas);
        }
        Decorator.prototype.$updateDecorators = function(config) {
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            this.setDimensions(config);
            var ctx = this.canvas.getContext("2d");
            function compare(a, b) {
                if (a.priority < b.priority) return -1;
                if (a.priority > b.priority) return 1;
                return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
                var priorities = {
                    "info": 1,
                    "warning": 2,
                    "error": 3
                };
                annotations.forEach(function(item) {
                    item.priority = priorities[item.type] || null;
                });
                annotations = annotations.sort(compare);
                for(var i = 0; i < annotations.length; i++){
                    var row = annotations[i].row;
                    var compensateFold = this.compensateFoldRows(row);
                    var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                    var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                    var y2 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                    var height = y2 - y1;
                    if (height < this.minDecorationHeight) {
                        var yCenter = (y1 + y2) / 2 | 0;
                        if (yCenter < this.halfMinDecorationHeight) yCenter = this.halfMinDecorationHeight;
                        else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                        y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                        y2 = Math.round(yCenter + this.halfMinDecorationHeight);
                    }
                    ctx.fillStyle = colors[annotations[i].type] || null;
                    ctx.fillRect(0, currentY, this.canvasWidth, y2 - y1);
                }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
                var compensateFold = this.compensateFoldRows(cursor.row);
                var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
                ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
        };
        Decorator.prototype.compensateFoldRows = function(row) {
            var foldData = this.renderer.session.$foldData;
            var compensateFold = 0;
            if (foldData && foldData.length > 0) for(var j = 0; j < foldData.length; j++){
                if (row > foldData[j].start.row && row < foldData[j].end.row) compensateFold += row - foldData[j].start.row;
                else if (row >= foldData[j].end.row) compensateFold += foldData[j].end.row - foldData[j].start.row;
            }
            return compensateFold;
        };
        Decorator.prototype.compensateLineWidgets = function(row) {
            var widgetManager = this.renderer.session.widgetManager;
            if (widgetManager) {
                var delta_1 = 0;
                widgetManager.lineWidgets.forEach(function(el, index) {
                    if (row > index) delta_1 += el.rowCount || 0;
                });
                return delta_1 - 1;
            }
            return 0;
        };
        Decorator.prototype.setDimensions = function(config) {
            if (config) {
                this.maxHeight = config.maxHeight;
                this.lineHeight = config.lineHeight;
                this.canvasHeight = config.height;
                if (this.maxHeight < this.canvasHeight) this.heightRatio = 1;
                else this.heightRatio = this.canvasHeight / this.maxHeight;
            } else {
                this.canvasHeight = this.parentEl.parent.scrollHeight || this.canvasHeight;
                this.canvasWidth = this.parentEl.width || this.canvasWidth;
                this.heightRatio = this.canvasHeight / this.maxHeight;
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
            }
        };
        return Decorator;
    }();
    oop.implement(Decorator.prototype, EventEmitter);
    exports.Decorator = Decorator;
});
ace.define("ace/virtual_renderer", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/dom",
    "ace/lib/lang",
    "ace/config",
    "ace/layer/gutter",
    "ace/layer/marker",
    "ace/layer/text",
    "ace/layer/cursor",
    "ace/scrollbar",
    "ace/scrollbar",
    "ace/scrollbar_custom",
    "ace/scrollbar_custom",
    "ace/renderloop",
    "ace/layer/font_metrics",
    "ace/lib/event_emitter",
    "ace/css/editor-css",
    "ace/layer/decorators",
    "ace/lib/useragent",
    "ace/layer/text_util"
], function(require, exports, module1) {
    "use strict";
    var oop = require("./lib/oop");
    var dom = require("./lib/dom");
    var lang = require("./lib/lang");
    var config = require("./config");
    var GutterLayer = require("./layer/gutter").Gutter;
    var MarkerLayer = require("./layer/marker").Marker;
    var TextLayer = require("./layer/text").Text;
    var CursorLayer = require("./layer/cursor").Cursor;
    var HScrollBar = require("./scrollbar").HScrollBar;
    var VScrollBar = require("./scrollbar").VScrollBar;
    var HScrollBarCustom = require("./scrollbar_custom").HScrollBar;
    var VScrollBarCustom = require("./scrollbar_custom").VScrollBar;
    var RenderLoop = require("./renderloop").RenderLoop;
    var FontMetrics = require("./layer/font_metrics").FontMetrics;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var editorCss = require("./css/editor-css");
    var Decorator = require("./layer/decorators").Decorator;
    var useragent = require("./lib/useragent");
    var isTextToken = require("./layer/text_util").isTextToken;
    dom.importCssString(editorCss, "ace_editor.css", false);
    var VirtualRenderer = /** @class */ function() {
        function VirtualRenderer(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI) dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config.get("useStrictCSP") == null) config.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", "true");
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e) {
                if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e) {
                if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
                row: 0,
                column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e) {
                _self.updateCharacterSize();
                _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
                _self._signal("changeCharacterSize", e);
            });
            this.$size = {
                width: 0,
                height: 0,
                scrollerHeight: 0,
                scrollerWidth: 0,
                $dirty: true
            };
            this.layerConfig = {
                width: 1,
                padding: 0,
                firstRow: 0,
                firstRowScreen: 0,
                lastRow: 0,
                lineHeight: 0,
                characterWidth: 0,
                minHeight: 1,
                maxHeight: 1,
                offset: 0,
                height: 1,
                gutterOffset: 1
            };
            this.scrollMargin = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                v: 0,
                h: 0
            };
            this.margin = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
                v: 0,
                h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config.resetOptions(this);
            config._signal("renderer", this);
        }
        VirtualRenderer.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
                this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
                this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        };
        VirtualRenderer.prototype.setSession = function(session) {
            if (this.session) this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0) session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session) return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
        };
        VirtualRenderer.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === undefined) lastRow = Infinity;
            if (!this.$changedLines) this.$changedLines = {
                firstRow: firstRow,
                lastRow: lastRow
            };
            else {
                if (this.$changedLines.firstRow > firstRow) this.$changedLines.firstRow = firstRow;
                if (this.$changedLines.lastRow < lastRow) this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
                if (force) this.$changedLines.lastRow = this.layerConfig.lastRow;
                else return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow) return;
            this.$loop.schedule(this.CHANGE_LINES);
        };
        VirtualRenderer.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        };
        VirtualRenderer.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
        };
        VirtualRenderer.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
        };
        VirtualRenderer.prototype.updateFull = function(force) {
            if (force) this.$renderChanges(this.CHANGE_FULL, true);
            else this.$loop.schedule(this.CHANGE_FULL);
        };
        VirtualRenderer.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
        };
        VirtualRenderer.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending) this.$size.$dirty = true;
            else this.onResize();
        };
        VirtualRenderer.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2) return;
            else if (this.resizing > 0) this.resizing++;
            else this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height) height = el.clientHeight || el.scrollHeight;
            if (!height && this.$maxLines && this.lineHeight > 1) {
                if (!el.style.height || el.style.height == "0px") {
                    el.style.height = "1px";
                    height = el.clientHeight || el.scrollHeight;
                }
            }
            if (!width) width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer) this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height) return this.resizing = 0;
            if (force) this.$gutterLayer.$padding = null;
            if (force) this.$renderChanges(changes | this.$changes, true);
            else this.$loop.schedule(changes | this.$changes);
            if (this.resizing) this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) this.$updateCustomScrollbar(true);
        };
        VirtualRenderer.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
                width: size.width,
                height: size.height,
                scrollerHeight: size.scrollerHeight,
                scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
                size.height = height;
                changes |= this.CHANGE_SIZE;
                size.scrollerHeight = size.height;
                if (this.$horizScroll) size.scrollerHeight -= this.scrollBarH.getHeight();
                this.scrollBarV.setHeight(size.scrollerHeight);
                this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
                changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
                changes |= this.CHANGE_SIZE;
                size.width = width;
                if (gutterWidth == null) gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
                this.gutterWidth = gutterWidth;
                dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
                dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
                size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
                dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
                var right = this.scrollBarV.getWidth() + "px";
                dom.setStyle(this.scrollBarH.element.style, "right", right);
                dom.setStyle(this.scroller.style, "right", right);
                dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
                this.scrollBarH.setWidth(size.scrollerWidth);
                if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) changes |= this.CHANGE_FULL;
            }
            size.$dirty = !width || !height;
            if (changes) this._signal("resize", oldSize);
            return changes;
        };
        VirtualRenderer.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth) this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) this.$loop.schedule(this.CHANGE_FULL);
            else if (this.$size.$dirty) this.$loop.schedule(this.CHANGE_FULL);
            else this.$computeLayerConfig();
        };
        VirtualRenderer.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
        };
        VirtualRenderer.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
        };
        VirtualRenderer.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
        };
        VirtualRenderer.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
        };
        VirtualRenderer.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
        };
        VirtualRenderer.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
        };
        VirtualRenderer.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
        };
        VirtualRenderer.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
        };
        VirtualRenderer.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
        };
        VirtualRenderer.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
        };
        VirtualRenderer.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
        };
        VirtualRenderer.prototype.setPrintMarginColumn = function(printMarginColumn) {
            this.setOption("printMarginColumn", printMarginColumn);
        };
        VirtualRenderer.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
        };
        VirtualRenderer.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
        };
        VirtualRenderer.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
        };
        VirtualRenderer.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
        };
        VirtualRenderer.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
        };
        VirtualRenderer.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
        };
        VirtualRenderer.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
        };
        VirtualRenderer.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl) return;
            if (!this.$printMarginEl) {
                var containerEl = dom.createElement("div");
                containerEl.className = "ace_layer ace_print-margin-layer";
                this.$printMarginEl = dom.createElement("div");
                this.$printMarginEl.className = "ace_print-margin";
                containerEl.appendChild(this.$printMarginEl);
                this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1) this.adjustWrapLimit();
        };
        VirtualRenderer.prototype.getContainerElement = function() {
            return this.container;
        };
        VirtualRenderer.prototype.getMouseEventTarget = function() {
            return this.scroller;
        };
        VirtualRenderer.prototype.getTextAreaContainer = function() {
            return this.container;
        };
        VirtualRenderer.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed) return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
                dom.translate(this.textarea, -100, 0);
                return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos) return;
            if (composition && composition.markerRange) pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config.offset;
            var h = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config.height - h) {
                dom.translate(this.textarea, 0, 0);
                return;
            }
            var w = 1;
            var maxTop = this.$size.height - h;
            if (!composition) posTop += this.lineHeight;
            else if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
            } else posTop += this.lineHeight + 2;
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w) posLeft = this.$size.scrollerWidth - w;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h + "px");
            dom.setStyle(style, "width", w + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w), Math.min(posTop, maxTop));
        };
        VirtualRenderer.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
        };
        VirtualRenderer.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        };
        VirtualRenderer.prototype.getLastFullyVisibleRow = function() {
            var config = this.layerConfig;
            var lastRow = config.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config.lineHeight;
            if (top - this.session.getScrollTop() > config.height - config.lineHeight) return lastRow - 1;
            return lastRow;
        };
        VirtualRenderer.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
        };
        VirtualRenderer.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
        };
        VirtualRenderer.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session) this.session.setScrollTop(-sm.top);
            this.updateFull();
        };
        VirtualRenderer.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
        };
        VirtualRenderer.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
        };
        VirtualRenderer.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
        };
        VirtualRenderer.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
        };
        VirtualRenderer.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
        };
        VirtualRenderer.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
                scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
                if (this.scrollTop > scrollHeight - scrollerHeight) {
                    scrollHeight = this.scrollTop + scrollerHeight;
                    this.scrollBarV.scrollTop = null;
                }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        };
        VirtualRenderer.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        };
        VirtualRenderer.prototype.freeze = function() {
            this.$frozen = true;
        };
        VirtualRenderer.prototype.unfreeze = function() {
            this.$frozen = false;
        };
        VirtualRenderer.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
                changes |= this.$changes;
                this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
                this.$changes |= changes;
                return;
            }
            if (this.$size.$dirty) {
                this.$changes |= changes;
                return this.onResize(true);
            }
            if (!this.lineHeight) this.$textLayer.checkForSizeChanges();
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler) this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
                changes |= this.$computeLayerConfig() | this.$loop.clear();
                if (config.firstRow != this.layerConfig.firstRow && config.firstRowScreen == this.layerConfig.firstRowScreen) {
                    var st = this.scrollTop + (config.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                    if (st > 0) {
                        this.scrollTop = st;
                        changes = changes | this.CHANGE_SCROLL;
                        changes |= this.$computeLayerConfig() | this.$loop.clear();
                    }
                }
                config = this.layerConfig;
                this.$updateScrollBarV();
                if (changes & this.CHANGE_H_SCROLL) this.$updateScrollBarH();
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                var width = config.width + 2 * this.$padding + "px";
                var height = config.minHeight + "px";
                dom.setStyle(this.content.style, "width", width);
                dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
                dom.translate(this.content, -this.scrollLeft, -config.offset);
                this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
                if (this.enableKeyboardAccessibility) this.scroller.className += this.keyboardFocusClassName;
            }
            if (changes & this.CHANGE_FULL) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter) this.$gutterLayer.update(config);
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }
            if (changes & this.CHANGE_SCROLL) {
                this.$changedLines = null;
                if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES) this.$textLayer.update(config);
                else this.$textLayer.scrollLines(config);
                if (this.$showGutter) {
                    if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES) this.$gutterLayer.update(config);
                    else this.$gutterLayer.scrollLines(config);
                }
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
                this.$markerBack.update(config);
                this.$markerFront.update(config);
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
                this._signal("afterRender", changes);
                return;
            }
            if (changes & this.CHANGE_TEXT) {
                this.$changedLines = null;
                this.$textLayer.update(config);
                if (this.$showGutter) this.$gutterLayer.update(config);
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
            } else if (changes & this.CHANGE_LINES) {
                if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter) this.$gutterLayer.update(config);
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
                if (this.$showGutter) this.$gutterLayer.update(config);
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
            } else if (changes & this.CHANGE_CURSOR) {
                if (this.$highlightGutterLine) this.$gutterLayer.updateLineHighlight(config);
                if (this.$customScrollbar) this.$scrollDecorator.$updateDecorators(config);
            }
            if (changes & this.CHANGE_CURSOR) {
                this.$cursorLayer.update(config);
                this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) this.$markerFront.update(config);
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) this.$markerBack.update(config);
            this._signal("afterRender", changes);
        };
        VirtualRenderer.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll) desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight) desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
                if (vScroll != this.$vScroll) {
                    this.$vScroll = vScroll;
                    this.scrollBarV.setVisible(vScroll);
                }
                var w = this.container.clientWidth;
                this.container.style.height = desiredHeight + "px";
                this.$updateCachedSize(true, this.$gutterWidth, w, desiredHeight);
                this.desiredHeight = desiredHeight;
                this._signal("autosize");
            }
        };
        VirtualRenderer.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
                this.$horizScroll = horizScroll;
                this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll; // autosize can change vscroll value in which case we need to update longestLine
            if (this.$maxLines && this.lineHeight > 1) {
                this.$autosize();
                hideScrollbars = size.height <= 2 * this.lineHeight;
            }
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) firstRow = foldLine.start.row;
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            if (offset < 0 && firstRowScreen > 0) {
                firstRowScreen = Math.max(0, firstRowScreen + Math.floor(offset / lineHeight));
                offset = this.scrollTop - firstRowScreen * lineHeight;
            }
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged) changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
                changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
                this._signal("scrollbarVisibilityChanged");
                if (vScrollChanged) longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
                width: longestLine,
                padding: this.$padding,
                firstRow: firstRow,
                firstRowScreen: firstRowScreen,
                lastRow: lastRow,
                lineHeight: lineHeight,
                characterWidth: this.characterWidth,
                minHeight: minHeight,
                maxHeight: maxHeight,
                offset: offset,
                gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
                height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler) this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
        };
        VirtualRenderer.prototype.$updateLines = function() {
            if (!this.$changedLines) return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) return;
            if (lastRow < layerConfig.firstRow) return;
            if (lastRow === Infinity) {
                if (this.$showGutter) this.$gutterLayer.update(layerConfig);
                this.$textLayer.update(layerConfig);
                return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
        };
        VirtualRenderer.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode) charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH) charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
        };
        VirtualRenderer.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        };
        VirtualRenderer.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
        };
        VirtualRenderer.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
        };
        VirtualRenderer.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
        };
        VirtualRenderer.prototype.updateBreakpoints = function(rows) {
            this._rows = rows;
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        VirtualRenderer.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
        };
        VirtualRenderer.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
        };
        VirtualRenderer.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
        };
        VirtualRenderer.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
        };
        VirtualRenderer.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
        };
        VirtualRenderer.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0) return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) this.$stopAnimation = true;
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
                if (offset && currentTop + topMargin > newTop + this.lineHeight) newTop -= offset * this.$size.scrollerHeight;
                if (newTop === 0) newTop = -this.scrollMargin.top;
                this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
                if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight) newTop += offset * this.$size.scrollerHeight;
                this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
                newLeft -= twoCharsWidth;
                if (newLeft < this.$padding + twoCharsWidth) newLeft = -this.scrollMargin.left;
                this.session.setScrollLeft(newLeft);
            } else {
                newLeft += twoCharsWidth;
                if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
                else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) this.session.setScrollLeft(0);
            }
        };
        VirtualRenderer.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
        };
        VirtualRenderer.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
        };
        VirtualRenderer.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
        };
        VirtualRenderer.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        };
        VirtualRenderer.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
        };
        VirtualRenderer.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number") cursor = {
                row: cursor,
                column: 0
            };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
        };
        VirtualRenderer.prototype.$calcSteps = function(fromValue, toValue) {
            var i = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t, x_min, dx) {
                return dx * (Math.pow(t - 1, 3) + 1) + x_min;
            };
            for(i = 0; i < l; ++i)steps.push(func(i / this.STEPS, fromValue, toValue - fromValue));
            return steps;
        };
        VirtualRenderer.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({
                row: line,
                column: 0
            });
            var offset = pos.top;
            if (center) offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false) this.animateScrolling(initialScroll, callback);
        };
        VirtualRenderer.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll) return;
            var _self = this;
            if (fromValue == toValue) return;
            if (this.$scrollAnimation) {
                var oldSteps = this.$scrollAnimation.steps;
                if (oldSteps.length) {
                    fromValue = oldSteps[0];
                    if (fromValue == toValue) return;
                }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = {
                from: fromValue,
                to: toValue,
                steps: steps
            };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
                _self.$timer = clearInterval(_self.$timer);
                _self.$scrollAnimation = null;
                _self.$stopAnimation = false;
                callback && callback();
            }
            this.$timer = setInterval(function() {
                if (_self.$stopAnimation) {
                    endAnimation();
                    return;
                }
                if (!_self.session) return clearInterval(_self.$timer);
                if (steps.length) {
                    _self.session.setScrollTop(steps.shift());
                    _self.session.$scrollTop = toValue;
                } else if (toValue != null) {
                    _self.session.$scrollTop = -1;
                    _self.session.setScrollTop(toValue);
                    toValue = null;
                } else endAnimation();
            }, 10);
        };
        VirtualRenderer.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
                this.$loop.schedule(this.CHANGE_SCROLL);
                this.scrollTop = scrollTop;
            }
        };
        VirtualRenderer.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft) this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
        };
        VirtualRenderer.prototype.scrollTo = function(x, y) {
            this.session.setScrollTop(y);
            this.session.setScrollLeft(x);
        };
        VirtualRenderer.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
        };
        VirtualRenderer.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top) return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom) return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left) return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right) return true;
        };
        VirtualRenderer.prototype.pixelToScreenCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {
                    top: 0,
                    left: 0
                };
                var p = this.$fontMetrics.transformCoordinates([
                    x,
                    y
                ]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else canvasPos = this.scroller.getBoundingClientRect();
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return {
                row: row,
                column: col,
                side: offset - col > 0 ? 1 : -1,
                offsetX: offsetX
            };
        };
        VirtualRenderer.prototype.screenToTextCoordinates = function(x, y) {
            var canvasPos;
            if (this.$hasCssTransforms) {
                canvasPos = {
                    top: 0,
                    left: 0
                };
                var p = this.$fontMetrics.transformCoordinates([
                    x,
                    y
                ]);
                x = p[1] - this.gutterWidth - this.margin.left;
                y = p[0];
            } else canvasPos = this.scroller.getBoundingClientRect();
            var offsetX = x + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
        };
        VirtualRenderer.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y = pos.row * this.lineHeight;
            return {
                pageX: canvasPos.left + x - this.scrollLeft,
                pageY: canvasPos.top + y - this.scrollTop
            };
        };
        VirtualRenderer.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
        };
        VirtualRenderer.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
        };
        VirtualRenderer.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) composition.cssText = this.textarea.style.cssText;
            if (composition.useTextareaForIME == undefined) composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
                dom.addCssClass(this.textarea, "ace_composition");
                this.textarea.style.cssText = "";
                this.$moveTextAreaToCursor();
                this.$cursorLayer.element.style.display = "none";
            } else composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
        };
        VirtualRenderer.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
        };
        VirtualRenderer.prototype.hideComposition = function() {
            if (!this.$composition) return;
            if (this.$composition.markerId) this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
        };
        VirtualRenderer.prototype.setGhostText = function(text, position) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position || {
                row: cursor.row,
                column: cursor.column
            };
            this.removeGhostText();
            var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
            this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
                text: text,
                position: {
                    row: insertPosition.row,
                    column: insertPosition.column
                }
            };
            var widgetDiv = dom.createElement("div");
            if (textChunks.length > 1) {
                var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
                var lastLineDiv;
                textChunks.slice(1).forEach(function(el) {
                    var chunkDiv = dom.createElement("div");
                    var chunkSpan = dom.createElement("span");
                    chunkSpan.className = "ace_ghost_text";
                    if (el.wrapped) chunkDiv.className = "ghost_text_line_wrapped";
                    if (el.text.length === 0) el.text = " ";
                    chunkSpan.appendChild(dom.createTextNode(el.text));
                    chunkDiv.appendChild(chunkSpan);
                    widgetDiv.appendChild(chunkDiv);
                    lastLineDiv = chunkDiv;
                });
                hiddenTokens.forEach(function(token) {
                    var element = dom.createElement("span");
                    if (!isTextToken(token.type)) element.className = "ace_" + token.type.replace(/\./g, " ace_");
                    element.appendChild(dom.createTextNode(token.value));
                    lastLineDiv.appendChild(element);
                });
                this.$ghostTextWidget = {
                    el: widgetDiv,
                    row: insertPosition.row,
                    column: insertPosition.column,
                    className: "ace_ghost_text_container"
                };
                this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
                var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
                var el = this.container;
                var height = el.getBoundingClientRect().height;
                var ghostTextHeight = textChunks.length * this.lineHeight;
                var fitsY = ghostTextHeight < height - pixelPosition.top;
                if (fitsY) return;
                if (ghostTextHeight < height) this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
                else this.scrollToRow(insertPosition.row);
            }
        };
        VirtualRenderer.prototype.$calculateWrappedTextChunks = function(text, position) {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth) - 2;
            limit = limit <= 0 ? 60 : limit; // this is a hack to prevent the editor from crashing when the window is too small
            var textLines = text.split(/\r?\n/);
            var textChunks = [];
            for(var i = 0; i < textLines.length; i++){
                var displayTokens = this.session.$getDisplayTokens(textLines[i], position.column);
                var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);
                if (wrapSplits.length > 0) {
                    var start = 0;
                    wrapSplits.push(textLines[i].length);
                    for(var j = 0; j < wrapSplits.length; j++){
                        var textSlice = textLines[i].slice(start, wrapSplits[j]);
                        textChunks.push({
                            text: textSlice,
                            wrapped: true
                        });
                        start = wrapSplits[j];
                    }
                } else textChunks.push({
                    text: textLines[i],
                    wrapped: false
                });
            }
            return textChunks;
        };
        VirtualRenderer.prototype.removeGhostText = function() {
            if (!this.$ghostText) return;
            var position = this.$ghostText.position;
            this.removeExtraToken(position.row, position.column);
            if (this.$ghostTextWidget) {
                this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
                this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
        };
        VirtualRenderer.prototype.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = {
                type: type,
                value: text
            };
            var tokens = session.getTokens(row);
            if (column == null || !tokens.length) tokens.push(newToken);
            else {
                var l = 0;
                for(var i = 0; i < tokens.length; i++){
                    var token = tokens[i];
                    l += token.value.length;
                    if (column <= l) {
                        var diff = token.value.length - (l - column);
                        var before = token.value.slice(0, diff);
                        var after = token.value.slice(diff);
                        tokens.splice(i, 1, {
                            type: token.type,
                            value: before
                        }, newToken, {
                            type: token.type,
                            value: after
                        });
                        break;
                    }
                }
            }
            this.updateLines(row, row);
        };
        VirtualRenderer.prototype.hideTokensAfterPosition = function(row, column) {
            var tokens = this.session.getTokens(row);
            var l = 0;
            var hasPassedCursor = false;
            var hiddenTokens = [];
            for(var i = 0; i < tokens.length; i++){
                var token = tokens[i];
                l += token.value.length;
                if (token.type === "ghost_text") continue;
                if (hasPassedCursor) {
                    hiddenTokens.push({
                        type: token.type,
                        value: token.value
                    });
                    token.type = "hidden_token";
                    continue;
                }
                if (l === column) hasPassedCursor = true;
            }
            this.updateLines(row, row);
            return hiddenTokens;
        };
        VirtualRenderer.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
        };
        VirtualRenderer.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", {
                theme: theme
            });
            if (!theme || typeof theme == "string") {
                var moduleName = theme || this.$options.theme.initialValue;
                config.loadModule([
                    "theme",
                    moduleName
                ], afterLoad);
            } else afterLoad(theme);
            function afterLoad(module1) {
                if (_self.$themeId != theme) return cb && cb();
                if (!module1 || !module1.cssClass) throw new Error("couldn't load module " + theme + " or it didn't call define");
                if (module1.$id) _self.$themeId = module1.$id;
                dom.importCssString(module1.cssText, module1.cssClass, _self.container);
                if (_self.theme) dom.removeCssClass(_self.container, _self.theme.cssClass);
                var padding = "padding" in module1 ? module1.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
                if (_self.$padding && padding != _self.$padding) _self.setPadding(padding);
                _self.$theme = module1.cssClass;
                _self.theme = module1;
                dom.addCssClass(_self.container, module1.cssClass);
                dom.setCssClass(_self.container, "ace_dark", module1.isDark);
                if (_self.$size) {
                    _self.$size.width = 0;
                    _self.$updateSizeAsync();
                }
                _self._dispatchEvent("themeLoaded", {
                    theme: module1
                });
                cb && cb();
                if (useragent.isSafari && _self.scroller) {
                    _self.scroller.style.background = "red";
                    _self.scroller.style.background = "";
                }
            }
        };
        VirtualRenderer.prototype.getTheme = function() {
            return this.$themeId;
        };
        VirtualRenderer.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
        };
        VirtualRenderer.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
        };
        VirtualRenderer.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
        };
        VirtualRenderer.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
        };
        VirtualRenderer.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
        };
        VirtualRenderer.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
        };
        VirtualRenderer.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (this.$scrollDecorator) delete this.$scrollDecorator;
            if (val === true) {
                this.scrollBarV = new VScrollBarCustom(this.container, this);
                this.scrollBarH = new HScrollBarCustom(this.container, this);
                this.scrollBarV.setHeight(this.$size.scrollerHeight);
                this.scrollBarH.setWidth(this.$size.scrollerWidth);
                this.scrollBarV.addEventListener("scroll", function(e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH.addEventListener("scroll", function(e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                });
                this.$scrollDecorator = new Decorator(this.scrollBarV, this);
                this.$scrollDecorator.$updateDecorators();
            } else {
                this.scrollBarV = new VScrollBar(this.container, this);
                this.scrollBarH = new HScrollBar(this.container, this);
                this.scrollBarV.addEventListener("scroll", function(e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollTop(e.data - _self.scrollMargin.top);
                });
                this.scrollBarH.addEventListener("scroll", function(e) {
                    if (!_self.$scrollAnimation) _self.session.setScrollLeft(e.data - _self.scrollMargin.left);
                });
            }
        };
        VirtualRenderer.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver) return;
            var self1 = this;
            this.$resizeTimer = lang.delayedCall(function() {
                if (!self1.destroyed) self1.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e) {
                var w = e[0].contentRect.width;
                var h = e[0].contentRect.height;
                if (Math.abs(self1.$size.width - w) > 1 || Math.abs(self1.$size.height - h) > 1) self1.$resizeTimer.delay();
                else self1.$resizeTimer.cancel();
            });
            this.$resizeObserver.observe(this.container);
        };
        return VirtualRenderer;
    }();
    VirtualRenderer.prototype.CHANGE_CURSOR = 1;
    VirtualRenderer.prototype.CHANGE_MARKER = 2;
    VirtualRenderer.prototype.CHANGE_GUTTER = 4;
    VirtualRenderer.prototype.CHANGE_SCROLL = 8;
    VirtualRenderer.prototype.CHANGE_LINES = 16;
    VirtualRenderer.prototype.CHANGE_TEXT = 32;
    VirtualRenderer.prototype.CHANGE_SIZE = 64;
    VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
    VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
    VirtualRenderer.prototype.CHANGE_FULL = 512;
    VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
    VirtualRenderer.prototype.$changes = 0;
    VirtualRenderer.prototype.$padding = null;
    VirtualRenderer.prototype.$frozen = false;
    VirtualRenderer.prototype.STEPS = 8;
    oop.implement(VirtualRenderer.prototype, EventEmitter);
    config.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
            set: function(value) {
                if (!value && this.$resizeObserver) {
                    this.$resizeObserver.disconnect();
                    this.$resizeTimer.cancel();
                    this.$resizeTimer = this.$resizeObserver = null;
                } else if (value && !this.$resizeObserver) this.$addResizeObserver();
            }
        },
        animatedScroll: {
            initialValue: false
        },
        showInvisibles: {
            set: function(value) {
                if (this.$textLayer.setShowInvisibles(value)) this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: false
        },
        showPrintMargin: {
            set: function() {
                this.$updatePrintMargin();
            },
            initialValue: true
        },
        printMarginColumn: {
            set: function() {
                this.$updatePrintMargin();
            },
            initialValue: 80
        },
        printMargin: {
            set: function(val) {
                if (typeof val == "number") this.$printMarginColumn = val;
                this.$showPrintMargin = !!val;
                this.$updatePrintMargin();
            },
            get: function() {
                return this.$showPrintMargin && this.$printMarginColumn;
            }
        },
        showGutter: {
            set: function(show) {
                this.$gutter.style.display = show ? "block" : "none";
                this.$loop.schedule(this.CHANGE_FULL);
                this.onGutterResize();
            },
            initialValue: true
        },
        useSvgGutterIcons: {
            set: function(value) {
                this.$gutterLayer.$useSvgGutterIcons = value;
            },
            initialValue: false
        },
        showFoldedAnnotations: {
            set: function(value) {
                this.$gutterLayer.$showFoldedAnnotations = value;
            },
            initialValue: false
        },
        fadeFoldWidgets: {
            set: function(show) {
                dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
            },
            initialValue: false
        },
        showFoldWidgets: {
            set: function(show) {
                this.$gutterLayer.setShowFoldWidgets(show);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        displayIndentGuides: {
            set: function(show) {
                if (this.$textLayer.setDisplayIndentGuides(show)) this.$loop.schedule(this.CHANGE_TEXT);
            },
            initialValue: true
        },
        highlightIndentGuides: {
            set: function(show) {
                if (this.$textLayer.setHighlightIndentGuides(show) == true) this.$textLayer.$highlightIndentGuide();
                else this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            },
            initialValue: true
        },
        highlightGutterLine: {
            set: function(shouldHighlight) {
                this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
                this.$loop.schedule(this.CHANGE_GUTTER);
            },
            initialValue: true
        },
        hScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        vScrollBarAlwaysVisible: {
            set: function(val) {
                if (!this.$vScrollBarAlwaysVisible || !this.$vScroll) this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: false
        },
        fontSize: {
            set: function(size) {
                if (typeof size == "number") size = size + "px";
                this.container.style.fontSize = size;
                this.updateFontSize();
            },
            initialValue: 12
        },
        fontFamily: {
            set: function(name) {
                this.container.style.fontFamily = name;
                this.updateFontSize();
            }
        },
        maxLines: {
            set: function(val) {
                this.updateFull();
            }
        },
        minLines: {
            set: function(val) {
                if (!(this.$minLines < 0x1ffffffffffff)) this.$minLines = 0;
                this.updateFull();
            }
        },
        maxPixelHeight: {
            set: function(val) {
                this.updateFull();
            },
            initialValue: 0
        },
        scrollPastEnd: {
            set: function(val) {
                val = +val || 0;
                if (this.$scrollPastEnd == val) return;
                this.$scrollPastEnd = val;
                this.$loop.schedule(this.CHANGE_SCROLL);
            },
            initialValue: 0,
            handlesSet: true
        },
        fixedWidthGutter: {
            set: function(val) {
                this.$gutterLayer.$fixedWidth = !!val;
                this.$loop.schedule(this.CHANGE_GUTTER);
            }
        },
        customScrollbar: {
            set: function(val) {
                this.$updateCustomScrollbar(val);
            },
            initialValue: false
        },
        theme: {
            set: function(val) {
                this.setTheme(val);
            },
            get: function() {
                return this.$themeId || this.theme;
            },
            initialValue: "./theme/textmate",
            handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
            initialValue: !useragent.isMobile && !useragent.isIE
        }
    });
    exports.VirtualRenderer = VirtualRenderer;
});
ace.define("ace/worker/worker_client", [
    "require",
    "exports",
    "module",
    "ace/lib/oop",
    "ace/lib/net",
    "ace/lib/event_emitter",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    var oop = require("../lib/oop");
    var net = require("../lib/net");
    var EventEmitter = require("../lib/event_emitter").EventEmitter;
    var config = require("../config");
    function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
            return new Blob([
                script
            ], {
                "type": "application/javascript"
            });
        } catch (e) {
            var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
            var blobBuilder = new BlobBuilder();
            blobBuilder.append(script);
            return blobBuilder.getBlob("application/javascript");
        }
    }
    function createWorker(workerUrl) {
        if (typeof Worker == "undefined") return {
            postMessage: function() {},
            terminate: function() {}
        };
        if (config.get("loadWorkerFromBlob")) {
            var blob = $workerBlob(workerUrl);
            var URL = window.URL || window.webkitURL;
            var blobURL = URL.createObjectURL(blob);
            return new Worker(blobURL);
        }
        return new Worker(workerUrl);
    }
    var WorkerClient = function(worker) {
        if (!worker.postMessage) worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
    };
    (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
            if (require.nameToUrl && !require.toUrl) require.toUrl = require.nameToUrl;
            if (config.get("packaged") || !require.toUrl) workerUrl = workerUrl || config.moduleUrl(mod, "worker");
            else {
                var normalizePath = this.$normalizePath;
                workerUrl = workerUrl || normalizePath(require.toUrl("ace/worker/worker.js", null, "_"));
                var tlns = {};
                topLevelNamespaces.forEach(function(ns) {
                    tlns[ns] = normalizePath(require.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
                });
            }
            this.$worker = createWorker(workerUrl);
            if (importScripts) this.send("importScripts", importScripts);
            this.$worker.postMessage({
                init: true,
                tlns: tlns,
                module: mod,
                classname: classname
            });
            return this.$worker;
        };
        this.onMessage = function(e) {
            var msg = e.data;
            switch(msg.type){
                case "event":
                    this._signal(msg.name, {
                        data: msg.data
                    });
                    break;
                case "call":
                    var callback = this.callbacks[msg.id];
                    if (callback) {
                        callback(msg.data);
                        delete this.callbacks[msg.id];
                    }
                    break;
                case "error":
                    this.reportError(msg.data);
                    break;
                case "log":
                    window.console && console.log && console.log.apply(console, msg.data);
                    break;
            }
        };
        this.reportError = function(err) {
            window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
            return net.qualifyURL(path);
        };
        this.terminate = function() {
            this._signal("terminate", {});
            this.deltaQueue = null;
            this.$worker.terminate();
            this.$worker.onerror = function(e) {
                e.preventDefault();
            };
            this.$worker = null;
            if (this.$doc) this.$doc.off("change", this.changeListener);
            this.$doc = null;
        };
        this.send = function(cmd, args) {
            this.$worker.postMessage({
                command: cmd,
                args: args
            });
        };
        this.call = function(cmd, args, callback) {
            if (callback) {
                var id = this.callbackId++;
                this.callbacks[id] = callback;
                args.push(id);
            }
            this.send(cmd, args);
        };
        this.emit = function(event, data) {
            try {
                if (data.data && data.data.err) data.data.err = {
                    message: data.data.err.message,
                    stack: data.data.err.stack,
                    code: data.data.err.code
                };
                this.$worker && this.$worker.postMessage({
                    event: event,
                    data: {
                        data: data.data
                    }
                });
            } catch (ex) {
                console.error(ex.stack);
            }
        };
        this.attachToDocument = function(doc) {
            if (this.$doc) this.terminate();
            this.$doc = doc;
            this.call("setValue", [
                doc.getValue()
            ]);
            doc.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
            if (!this.deltaQueue) {
                this.deltaQueue = [];
                setTimeout(this.$sendDeltaQueue, 0);
            }
            if (delta.action == "insert") this.deltaQueue.push(delta.start, delta.lines);
            else this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
            var q = this.deltaQueue;
            if (!q) return;
            this.deltaQueue = null;
            if (q.length > 50 && q.length > this.$doc.getLength() >> 1) this.call("setValue", [
                this.$doc.getValue()
            ]);
            else this.emit("change", {
                data: q
            });
        };
    }).call(WorkerClient.prototype);
    var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
            messageBuffer: messageBuffer,
            terminate: function() {},
            postMessage: function(e) {
                messageBuffer.push(e);
                if (!main) return;
                if (emitSync) setTimeout(processNext);
                else processNext();
            }
        });
        workerClient.setEmitSync = function(val) {
            emitSync = val;
        };
        var processNext = function() {
            var msg = messageBuffer.shift();
            if (msg.command) main[msg.command].apply(main, msg.args);
            else if (msg.event) sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
            workerClient.onMessage({
                data: msg
            });
        };
        sender.callback = function(data, callbackId) {
            this.postMessage({
                type: "call",
                id: callbackId,
                data: data
            });
        };
        sender.emit = function(name, data) {
            this.postMessage({
                type: "event",
                name: name,
                data: data
            });
        };
        config.loadModule([
            "worker",
            mod
        ], function(Main) {
            main = new Main[classname](sender);
            while(messageBuffer.length)processNext();
        });
        return workerClient;
    };
    exports.UIWorkerClient = UIWorkerClient;
    exports.WorkerClient = WorkerClient;
    exports.createWorker = createWorker;
});
ace.define("ace/placeholder", [
    "require",
    "exports",
    "module",
    "ace/range",
    "ace/lib/event_emitter",
    "ace/lib/oop"
], function(require, exports, module1) {
    "use strict";
    var Range = require("./range").Range;
    var EventEmitter = require("./lib/event_emitter").EventEmitter;
    var oop = require("./lib/oop");
    var PlaceHolder = /** @class */ function() {
        function PlaceHolder(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
                setTimeout(function() {
                    _self.onCursorChange();
                });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || {
                length: -1
            };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
        }
        PlaceHolder.prototype.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode) session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
                var anchor = doc.createAnchor(other.row, other.column);
                anchor.$insertRight = true;
                anchor.detach();
                _self.others.push(anchor);
            });
            session.setUndoSelect(false);
        };
        PlaceHolder.prototype.showOtherMarkers = function() {
            if (this.othersActive) return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
                anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
        };
        PlaceHolder.prototype.hideOtherMarkers = function() {
            if (!this.othersActive) return;
            this.othersActive = false;
            for(var i = 0; i < this.others.length; i++)this.session.removeMarker(this.others[i].markerId);
        };
        PlaceHolder.prototype.onUpdate = function(delta) {
            if (this.$updating) return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row) return;
            if (range.start.row !== this.pos.row) return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange) this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
                if (delta.action === "insert") for(var i = this.others.length - 1; i >= 0; i--){
                    var otherPos = this.others[i];
                    var newPos = {
                        row: otherPos.row,
                        column: otherPos.column + distanceFromStart
                    };
                    this.doc.insertMergedLines(newPos, delta.lines);
                }
                else if (delta.action === "remove") for(var i = this.others.length - 1; i >= 0; i--){
                    var otherPos = this.others[i];
                    var newPos = {
                        row: otherPos.row,
                        column: otherPos.column + distanceFromStart
                    };
                    this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
            }
            this.$updating = false;
            this.updateMarkers();
        };
        PlaceHolder.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for(var i = this.others.length; i--;)this.others[i].onChange(delta);
            this.updateMarkers();
        };
        PlaceHolder.prototype.updateMarkers = function() {
            if (this.$updating) return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
                session.removeMarker(pos.markerId);
                pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for(var i = this.others.length; i--;)updateMarker(this.others[i], this.othersClass);
        };
        PlaceHolder.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session) return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
                this.showOtherMarkers();
                this._emit("cursorEnter", event);
            } else {
                this.hideOtherMarkers();
                this._emit("cursorLeave", event);
            }
        };
        PlaceHolder.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
        };
        PlaceHolder.prototype.cancel = function() {
            if (this.$undoStackDepth === -1) return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
            for(var i = 0; i < undosRequired; i++)undoManager.undo(this.session, true);
            if (this.selectionBefore) this.session.selection.fromJSON(this.selectionBefore);
        };
        return PlaceHolder;
    }();
    oop.implement(PlaceHolder.prototype, EventEmitter);
    exports.PlaceHolder = PlaceHolder;
});
ace.define("ace/mouse/multi_select_handler", [
    "require",
    "exports",
    "module",
    "ace/lib/event",
    "ace/lib/useragent"
], function(require, exports, module1) {
    var event = require("../lib/event");
    var useragent = require("../lib/useragent");
    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }
    function onMouseDown(e) {
        var ev = e.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e.getAccelKey();
        var button = e.getButton();
        if (ctrl && useragent.isMac) button = ev.button;
        if (e.editor.inMultiSelectMode && button == 2) {
            e.editor.textInput.onContextMenu(e.domEvent);
            return;
        }
        if (!ctrl && !alt && !accel) {
            if (button === 0 && e.editor.inMultiSelectMode) e.editor.exitMultiSelectMode();
            return;
        }
        if (button !== 0) return;
        var editor = e.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e.x, mouseY = e.y;
        var onMouseSelection = function(e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
            if (ctrl && alt || accel && alt) selectionMode = shift ? "block" : "add";
            else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
        } else {
            if (accel && !alt) {
                selectionMode = "add";
                if (!isMultiSelect && shift) return;
            } else if (alt && editor.$blockSelectEnabled) selectionMode = "block";
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) editor.$mouseHandler.cancelContextMenu();
        if (selectionMode == "add") {
            if (!isMultiSelect && inSelection) return; // dragging
            if (!isMultiSelect) {
                var range = selection.toOrientedRange();
                editor.addSelectionMarker(range);
            }
            var oldRange = selection.rangeList.rangeAtPoint(pos);
            editor.inVirtualSelectionMode = true;
            if (shift) {
                oldRange = null;
                range = selection.ranges[0] || range;
                editor.removeSelectionMarker(range);
            }
            editor.once("mouseup", function() {
                var tmpSel = selection.toOrientedRange();
                if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor)) selection.substractPoint(tmpSel.cursor);
                else {
                    if (shift) selection.substractPoint(range.cursor);
                    else if (range) {
                        editor.removeSelectionMarker(range);
                        selection.addRange(range);
                    }
                    selection.addRange(tmpSel);
                }
                editor.inVirtualSelectionMode = false;
            });
        } else if (selectionMode == "block") {
            e.stop();
            editor.inVirtualSelectionMode = true;
            var initialRange;
            var rectSel = [];
            var blockSelect = function() {
                var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
                var cursor = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
                if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor, selection.lead)) return;
                screenCursor = newCursor;
                editor.selection.moveToPosition(cursor);
                editor.renderer.scrollCursorIntoView();
                editor.removeSelectionMarkers(rectSel);
                rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
                if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty()) rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
                rectSel.forEach(editor.addSelectionMarker, editor);
                editor.updateSelectionMarkers();
            };
            if (isMultiSelect && !accel) selection.toSingleRange();
            else if (!isMultiSelect && accel) {
                initialRange = selection.toOrientedRange();
                editor.addSelectionMarker(initialRange);
            }
            if (shift) screenAnchor = session.documentToScreenPosition(selection.lead);
            else selection.moveToPosition(pos);
            screenCursor = {
                row: -1,
                column: -1
            };
            var onMouseSelectionEnd = function(e) {
                blockSelect();
                clearInterval(timerId);
                editor.removeSelectionMarkers(rectSel);
                if (!rectSel.length) rectSel = [
                    selection.toOrientedRange()
                ];
                if (initialRange) {
                    editor.removeSelectionMarker(initialRange);
                    selection.toSingleRange(initialRange);
                }
                for(var i = 0; i < rectSel.length; i++)selection.addRange(rectSel[i]);
                editor.inVirtualSelectionMode = false;
                editor.$mouseHandler.$clickSelection = null;
            };
            var onSelectionInterval = blockSelect;
            event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
            var timerId = setInterval(function() {
                onSelectionInterval();
            }, 20);
            return e.preventDefault();
        }
    }
    exports.onMouseDown = onMouseDown;
});
ace.define("ace/commands/multi_select_commands", [
    "require",
    "exports",
    "module",
    "ace/keyboard/hash_handler"
], function(require, exports, module1) {
    exports.defaultCommands = [
        {
            name: "addCursorAbove",
            description: "Add cursor above",
            exec: function(editor) {
                editor.selectMoreLines(-1);
            },
            bindKey: {
                win: "Ctrl-Alt-Up",
                mac: "Ctrl-Alt-Up"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "addCursorBelow",
            description: "Add cursor below",
            exec: function(editor) {
                editor.selectMoreLines(1);
            },
            bindKey: {
                win: "Ctrl-Alt-Down",
                mac: "Ctrl-Alt-Down"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "addCursorAboveSkipCurrent",
            description: "Add cursor above (skip current)",
            exec: function(editor) {
                editor.selectMoreLines(-1, true);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Up",
                mac: "Ctrl-Alt-Shift-Up"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "addCursorBelowSkipCurrent",
            description: "Add cursor below (skip current)",
            exec: function(editor) {
                editor.selectMoreLines(1, true);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Down",
                mac: "Ctrl-Alt-Shift-Down"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectMoreBefore",
            description: "Select more before",
            exec: function(editor) {
                editor.selectMore(-1);
            },
            bindKey: {
                win: "Ctrl-Alt-Left",
                mac: "Ctrl-Alt-Left"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectMoreAfter",
            description: "Select more after",
            exec: function(editor) {
                editor.selectMore(1);
            },
            bindKey: {
                win: "Ctrl-Alt-Right",
                mac: "Ctrl-Alt-Right"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectNextBefore",
            description: "Select next before",
            exec: function(editor) {
                editor.selectMore(-1, true);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Left",
                mac: "Ctrl-Alt-Shift-Left"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "selectNextAfter",
            description: "Select next after",
            exec: function(editor) {
                editor.selectMore(1, true);
            },
            bindKey: {
                win: "Ctrl-Alt-Shift-Right",
                mac: "Ctrl-Alt-Shift-Right"
            },
            scrollIntoView: "cursor",
            readOnly: true
        },
        {
            name: "toggleSplitSelectionIntoLines",
            description: "Split selection into lines",
            exec: function(editor) {
                if (editor.multiSelect.rangeCount > 1) editor.multiSelect.joinSelections();
                else editor.multiSelect.splitIntoLines();
            },
            bindKey: {
                win: "Ctrl-Alt-L",
                mac: "Ctrl-Alt-L"
            },
            readOnly: true
        },
        {
            name: "splitSelectionIntoLines",
            description: "Split into lines",
            exec: function(editor) {
                editor.multiSelect.splitIntoLines();
            },
            readOnly: true
        },
        {
            name: "alignCursors",
            description: "Align cursors",
            exec: function(editor) {
                editor.alignCursors();
            },
            bindKey: {
                win: "Ctrl-Alt-A",
                mac: "Ctrl-Alt-A"
            },
            scrollIntoView: "cursor"
        },
        {
            name: "findAll",
            description: "Find all",
            exec: function(editor) {
                editor.findAll();
            },
            bindKey: {
                win: "Ctrl-Alt-K",
                mac: "Ctrl-Alt-G"
            },
            scrollIntoView: "cursor",
            readOnly: true
        }
    ];
    exports.multiSelectCommands = [
        {
            name: "singleSelection",
            description: "Single selection",
            bindKey: "esc",
            exec: function(editor) {
                editor.exitMultiSelectMode();
            },
            scrollIntoView: "cursor",
            readOnly: true,
            isAvailable: function(editor) {
                return editor && editor.inMultiSelectMode;
            }
        }
    ];
    var HashHandler = require("../keyboard/hash_handler").HashHandler;
    exports.keyboardHandler = new HashHandler(exports.multiSelectCommands);
});
ace.define("ace/multi_select", [
    "require",
    "exports",
    "module",
    "ace/range_list",
    "ace/range",
    "ace/selection",
    "ace/mouse/multi_select_handler",
    "ace/lib/event",
    "ace/lib/lang",
    "ace/commands/multi_select_commands",
    "ace/search",
    "ace/edit_session",
    "ace/editor",
    "ace/config"
], function(require, exports, module1) {
    var RangeList = require("./range_list").RangeList;
    var Range = require("./range").Range;
    var Selection = require("./selection").Selection;
    var onMouseDown = require("./mouse/multi_select_handler").onMouseDown;
    var event = require("./lib/event");
    var lang = require("./lib/lang");
    var commands = require("./commands/multi_select_commands");
    exports.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
    var Search = require("./search").Search;
    var search = new Search();
    function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
    }
    var EditSession = require("./edit_session").EditSession;
    (function() {
        this.getSelectionMarkers = function() {
            return this.$selectionMarkers;
        };
    }).call(EditSession.prototype);
    (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
            if (!range) return;
            if (!this.inMultiSelectMode && this.rangeCount === 0) {
                var oldRange = this.toOrientedRange();
                this.rangeList.add(oldRange);
                this.rangeList.add(range);
                if (this.rangeList.ranges.length != 2) {
                    this.rangeList.removeAll();
                    return $blockChangeEvents || this.fromOrientedRange(range);
                }
                this.rangeList.removeAll();
                this.rangeList.add(oldRange);
                this.$onAddRange(oldRange);
            }
            if (!range.cursor) range.cursor = range.end;
            var removed = this.rangeList.add(range);
            this.$onAddRange(range);
            if (removed.length) this.$onRemoveRange(removed);
            if (this.rangeCount > 1 && !this.inMultiSelectMode) {
                this._signal("multiSelect");
                this.inMultiSelectMode = true;
                this.session.$undoSelect = false;
                this.rangeList.attach(this.session);
            }
            return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
            range = range || this.ranges[0];
            var removed = this.rangeList.removeAll();
            if (removed.length) this.$onRemoveRange(removed);
            range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
            var removed = this.rangeList.substractPoint(pos);
            if (removed) {
                this.$onRemoveRange(removed);
                return removed[0];
            }
        };
        this.mergeOverlappingRanges = function() {
            var removed = this.rangeList.merge();
            if (removed.length) this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
            this.rangeCount = this.rangeList.ranges.length;
            this.ranges.unshift(range);
            this._signal("addRange", {
                range: range
            });
        };
        this.$onRemoveRange = function(removed) {
            this.rangeCount = this.rangeList.ranges.length;
            if (this.rangeCount == 1 && this.inMultiSelectMode) {
                var lastRange = this.rangeList.ranges.pop();
                removed.push(lastRange);
                this.rangeCount = 0;
            }
            for(var i = removed.length; i--;){
                var index = this.ranges.indexOf(removed[i]);
                this.ranges.splice(index, 1);
            }
            this._signal("removeRange", {
                ranges: removed
            });
            if (this.rangeCount === 0 && this.inMultiSelectMode) {
                this.inMultiSelectMode = false;
                this._signal("singleSelect");
                this.session.$undoSelect = true;
                this.rangeList.detach(this.session);
            }
            lastRange = lastRange || this.ranges[0];
            if (lastRange && !lastRange.isEqual(this.getRange())) this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
            if (this.rangeList) return;
            this.rangeList = new RangeList();
            this.ranges = [];
            this.rangeCount = 0;
        };
        this.getAllRanges = function() {
            return this.rangeCount ? this.rangeList.ranges.concat() : [
                this.getRange()
            ];
        };
        this.splitIntoLines = function() {
            var ranges = this.ranges.length ? this.ranges : [
                this.getRange()
            ];
            var newRanges = [];
            for(var i = 0; i < ranges.length; i++){
                var range = ranges[i];
                var row = range.start.row;
                var endRow = range.end.row;
                if (row === endRow) newRanges.push(range.clone());
                else {
                    newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
                    while(++row < endRow)newRanges.push(this.getLineRange(row, true));
                    newRanges.push(new Range(endRow, 0, endRow, range.end.column));
                }
                if (i == 0 && !this.isBackwards()) newRanges = newRanges.reverse();
            }
            this.toSingleRange();
            for(var i = newRanges.length; i--;)this.addRange(newRanges[i]);
        };
        this.joinSelections = function() {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
            if (this.rangeCount > 1) {
                var ranges = this.rangeList.ranges;
                var lastRange = ranges[ranges.length - 1];
                var range = Range.fromPoints(ranges[0].start, lastRange.end);
                this.toSingleRange();
                this.setSelectionRange(range, lastRange.cursor == lastRange.start);
            } else {
                var cursor = this.session.documentToScreenPosition(this.cursor);
                var anchor = this.session.documentToScreenPosition(this.anchor);
                var rectSel = this.rectangularRangeBlock(cursor, anchor);
                rectSel.forEach(this.addRange, this);
            }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
            var rectSel = [];
            var xBackwards = screenCursor.column < screenAnchor.column;
            if (xBackwards) {
                var startColumn = screenCursor.column;
                var endColumn = screenAnchor.column;
                var startOffsetX = screenCursor.offsetX;
                var endOffsetX = screenAnchor.offsetX;
            } else {
                var startColumn = screenAnchor.column;
                var endColumn = screenCursor.column;
                var startOffsetX = screenAnchor.offsetX;
                var endOffsetX = screenCursor.offsetX;
            }
            var yBackwards = screenCursor.row < screenAnchor.row;
            if (yBackwards) {
                var startRow = screenCursor.row;
                var endRow = screenAnchor.row;
            } else {
                var startRow = screenAnchor.row;
                var endRow = screenCursor.row;
            }
            if (startColumn < 0) startColumn = 0;
            if (startRow < 0) startRow = 0;
            if (startRow == endRow) includeEmptyLines = true;
            var docEnd;
            for(var row = startRow; row <= endRow; row++){
                var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
                if (range.isEmpty()) {
                    if (docEnd && isSamePoint(range.end, docEnd)) break;
                    docEnd = range.end;
                }
                range.cursor = xBackwards ? range.start : range.end;
                rectSel.push(range);
            }
            if (yBackwards) rectSel.reverse();
            if (!includeEmptyLines) {
                var end = rectSel.length - 1;
                while(rectSel[end].isEmpty() && end > 0)end--;
                if (end > 0) {
                    var start = 0;
                    while(rectSel[start].isEmpty())start++;
                }
                for(var i = end; i >= start; i--)if (rectSel[i].isEmpty()) rectSel.splice(i, 1);
            }
            return rectSel;
        };
    }).call(Selection.prototype);
    var Editor = require("./editor").Editor;
    (function() {
        this.updateSelectionMarkers = function() {
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
            if (!orientedRange.cursor) orientedRange.cursor = orientedRange.end;
            var style = this.getSelectionStyle();
            orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
            this.session.$selectionMarkers.push(orientedRange);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
            return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
            if (!range.marker) return;
            this.session.removeMarker(range.marker);
            var index = this.session.$selectionMarkers.indexOf(range);
            if (index != -1) this.session.$selectionMarkers.splice(index, 1);
            this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
            var markerList = this.session.$selectionMarkers;
            for(var i = ranges.length; i--;){
                var range = ranges[i];
                if (!range.marker) continue;
                this.session.removeMarker(range.marker);
                var index = markerList.indexOf(range);
                if (index != -1) markerList.splice(index, 1);
            }
            this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e) {
            this.addSelectionMarker(e.range);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e) {
            this.removeSelectionMarkers(e.ranges);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e) {
            if (this.inMultiSelectMode) return;
            this.inMultiSelectMode = true;
            this.setStyle("ace_multiselect");
            this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
            this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e) {
            if (this.session.multiSelect.inVirtualMode) return;
            this.inMultiSelectMode = false;
            this.unsetStyle("ace_multiselect");
            this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
            this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
            this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e) {
            var command = e.command;
            var editor = e.editor;
            if (!editor.multiSelect) return;
            if (!command.multiSelectAction) {
                var result = command.exec(editor, e.args || {});
                editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
                editor.multiSelect.mergeOverlappingRanges();
            } else if (command.multiSelectAction == "forEach") result = editor.forEachSelection(command, e.args);
            else if (command.multiSelectAction == "forEachLine") result = editor.forEachSelection(command, e.args, true);
            else if (command.multiSelectAction == "single") {
                editor.exitMultiSelectMode();
                result = command.exec(editor, e.args || {});
            } else result = command.multiSelectAction(editor, e.args || {});
            return result;
        };
        this.forEachSelection = function(cmd, args, options) {
            if (this.inVirtualSelectionMode) return;
            var keepOrder = options && options.keepOrder;
            var $byLines = options == true || options && options.$byLines;
            var session = this.session;
            var selection = this.selection;
            var rangeList = selection.rangeList;
            var ranges = (keepOrder ? selection : rangeList).ranges;
            var result;
            if (!ranges.length) return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            var reg = selection._eventRegistry;
            selection._eventRegistry = {};
            var tmpSel = new Selection(session);
            this.inVirtualSelectionMode = true;
            for(var i = ranges.length; i--;){
                if ($byLines) while(i > 0 && ranges[i].start.row == ranges[i - 1].end.row)i--;
                tmpSel.fromOrientedRange(ranges[i]);
                tmpSel.index = i;
                this.selection = session.selection = tmpSel;
                var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
                if (!result && cmdResult !== undefined) result = cmdResult;
                tmpSel.toOrientedRange(ranges[i]);
            }
            tmpSel.detach();
            this.selection = session.selection = selection;
            this.inVirtualSelectionMode = false;
            selection._eventRegistry = reg;
            selection.mergeOverlappingRanges();
            if (selection.ranges[0]) selection.fromOrientedRange(selection.ranges[0]);
            var anim = this.renderer.$scrollAnimation;
            this.onCursorChange();
            this.onSelectionChange();
            if (anim && anim.from == anim.to) this.renderer.animateScrolling(anim.from);
            return result;
        };
        this.exitMultiSelectMode = function() {
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) return;
            this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
            var text = "";
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var ranges = this.multiSelect.rangeList.ranges;
                var buf = [];
                for(var i = 0; i < ranges.length; i++)buf.push(this.session.getTextRange(ranges[i]));
                var nl = this.session.getDocument().getNewLineCharacter();
                text = buf.join(nl);
                if (text.length == (buf.length - 1) * nl.length) text = "";
            } else if (!this.selection.isEmpty()) text = this.session.getTextRange(this.getSelectionRange());
            return text;
        };
        this.$checkMultiselectChange = function(e, anchor) {
            if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
                var range = this.multiSelect.ranges[0];
                if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor) return;
                var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
                if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column) this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
                else this.multiSelect.mergeOverlappingRanges();
            }
        };
        this.findAll = function(needle, options, additive) {
            options = options || {};
            options.needle = needle || options.needle;
            if (options.needle == undefined) {
                var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
                options.needle = this.session.getTextRange(range);
            }
            this.$search.set(options);
            var ranges = this.$search.findAll(this.session);
            if (!ranges.length) return 0;
            var selection = this.multiSelect;
            if (!additive) selection.toSingleRange(ranges[0]);
            for(var i = ranges.length; i--;)selection.addRange(ranges[i], true);
            if (range && selection.rangeList.rangeAtPoint(range.start)) selection.addRange(range, true);
            return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
            var range = this.selection.toOrientedRange();
            var isBackwards = range.cursor == range.end;
            var screenLead = this.session.documentToScreenPosition(range.cursor);
            if (this.selection.$desiredColumn) screenLead.column = this.selection.$desiredColumn;
            var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
            if (!range.isEmpty()) {
                var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
                var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
            } else var anchor = lead;
            if (isBackwards) {
                var newRange = Range.fromPoints(lead, anchor);
                newRange.cursor = newRange.start;
            } else {
                var newRange = Range.fromPoints(anchor, lead);
                newRange.cursor = newRange.end;
            }
            newRange.desiredColumn = screenLead.column;
            if (!this.selection.inMultiSelectMode) this.selection.addRange(range);
            else if (skip) var toRemove = range.cursor;
            this.selection.addRange(newRange);
            if (toRemove) this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
            var session = this.session;
            var sel = session.multiSelect;
            var all = sel.ranges;
            for(var i = all.length; i--;){
                var range = all[i];
                if (range.isEmpty()) {
                    var tmp_1 = session.getWordRange(range.start.row, range.start.column);
                    range.start.row = tmp_1.start.row;
                    range.start.column = tmp_1.start.column;
                    range.end.row = tmp_1.end.row;
                    range.end.column = tmp_1.end.column;
                }
            }
            sel.mergeOverlappingRanges();
            var words = [];
            for(var i = all.length; i--;){
                var range = all[i];
                words.unshift(session.getTextRange(range));
            }
            if (dir < 0) words.unshift(words.pop());
            else words.push(words.shift());
            for(var i = all.length; i--;){
                var range = all[i];
                var tmp = range.clone();
                session.replace(range, words[i]);
                range.start.row = tmp.start.row;
                range.start.column = tmp.start.column;
            }
            sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
            var session = this.session;
            var sel = session.multiSelect;
            var range = sel.toOrientedRange();
            if (range.isEmpty()) {
                range = session.getWordRange(range.start.row, range.start.column);
                range.cursor = dir == -1 ? range.start : range.end;
                this.multiSelect.addRange(range);
                if (stopAtFirst) return;
            }
            var needle = session.getTextRange(range);
            var newRange = find(session, needle, dir);
            if (newRange) {
                newRange.cursor = dir == -1 ? newRange.start : newRange.end;
                this.session.unfold(newRange);
                this.multiSelect.addRange(newRange);
                this.renderer.scrollCursorIntoView(null, 0.5);
            }
            if (skip) this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
            var session = this.session;
            var sel = session.multiSelect;
            var ranges = sel.ranges;
            var row = -1;
            var sameRowRanges = ranges.filter(function(r) {
                if (r.cursor.row == row) return true;
                row = r.cursor.row;
            });
            if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
                var range = this.selection.getRange();
                var fr = range.start.row, lr = range.end.row;
                var guessRange = fr == lr;
                if (guessRange) {
                    var max = this.session.getLength();
                    var line;
                    do line = this.session.getLine(lr);
                    while (/[=:]/.test(line) && ++lr < max);
                    do line = this.session.getLine(fr);
                    while (/[=:]/.test(line) && --fr > 0);
                    if (fr < 0) fr = 0;
                    if (lr >= max) lr = max - 1;
                }
                var lines = this.session.removeFullLines(fr, lr);
                lines = this.$reAlignText(lines, guessRange);
                this.session.insert({
                    row: fr,
                    column: 0
                }, lines.join("\n") + "\n");
                if (!guessRange) {
                    range.start.column = 0;
                    range.end.column = lines[lines.length - 1].length;
                }
                this.selection.setRange(range);
            } else {
                sameRowRanges.forEach(function(r) {
                    sel.substractPoint(r.cursor);
                });
                var maxCol = 0;
                var minSpace = Infinity;
                var spaceOffsets = ranges.map(function(r) {
                    var p = r.cursor;
                    var line = session.getLine(p.row);
                    var spaceOffset = line.substr(p.column).search(/\S/g);
                    if (spaceOffset == -1) spaceOffset = 0;
                    if (p.column > maxCol) maxCol = p.column;
                    if (spaceOffset < minSpace) minSpace = spaceOffset;
                    return spaceOffset;
                });
                ranges.forEach(function(r, i) {
                    var p = r.cursor;
                    var l = maxCol - p.column;
                    var d = spaceOffsets[i] - minSpace;
                    if (l > d) session.insert(p, lang.stringRepeat(" ", l - d));
                    else session.remove(new Range(p.row, p.column, p.row, p.column - l + d));
                    r.start.column = r.end.column = maxCol;
                    r.start.row = r.end.row = p.row;
                    r.cursor = r.end;
                });
                sel.fromOrientedRange(ranges[0]);
                this.renderer.updateCursor();
                this.renderer.updateBackMarkers();
            }
        };
        this.$reAlignText = function(lines, forceLeft) {
            var isLeftAligned = true, isRightAligned = true;
            var startW, textW, endW;
            return lines.map(function(line) {
                var m = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
                if (!m) return [
                    line
                ];
                if (startW == null) {
                    startW = m[1].length;
                    textW = m[2].length;
                    endW = m[3].length;
                    return m;
                }
                if (startW + textW + endW != m[1].length + m[2].length + m[3].length) isRightAligned = false;
                if (startW != m[1].length) isLeftAligned = false;
                if (startW > m[1].length) startW = m[1].length;
                if (textW < m[2].length) textW = m[2].length;
                if (endW > m[3].length) endW = m[3].length;
                return m;
            }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
            function spaces(n) {
                return lang.stringRepeat(" ", n);
            }
            function alignLeft(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(textW - m[2].length + endW) + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function alignRight(m) {
                return !m[2] ? m[0] : spaces(startW + textW - m[2].length) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
            }
            function unAlign(m) {
                return !m[2] ? m[0] : spaces(startW) + m[2] + spaces(endW) + m[4].replace(/^([=:])\s+/, "$1 ");
            }
        };
    }).call(Editor.prototype);
    function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
    }
    exports.onSessionChange = function(e) {
        var session = e.session;
        if (session && !session.multiSelect) {
            session.$selectionMarkers = [];
            session.selection.$initRangeList();
            session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e.oldSession;
        if (oldSession) {
            oldSession.multiSelect.off("addRange", this.$onAddRange);
            oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
            oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
            oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
            oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
            oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
            session.multiSelect.on("addRange", this.$onAddRange);
            session.multiSelect.on("removeRange", this.$onRemoveRange);
            session.multiSelect.on("multiSelect", this.$onMultiSelect);
            session.multiSelect.on("singleSelect", this.$onSingleSelect);
            session.multiSelect.lead.on("change", this.$checkMultiselectChange);
            session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
            if (session.selection.inMultiSelectMode) this.$onMultiSelect();
            else this.$onSingleSelect();
        }
    };
    function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange) return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
    }
    function addAltCursorListeners(editor) {
        if (!editor.textInput) return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e) {
            var altDown = e.keyCode == 18 && !(e.ctrlKey || e.shiftKey || e.metaKey);
            if (editor.$blockSelectEnabled && altDown) {
                if (!altCursor) {
                    editor.renderer.setMouseCursor("crosshair");
                    altCursor = true;
                }
            } else if (altCursor) reset();
        }, editor);
        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e) {
            if (altCursor) {
                editor.renderer.setMouseCursor("");
                altCursor = false;
            }
        }
    }
    exports.MultiSelect = MultiSelect;
    require("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
            set: function(val) {
                MultiSelect(this);
                if (val) this.on("mousedown", onMouseDown);
                else this.off("mousedown", onMouseDown);
            },
            value: true
        },
        enableBlockSelect: {
            set: function(val) {
                this.$blockSelectEnabled = val;
            },
            value: true
        }
    });
});
ace.define("ace/mode/folding/fold_mode", [
    "require",
    "exports",
    "module",
    "ace/range"
], function(require, exports, module1) {
    "use strict";
    var Range = require("../../range").Range;
    var FoldMode = exports.FoldMode = function() {};
    (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
            var line = session.getLine(row);
            if (this.foldingStartMarker.test(line)) return "start";
            if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line)) return "end";
            return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
            return null;
        };
        this.indentationBlock = function(session, row, column) {
            var re = /\S/;
            var line = session.getLine(row);
            var startLevel = line.search(re);
            if (startLevel == -1) return;
            var startColumn = column || line.length;
            var maxRow = session.getLength();
            var startRow = row;
            var endRow = row;
            while(++row < maxRow){
                var level = session.getLine(row).search(re);
                if (level == -1) continue;
                if (level <= startLevel) {
                    var token = session.getTokenAt(row, 0);
                    if (!token || token.type !== "string") break;
                }
                endRow = row;
            }
            if (endRow > startRow) {
                var endColumn = session.getLine(endRow).length;
                return new Range(startRow, startColumn, endRow, endColumn);
            }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
            var start = {
                row: row,
                column: column + 1
            };
            var end = session.$findClosingBracket(bracket, start, typeRe);
            if (!end) return;
            var fw = session.foldWidgets[end.row];
            if (fw == null) fw = session.getFoldWidget(end.row);
            if (fw == "start" && end.row > start.row) {
                end.row--;
                end.column = session.getLine(end.row).length;
            }
            return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
            var end = {
                row: row,
                column: column
            };
            var start = session.$findOpeningBracket(bracket, end);
            if (!start) return;
            start.column++;
            end.column--;
            return Range.fromPoints(start, end);
        };
    }).call(FoldMode.prototype);
});
ace.define("ace/ext/error_marker", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/range",
    "ace/config"
], function(require, exports, module1) {
    "use strict";
    var dom = require("../lib/dom");
    var Range = require("../range").Range;
    var nls = require("../config").nls;
    function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while(first <= last){
            var mid = first + last >> 1;
            var c = comparator(needle, array[mid]);
            if (c > 0) first = mid + 1;
            else if (c < 0) last = mid - 1;
            else return mid;
        }
        return -(first + 1);
    }
    function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length) return;
        var i = binarySearch(annotations, {
            row: row,
            column: -1
        }, Range.comparePoints);
        if (i < 0) i = -i - 1;
        if (i >= annotations.length) i = dir > 0 ? 0 : annotations.length - 1;
        else if (i === 0 && dir < 0) i = annotations.length - 1;
        var annotation = annotations[i];
        if (!annotation || !dir) return;
        if (annotation.row === row) {
            do annotation = annotations[i += dir];
            while (annotation && annotation.row === row);
            if (!annotation) return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
            matched[dir < 0 ? "unshift" : "push"](annotation);
            annotation = annotations[i += dir];
        }while (annotation && annotation.row == row);
        return matched.length && matched;
    }
    exports.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w) {
            return w.type == "errorMarker";
        })[0];
        if (oldWidget) oldWidget.destroy();
        else row -= dir;
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
            var annotation = annotations[0];
            pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
            pos.row = annotation.row;
            gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) return;
        else gutterAnno = {
            displayText: [
                nls("error-marker.good-state", "Looks good!")
            ],
            className: "ace_ok"
        };
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w = {
            row: pos.row,
            fixedWidth: true,
            coverGutter: true,
            el: dom.createElement("div"),
            type: "errorMarker"
        };
        var el = w.el.appendChild(dom.createElement("div"));
        var arrow = w.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        gutterAnno.displayText.forEach(function(annoTextLine, i) {
            el.appendChild(dom.createTextNode(annoTextLine));
            if (i < gutterAnno.displayText.length - 1) el.appendChild(dom.createElement("br"));
        });
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
            if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
                w.destroy();
                return {
                    command: "null"
                };
            }
        };
        w.destroy = function() {
            if (editor.$mouseHandler.isMousePressed) return;
            editor.keyBinding.removeKeyboardHandler(kb);
            session.widgetManager.removeLineWidget(w);
            editor.off("changeSelection", w.destroy);
            editor.off("changeSession", w.destroy);
            editor.off("mouseup", w.destroy);
            editor.off("change", w.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w.destroy);
        editor.on("changeSession", w.destroy);
        editor.on("mouseup", w.destroy);
        editor.on("change", w.destroy);
        editor.session.widgetManager.addLineWidget(w);
        w.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, {
            bottom: w.el.offsetHeight
        });
    };
    dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
});
ace.define("ace/ace", [
    "require",
    "exports",
    "module",
    "ace/lib/dom",
    "ace/range",
    "ace/editor",
    "ace/edit_session",
    "ace/undomanager",
    "ace/virtual_renderer",
    "ace/worker/worker_client",
    "ace/keyboard/hash_handler",
    "ace/placeholder",
    "ace/multi_select",
    "ace/mode/folding/fold_mode",
    "ace/theme/textmate",
    "ace/ext/error_marker",
    "ace/config",
    "ace/loader_build"
], function(require, exports, module1) {
    "use strict";
    require("./loader_build")(exports);
    var dom = require("./lib/dom");
    var Range = require("./range").Range;
    var Editor = require("./editor").Editor;
    var EditSession = require("./edit_session").EditSession;
    var UndoManager = require("./undomanager").UndoManager;
    var Renderer = require("./virtual_renderer").VirtualRenderer;
    require("./worker/worker_client");
    require("./keyboard/hash_handler");
    require("./placeholder");
    require("./multi_select");
    require("./mode/folding/fold_mode");
    require("./theme/textmate");
    require("./ext/error_marker");
    exports.config = require("./config");
    exports.edit = function(el, options) {
        if (typeof el == "string") {
            var _id = el;
            el = document.getElementById(_id);
            if (!el) throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor) return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
            var oldNode = el;
            value = oldNode.value;
            el = dom.createElement("pre");
            oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
            value = el.textContent;
            el.innerHTML = "";
        }
        var doc = exports.createEditSession(value);
        var editor = new Editor(new Renderer(el), doc, options);
        var env = {
            document: doc,
            editor: editor,
            onResize: editor.resize.bind(editor, null)
        };
        if (oldNode) env.textarea = oldNode;
        editor.on("destroy", function() {
            env.editor.container.env = null; // prevent memory leak on old ie
        });
        editor.container.env = editor.env = env;
        return editor;
    };
    exports.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
    };
    exports.Range = Range;
    exports.Editor = Editor;
    exports.EditSession = EditSession;
    exports.UndoManager = UndoManager;
    exports.VirtualRenderer = Renderer;
    var version = exports.config.version;
    exports.version = version;
});
(function() {
    ace.require([
        "ace/ace"
    ], function(a) {
        if (a) {
            a.config.init(true);
            a.define = ace.define;
        }
        var global = function() {
            return this;
        }();
        if (!global && typeof window != "undefined") global = window; // can happen in strict mode
        if (!global && typeof self != "undefined") global = self; // can happen in webworker
        if (!global.ace) global.ace = a;
        for(var key in a)if (a.hasOwnProperty(key)) global.ace[key] = a[key];
        global.ace["default"] = global.ace;
        if (module) module.exports = global.ace;
    });
})();

},{}],"3EO9f":[function() {},{}]},["eha9F","hTFxQ"], "hTFxQ", "parcelRequire55a5")

//# sourceMappingURL=index.1b6425ef.js.map
